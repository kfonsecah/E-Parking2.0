
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model ep_clients
 * 
 */
export type ep_clients = $Result.DefaultSelection<Prisma.$ep_clientsPayload>
/**
 * Model ep_informartion
 * 
 */
export type ep_informartion = $Result.DefaultSelection<Prisma.$ep_informartionPayload>
/**
 * Model ep_packages
 * 
 */
export type ep_packages = $Result.DefaultSelection<Prisma.$ep_packagesPayload>
/**
 * Model ep_role
 * 
 */
export type ep_role = $Result.DefaultSelection<Prisma.$ep_rolePayload>
/**
 * Model ep_server
 * 
 */
export type ep_server = $Result.DefaultSelection<Prisma.$ep_serverPayload>
/**
 * Model ep_tax
 * 
 */
export type ep_tax = $Result.DefaultSelection<Prisma.$ep_taxPayload>
/**
 * Model ep_users
 * 
 */
export type ep_users = $Result.DefaultSelection<Prisma.$ep_usersPayload>
/**
 * Model ep_vehicles
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 */
export type ep_vehicles = $Result.DefaultSelection<Prisma.$ep_vehiclesPayload>
/**
 * Model ep_cash_per_day
 * 
 */
export type ep_cash_per_day = $Result.DefaultSelection<Prisma.$ep_cash_per_dayPayload>
/**
 * Model ep_cashier
 * 
 */
export type ep_cashier = $Result.DefaultSelection<Prisma.$ep_cashierPayload>
/**
 * Model ep_cashier_transaction
 * 
 */
export type ep_cashier_transaction = $Result.DefaultSelection<Prisma.$ep_cashier_transactionPayload>
/**
 * Model ep_notes
 * 
 */
export type ep_notes = $Result.DefaultSelection<Prisma.$ep_notesPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Ep_clients
 * const ep_clients = await prisma.ep_clients.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Ep_clients
   * const ep_clients = await prisma.ep_clients.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.ep_clients`: Exposes CRUD operations for the **ep_clients** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ep_clients
    * const ep_clients = await prisma.ep_clients.findMany()
    * ```
    */
  get ep_clients(): Prisma.ep_clientsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ep_informartion`: Exposes CRUD operations for the **ep_informartion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ep_informartions
    * const ep_informartions = await prisma.ep_informartion.findMany()
    * ```
    */
  get ep_informartion(): Prisma.ep_informartionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ep_packages`: Exposes CRUD operations for the **ep_packages** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ep_packages
    * const ep_packages = await prisma.ep_packages.findMany()
    * ```
    */
  get ep_packages(): Prisma.ep_packagesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ep_role`: Exposes CRUD operations for the **ep_role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ep_roles
    * const ep_roles = await prisma.ep_role.findMany()
    * ```
    */
  get ep_role(): Prisma.ep_roleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ep_server`: Exposes CRUD operations for the **ep_server** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ep_servers
    * const ep_servers = await prisma.ep_server.findMany()
    * ```
    */
  get ep_server(): Prisma.ep_serverDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ep_tax`: Exposes CRUD operations for the **ep_tax** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ep_taxes
    * const ep_taxes = await prisma.ep_tax.findMany()
    * ```
    */
  get ep_tax(): Prisma.ep_taxDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ep_users`: Exposes CRUD operations for the **ep_users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ep_users
    * const ep_users = await prisma.ep_users.findMany()
    * ```
    */
  get ep_users(): Prisma.ep_usersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ep_vehicles`: Exposes CRUD operations for the **ep_vehicles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ep_vehicles
    * const ep_vehicles = await prisma.ep_vehicles.findMany()
    * ```
    */
  get ep_vehicles(): Prisma.ep_vehiclesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ep_cash_per_day`: Exposes CRUD operations for the **ep_cash_per_day** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ep_cash_per_days
    * const ep_cash_per_days = await prisma.ep_cash_per_day.findMany()
    * ```
    */
  get ep_cash_per_day(): Prisma.ep_cash_per_dayDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ep_cashier`: Exposes CRUD operations for the **ep_cashier** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ep_cashiers
    * const ep_cashiers = await prisma.ep_cashier.findMany()
    * ```
    */
  get ep_cashier(): Prisma.ep_cashierDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ep_cashier_transaction`: Exposes CRUD operations for the **ep_cashier_transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ep_cashier_transactions
    * const ep_cashier_transactions = await prisma.ep_cashier_transaction.findMany()
    * ```
    */
  get ep_cashier_transaction(): Prisma.ep_cashier_transactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ep_notes`: Exposes CRUD operations for the **ep_notes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ep_notes
    * const ep_notes = await prisma.ep_notes.findMany()
    * ```
    */
  get ep_notes(): Prisma.ep_notesDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.5.0
   * Query Engine version: 173f8d54f8d52e692c7e27e72a88314ec7aeff60
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    ep_clients: 'ep_clients',
    ep_informartion: 'ep_informartion',
    ep_packages: 'ep_packages',
    ep_role: 'ep_role',
    ep_server: 'ep_server',
    ep_tax: 'ep_tax',
    ep_users: 'ep_users',
    ep_vehicles: 'ep_vehicles',
    ep_cash_per_day: 'ep_cash_per_day',
    ep_cashier: 'ep_cashier',
    ep_cashier_transaction: 'ep_cashier_transaction',
    ep_notes: 'ep_notes'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "ep_clients" | "ep_informartion" | "ep_packages" | "ep_role" | "ep_server" | "ep_tax" | "ep_users" | "ep_vehicles" | "ep_cash_per_day" | "ep_cashier" | "ep_cashier_transaction" | "ep_notes"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      ep_clients: {
        payload: Prisma.$ep_clientsPayload<ExtArgs>
        fields: Prisma.ep_clientsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ep_clientsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_clientsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ep_clientsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_clientsPayload>
          }
          findFirst: {
            args: Prisma.ep_clientsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_clientsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ep_clientsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_clientsPayload>
          }
          findMany: {
            args: Prisma.ep_clientsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_clientsPayload>[]
          }
          create: {
            args: Prisma.ep_clientsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_clientsPayload>
          }
          createMany: {
            args: Prisma.ep_clientsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ep_clientsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_clientsPayload>[]
          }
          delete: {
            args: Prisma.ep_clientsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_clientsPayload>
          }
          update: {
            args: Prisma.ep_clientsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_clientsPayload>
          }
          deleteMany: {
            args: Prisma.ep_clientsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ep_clientsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ep_clientsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_clientsPayload>[]
          }
          upsert: {
            args: Prisma.ep_clientsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_clientsPayload>
          }
          aggregate: {
            args: Prisma.Ep_clientsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEp_clients>
          }
          groupBy: {
            args: Prisma.ep_clientsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Ep_clientsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ep_clientsCountArgs<ExtArgs>
            result: $Utils.Optional<Ep_clientsCountAggregateOutputType> | number
          }
        }
      }
      ep_informartion: {
        payload: Prisma.$ep_informartionPayload<ExtArgs>
        fields: Prisma.ep_informartionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ep_informartionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_informartionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ep_informartionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_informartionPayload>
          }
          findFirst: {
            args: Prisma.ep_informartionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_informartionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ep_informartionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_informartionPayload>
          }
          findMany: {
            args: Prisma.ep_informartionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_informartionPayload>[]
          }
          create: {
            args: Prisma.ep_informartionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_informartionPayload>
          }
          createMany: {
            args: Prisma.ep_informartionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ep_informartionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_informartionPayload>[]
          }
          delete: {
            args: Prisma.ep_informartionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_informartionPayload>
          }
          update: {
            args: Prisma.ep_informartionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_informartionPayload>
          }
          deleteMany: {
            args: Prisma.ep_informartionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ep_informartionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ep_informartionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_informartionPayload>[]
          }
          upsert: {
            args: Prisma.ep_informartionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_informartionPayload>
          }
          aggregate: {
            args: Prisma.Ep_informartionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEp_informartion>
          }
          groupBy: {
            args: Prisma.ep_informartionGroupByArgs<ExtArgs>
            result: $Utils.Optional<Ep_informartionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ep_informartionCountArgs<ExtArgs>
            result: $Utils.Optional<Ep_informartionCountAggregateOutputType> | number
          }
        }
      }
      ep_packages: {
        payload: Prisma.$ep_packagesPayload<ExtArgs>
        fields: Prisma.ep_packagesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ep_packagesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_packagesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ep_packagesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_packagesPayload>
          }
          findFirst: {
            args: Prisma.ep_packagesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_packagesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ep_packagesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_packagesPayload>
          }
          findMany: {
            args: Prisma.ep_packagesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_packagesPayload>[]
          }
          create: {
            args: Prisma.ep_packagesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_packagesPayload>
          }
          createMany: {
            args: Prisma.ep_packagesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ep_packagesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_packagesPayload>[]
          }
          delete: {
            args: Prisma.ep_packagesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_packagesPayload>
          }
          update: {
            args: Prisma.ep_packagesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_packagesPayload>
          }
          deleteMany: {
            args: Prisma.ep_packagesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ep_packagesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ep_packagesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_packagesPayload>[]
          }
          upsert: {
            args: Prisma.ep_packagesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_packagesPayload>
          }
          aggregate: {
            args: Prisma.Ep_packagesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEp_packages>
          }
          groupBy: {
            args: Prisma.ep_packagesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Ep_packagesGroupByOutputType>[]
          }
          count: {
            args: Prisma.ep_packagesCountArgs<ExtArgs>
            result: $Utils.Optional<Ep_packagesCountAggregateOutputType> | number
          }
        }
      }
      ep_role: {
        payload: Prisma.$ep_rolePayload<ExtArgs>
        fields: Prisma.ep_roleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ep_roleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_rolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ep_roleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_rolePayload>
          }
          findFirst: {
            args: Prisma.ep_roleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_rolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ep_roleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_rolePayload>
          }
          findMany: {
            args: Prisma.ep_roleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_rolePayload>[]
          }
          create: {
            args: Prisma.ep_roleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_rolePayload>
          }
          createMany: {
            args: Prisma.ep_roleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ep_roleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_rolePayload>[]
          }
          delete: {
            args: Prisma.ep_roleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_rolePayload>
          }
          update: {
            args: Prisma.ep_roleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_rolePayload>
          }
          deleteMany: {
            args: Prisma.ep_roleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ep_roleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ep_roleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_rolePayload>[]
          }
          upsert: {
            args: Prisma.ep_roleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_rolePayload>
          }
          aggregate: {
            args: Prisma.Ep_roleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEp_role>
          }
          groupBy: {
            args: Prisma.ep_roleGroupByArgs<ExtArgs>
            result: $Utils.Optional<Ep_roleGroupByOutputType>[]
          }
          count: {
            args: Prisma.ep_roleCountArgs<ExtArgs>
            result: $Utils.Optional<Ep_roleCountAggregateOutputType> | number
          }
        }
      }
      ep_server: {
        payload: Prisma.$ep_serverPayload<ExtArgs>
        fields: Prisma.ep_serverFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ep_serverFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_serverPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ep_serverFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_serverPayload>
          }
          findFirst: {
            args: Prisma.ep_serverFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_serverPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ep_serverFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_serverPayload>
          }
          findMany: {
            args: Prisma.ep_serverFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_serverPayload>[]
          }
          create: {
            args: Prisma.ep_serverCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_serverPayload>
          }
          createMany: {
            args: Prisma.ep_serverCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ep_serverCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_serverPayload>[]
          }
          delete: {
            args: Prisma.ep_serverDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_serverPayload>
          }
          update: {
            args: Prisma.ep_serverUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_serverPayload>
          }
          deleteMany: {
            args: Prisma.ep_serverDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ep_serverUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ep_serverUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_serverPayload>[]
          }
          upsert: {
            args: Prisma.ep_serverUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_serverPayload>
          }
          aggregate: {
            args: Prisma.Ep_serverAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEp_server>
          }
          groupBy: {
            args: Prisma.ep_serverGroupByArgs<ExtArgs>
            result: $Utils.Optional<Ep_serverGroupByOutputType>[]
          }
          count: {
            args: Prisma.ep_serverCountArgs<ExtArgs>
            result: $Utils.Optional<Ep_serverCountAggregateOutputType> | number
          }
        }
      }
      ep_tax: {
        payload: Prisma.$ep_taxPayload<ExtArgs>
        fields: Prisma.ep_taxFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ep_taxFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_taxPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ep_taxFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_taxPayload>
          }
          findFirst: {
            args: Prisma.ep_taxFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_taxPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ep_taxFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_taxPayload>
          }
          findMany: {
            args: Prisma.ep_taxFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_taxPayload>[]
          }
          create: {
            args: Prisma.ep_taxCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_taxPayload>
          }
          createMany: {
            args: Prisma.ep_taxCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ep_taxCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_taxPayload>[]
          }
          delete: {
            args: Prisma.ep_taxDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_taxPayload>
          }
          update: {
            args: Prisma.ep_taxUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_taxPayload>
          }
          deleteMany: {
            args: Prisma.ep_taxDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ep_taxUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ep_taxUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_taxPayload>[]
          }
          upsert: {
            args: Prisma.ep_taxUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_taxPayload>
          }
          aggregate: {
            args: Prisma.Ep_taxAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEp_tax>
          }
          groupBy: {
            args: Prisma.ep_taxGroupByArgs<ExtArgs>
            result: $Utils.Optional<Ep_taxGroupByOutputType>[]
          }
          count: {
            args: Prisma.ep_taxCountArgs<ExtArgs>
            result: $Utils.Optional<Ep_taxCountAggregateOutputType> | number
          }
        }
      }
      ep_users: {
        payload: Prisma.$ep_usersPayload<ExtArgs>
        fields: Prisma.ep_usersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ep_usersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_usersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ep_usersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_usersPayload>
          }
          findFirst: {
            args: Prisma.ep_usersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_usersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ep_usersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_usersPayload>
          }
          findMany: {
            args: Prisma.ep_usersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_usersPayload>[]
          }
          create: {
            args: Prisma.ep_usersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_usersPayload>
          }
          createMany: {
            args: Prisma.ep_usersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ep_usersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_usersPayload>[]
          }
          delete: {
            args: Prisma.ep_usersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_usersPayload>
          }
          update: {
            args: Prisma.ep_usersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_usersPayload>
          }
          deleteMany: {
            args: Prisma.ep_usersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ep_usersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ep_usersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_usersPayload>[]
          }
          upsert: {
            args: Prisma.ep_usersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_usersPayload>
          }
          aggregate: {
            args: Prisma.Ep_usersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEp_users>
          }
          groupBy: {
            args: Prisma.ep_usersGroupByArgs<ExtArgs>
            result: $Utils.Optional<Ep_usersGroupByOutputType>[]
          }
          count: {
            args: Prisma.ep_usersCountArgs<ExtArgs>
            result: $Utils.Optional<Ep_usersCountAggregateOutputType> | number
          }
        }
      }
      ep_vehicles: {
        payload: Prisma.$ep_vehiclesPayload<ExtArgs>
        fields: Prisma.ep_vehiclesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ep_vehiclesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_vehiclesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ep_vehiclesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_vehiclesPayload>
          }
          findFirst: {
            args: Prisma.ep_vehiclesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_vehiclesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ep_vehiclesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_vehiclesPayload>
          }
          findMany: {
            args: Prisma.ep_vehiclesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_vehiclesPayload>[]
          }
          create: {
            args: Prisma.ep_vehiclesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_vehiclesPayload>
          }
          createMany: {
            args: Prisma.ep_vehiclesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ep_vehiclesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_vehiclesPayload>[]
          }
          delete: {
            args: Prisma.ep_vehiclesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_vehiclesPayload>
          }
          update: {
            args: Prisma.ep_vehiclesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_vehiclesPayload>
          }
          deleteMany: {
            args: Prisma.ep_vehiclesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ep_vehiclesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ep_vehiclesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_vehiclesPayload>[]
          }
          upsert: {
            args: Prisma.ep_vehiclesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_vehiclesPayload>
          }
          aggregate: {
            args: Prisma.Ep_vehiclesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEp_vehicles>
          }
          groupBy: {
            args: Prisma.ep_vehiclesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Ep_vehiclesGroupByOutputType>[]
          }
          count: {
            args: Prisma.ep_vehiclesCountArgs<ExtArgs>
            result: $Utils.Optional<Ep_vehiclesCountAggregateOutputType> | number
          }
        }
      }
      ep_cash_per_day: {
        payload: Prisma.$ep_cash_per_dayPayload<ExtArgs>
        fields: Prisma.ep_cash_per_dayFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ep_cash_per_dayFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_cash_per_dayPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ep_cash_per_dayFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_cash_per_dayPayload>
          }
          findFirst: {
            args: Prisma.ep_cash_per_dayFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_cash_per_dayPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ep_cash_per_dayFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_cash_per_dayPayload>
          }
          findMany: {
            args: Prisma.ep_cash_per_dayFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_cash_per_dayPayload>[]
          }
          create: {
            args: Prisma.ep_cash_per_dayCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_cash_per_dayPayload>
          }
          createMany: {
            args: Prisma.ep_cash_per_dayCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ep_cash_per_dayCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_cash_per_dayPayload>[]
          }
          delete: {
            args: Prisma.ep_cash_per_dayDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_cash_per_dayPayload>
          }
          update: {
            args: Prisma.ep_cash_per_dayUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_cash_per_dayPayload>
          }
          deleteMany: {
            args: Prisma.ep_cash_per_dayDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ep_cash_per_dayUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ep_cash_per_dayUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_cash_per_dayPayload>[]
          }
          upsert: {
            args: Prisma.ep_cash_per_dayUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_cash_per_dayPayload>
          }
          aggregate: {
            args: Prisma.Ep_cash_per_dayAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEp_cash_per_day>
          }
          groupBy: {
            args: Prisma.ep_cash_per_dayGroupByArgs<ExtArgs>
            result: $Utils.Optional<Ep_cash_per_dayGroupByOutputType>[]
          }
          count: {
            args: Prisma.ep_cash_per_dayCountArgs<ExtArgs>
            result: $Utils.Optional<Ep_cash_per_dayCountAggregateOutputType> | number
          }
        }
      }
      ep_cashier: {
        payload: Prisma.$ep_cashierPayload<ExtArgs>
        fields: Prisma.ep_cashierFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ep_cashierFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_cashierPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ep_cashierFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_cashierPayload>
          }
          findFirst: {
            args: Prisma.ep_cashierFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_cashierPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ep_cashierFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_cashierPayload>
          }
          findMany: {
            args: Prisma.ep_cashierFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_cashierPayload>[]
          }
          create: {
            args: Prisma.ep_cashierCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_cashierPayload>
          }
          createMany: {
            args: Prisma.ep_cashierCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ep_cashierCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_cashierPayload>[]
          }
          delete: {
            args: Prisma.ep_cashierDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_cashierPayload>
          }
          update: {
            args: Prisma.ep_cashierUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_cashierPayload>
          }
          deleteMany: {
            args: Prisma.ep_cashierDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ep_cashierUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ep_cashierUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_cashierPayload>[]
          }
          upsert: {
            args: Prisma.ep_cashierUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_cashierPayload>
          }
          aggregate: {
            args: Prisma.Ep_cashierAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEp_cashier>
          }
          groupBy: {
            args: Prisma.ep_cashierGroupByArgs<ExtArgs>
            result: $Utils.Optional<Ep_cashierGroupByOutputType>[]
          }
          count: {
            args: Prisma.ep_cashierCountArgs<ExtArgs>
            result: $Utils.Optional<Ep_cashierCountAggregateOutputType> | number
          }
        }
      }
      ep_cashier_transaction: {
        payload: Prisma.$ep_cashier_transactionPayload<ExtArgs>
        fields: Prisma.ep_cashier_transactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ep_cashier_transactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_cashier_transactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ep_cashier_transactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_cashier_transactionPayload>
          }
          findFirst: {
            args: Prisma.ep_cashier_transactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_cashier_transactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ep_cashier_transactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_cashier_transactionPayload>
          }
          findMany: {
            args: Prisma.ep_cashier_transactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_cashier_transactionPayload>[]
          }
          create: {
            args: Prisma.ep_cashier_transactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_cashier_transactionPayload>
          }
          createMany: {
            args: Prisma.ep_cashier_transactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ep_cashier_transactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_cashier_transactionPayload>[]
          }
          delete: {
            args: Prisma.ep_cashier_transactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_cashier_transactionPayload>
          }
          update: {
            args: Prisma.ep_cashier_transactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_cashier_transactionPayload>
          }
          deleteMany: {
            args: Prisma.ep_cashier_transactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ep_cashier_transactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ep_cashier_transactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_cashier_transactionPayload>[]
          }
          upsert: {
            args: Prisma.ep_cashier_transactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_cashier_transactionPayload>
          }
          aggregate: {
            args: Prisma.Ep_cashier_transactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEp_cashier_transaction>
          }
          groupBy: {
            args: Prisma.ep_cashier_transactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<Ep_cashier_transactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ep_cashier_transactionCountArgs<ExtArgs>
            result: $Utils.Optional<Ep_cashier_transactionCountAggregateOutputType> | number
          }
        }
      }
      ep_notes: {
        payload: Prisma.$ep_notesPayload<ExtArgs>
        fields: Prisma.ep_notesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ep_notesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_notesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ep_notesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_notesPayload>
          }
          findFirst: {
            args: Prisma.ep_notesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_notesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ep_notesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_notesPayload>
          }
          findMany: {
            args: Prisma.ep_notesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_notesPayload>[]
          }
          create: {
            args: Prisma.ep_notesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_notesPayload>
          }
          createMany: {
            args: Prisma.ep_notesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ep_notesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_notesPayload>[]
          }
          delete: {
            args: Prisma.ep_notesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_notesPayload>
          }
          update: {
            args: Prisma.ep_notesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_notesPayload>
          }
          deleteMany: {
            args: Prisma.ep_notesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ep_notesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ep_notesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_notesPayload>[]
          }
          upsert: {
            args: Prisma.ep_notesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ep_notesPayload>
          }
          aggregate: {
            args: Prisma.Ep_notesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEp_notes>
          }
          groupBy: {
            args: Prisma.ep_notesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Ep_notesGroupByOutputType>[]
          }
          count: {
            args: Prisma.ep_notesCountArgs<ExtArgs>
            result: $Utils.Optional<Ep_notesCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    ep_clients?: ep_clientsOmit
    ep_informartion?: ep_informartionOmit
    ep_packages?: ep_packagesOmit
    ep_role?: ep_roleOmit
    ep_server?: ep_serverOmit
    ep_tax?: ep_taxOmit
    ep_users?: ep_usersOmit
    ep_vehicles?: ep_vehiclesOmit
    ep_cash_per_day?: ep_cash_per_dayOmit
    ep_cashier?: ep_cashierOmit
    ep_cashier_transaction?: ep_cashier_transactionOmit
    ep_notes?: ep_notesOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type Ep_usersCountOutputType
   */

  export type Ep_usersCountOutputType = {
    ep_cash_per_day: number
    notes: number
  }

  export type Ep_usersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ep_cash_per_day?: boolean | Ep_usersCountOutputTypeCountEp_cash_per_dayArgs
    notes?: boolean | Ep_usersCountOutputTypeCountNotesArgs
  }

  // Custom InputTypes
  /**
   * Ep_usersCountOutputType without action
   */
  export type Ep_usersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ep_usersCountOutputType
     */
    select?: Ep_usersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Ep_usersCountOutputType without action
   */
  export type Ep_usersCountOutputTypeCountEp_cash_per_dayArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ep_cash_per_dayWhereInput
  }

  /**
   * Ep_usersCountOutputType without action
   */
  export type Ep_usersCountOutputTypeCountNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ep_notesWhereInput
  }


  /**
   * Count Type Ep_cashierCountOutputType
   */

  export type Ep_cashierCountOutputType = {
    transactions: number
  }

  export type Ep_cashierCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | Ep_cashierCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes
  /**
   * Ep_cashierCountOutputType without action
   */
  export type Ep_cashierCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ep_cashierCountOutputType
     */
    select?: Ep_cashierCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Ep_cashierCountOutputType without action
   */
  export type Ep_cashierCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ep_cashier_transactionWhereInput
  }


  /**
   * Models
   */

  /**
   * Model ep_clients
   */

  export type AggregateEp_clients = {
    _count: Ep_clientsCountAggregateOutputType | null
    _avg: Ep_clientsAvgAggregateOutputType | null
    _sum: Ep_clientsSumAggregateOutputType | null
    _min: Ep_clientsMinAggregateOutputType | null
    _max: Ep_clientsMaxAggregateOutputType | null
  }

  export type Ep_clientsAvgAggregateOutputType = {
    cli_id: number | null
    cli_version: number | null
  }

  export type Ep_clientsSumAggregateOutputType = {
    cli_id: number | null
    cli_version: number | null
  }

  export type Ep_clientsMinAggregateOutputType = {
    cli_id: number | null
    cli_name: string | null
    cli_lastname: string | null
    cli_ced: string | null
    cli_email: string | null
    cli_version: number | null
  }

  export type Ep_clientsMaxAggregateOutputType = {
    cli_id: number | null
    cli_name: string | null
    cli_lastname: string | null
    cli_ced: string | null
    cli_email: string | null
    cli_version: number | null
  }

  export type Ep_clientsCountAggregateOutputType = {
    cli_id: number
    cli_name: number
    cli_lastname: number
    cli_ced: number
    cli_email: number
    cli_version: number
    _all: number
  }


  export type Ep_clientsAvgAggregateInputType = {
    cli_id?: true
    cli_version?: true
  }

  export type Ep_clientsSumAggregateInputType = {
    cli_id?: true
    cli_version?: true
  }

  export type Ep_clientsMinAggregateInputType = {
    cli_id?: true
    cli_name?: true
    cli_lastname?: true
    cli_ced?: true
    cli_email?: true
    cli_version?: true
  }

  export type Ep_clientsMaxAggregateInputType = {
    cli_id?: true
    cli_name?: true
    cli_lastname?: true
    cli_ced?: true
    cli_email?: true
    cli_version?: true
  }

  export type Ep_clientsCountAggregateInputType = {
    cli_id?: true
    cli_name?: true
    cli_lastname?: true
    cli_ced?: true
    cli_email?: true
    cli_version?: true
    _all?: true
  }

  export type Ep_clientsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ep_clients to aggregate.
     */
    where?: ep_clientsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ep_clients to fetch.
     */
    orderBy?: ep_clientsOrderByWithRelationInput | ep_clientsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ep_clientsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ep_clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ep_clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ep_clients
    **/
    _count?: true | Ep_clientsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Ep_clientsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Ep_clientsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Ep_clientsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Ep_clientsMaxAggregateInputType
  }

  export type GetEp_clientsAggregateType<T extends Ep_clientsAggregateArgs> = {
        [P in keyof T & keyof AggregateEp_clients]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEp_clients[P]>
      : GetScalarType<T[P], AggregateEp_clients[P]>
  }




  export type ep_clientsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ep_clientsWhereInput
    orderBy?: ep_clientsOrderByWithAggregationInput | ep_clientsOrderByWithAggregationInput[]
    by: Ep_clientsScalarFieldEnum[] | Ep_clientsScalarFieldEnum
    having?: ep_clientsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Ep_clientsCountAggregateInputType | true
    _avg?: Ep_clientsAvgAggregateInputType
    _sum?: Ep_clientsSumAggregateInputType
    _min?: Ep_clientsMinAggregateInputType
    _max?: Ep_clientsMaxAggregateInputType
  }

  export type Ep_clientsGroupByOutputType = {
    cli_id: number
    cli_name: string | null
    cli_lastname: string
    cli_ced: string
    cli_email: string | null
    cli_version: number
    _count: Ep_clientsCountAggregateOutputType | null
    _avg: Ep_clientsAvgAggregateOutputType | null
    _sum: Ep_clientsSumAggregateOutputType | null
    _min: Ep_clientsMinAggregateOutputType | null
    _max: Ep_clientsMaxAggregateOutputType | null
  }

  type GetEp_clientsGroupByPayload<T extends ep_clientsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Ep_clientsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Ep_clientsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Ep_clientsGroupByOutputType[P]>
            : GetScalarType<T[P], Ep_clientsGroupByOutputType[P]>
        }
      >
    >


  export type ep_clientsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cli_id?: boolean
    cli_name?: boolean
    cli_lastname?: boolean
    cli_ced?: boolean
    cli_email?: boolean
    cli_version?: boolean
  }, ExtArgs["result"]["ep_clients"]>

  export type ep_clientsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cli_id?: boolean
    cli_name?: boolean
    cli_lastname?: boolean
    cli_ced?: boolean
    cli_email?: boolean
    cli_version?: boolean
  }, ExtArgs["result"]["ep_clients"]>

  export type ep_clientsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cli_id?: boolean
    cli_name?: boolean
    cli_lastname?: boolean
    cli_ced?: boolean
    cli_email?: boolean
    cli_version?: boolean
  }, ExtArgs["result"]["ep_clients"]>

  export type ep_clientsSelectScalar = {
    cli_id?: boolean
    cli_name?: boolean
    cli_lastname?: boolean
    cli_ced?: boolean
    cli_email?: boolean
    cli_version?: boolean
  }

  export type ep_clientsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"cli_id" | "cli_name" | "cli_lastname" | "cli_ced" | "cli_email" | "cli_version", ExtArgs["result"]["ep_clients"]>

  export type $ep_clientsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ep_clients"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      cli_id: number
      cli_name: string | null
      cli_lastname: string
      cli_ced: string
      cli_email: string | null
      cli_version: number
    }, ExtArgs["result"]["ep_clients"]>
    composites: {}
  }

  type ep_clientsGetPayload<S extends boolean | null | undefined | ep_clientsDefaultArgs> = $Result.GetResult<Prisma.$ep_clientsPayload, S>

  type ep_clientsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ep_clientsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Ep_clientsCountAggregateInputType | true
    }

  export interface ep_clientsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ep_clients'], meta: { name: 'ep_clients' } }
    /**
     * Find zero or one Ep_clients that matches the filter.
     * @param {ep_clientsFindUniqueArgs} args - Arguments to find a Ep_clients
     * @example
     * // Get one Ep_clients
     * const ep_clients = await prisma.ep_clients.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ep_clientsFindUniqueArgs>(args: SelectSubset<T, ep_clientsFindUniqueArgs<ExtArgs>>): Prisma__ep_clientsClient<$Result.GetResult<Prisma.$ep_clientsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ep_clients that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ep_clientsFindUniqueOrThrowArgs} args - Arguments to find a Ep_clients
     * @example
     * // Get one Ep_clients
     * const ep_clients = await prisma.ep_clients.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ep_clientsFindUniqueOrThrowArgs>(args: SelectSubset<T, ep_clientsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ep_clientsClient<$Result.GetResult<Prisma.$ep_clientsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ep_clients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ep_clientsFindFirstArgs} args - Arguments to find a Ep_clients
     * @example
     * // Get one Ep_clients
     * const ep_clients = await prisma.ep_clients.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ep_clientsFindFirstArgs>(args?: SelectSubset<T, ep_clientsFindFirstArgs<ExtArgs>>): Prisma__ep_clientsClient<$Result.GetResult<Prisma.$ep_clientsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ep_clients that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ep_clientsFindFirstOrThrowArgs} args - Arguments to find a Ep_clients
     * @example
     * // Get one Ep_clients
     * const ep_clients = await prisma.ep_clients.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ep_clientsFindFirstOrThrowArgs>(args?: SelectSubset<T, ep_clientsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ep_clientsClient<$Result.GetResult<Prisma.$ep_clientsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ep_clients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ep_clientsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ep_clients
     * const ep_clients = await prisma.ep_clients.findMany()
     * 
     * // Get first 10 Ep_clients
     * const ep_clients = await prisma.ep_clients.findMany({ take: 10 })
     * 
     * // Only select the `cli_id`
     * const ep_clientsWithCli_idOnly = await prisma.ep_clients.findMany({ select: { cli_id: true } })
     * 
     */
    findMany<T extends ep_clientsFindManyArgs>(args?: SelectSubset<T, ep_clientsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ep_clientsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ep_clients.
     * @param {ep_clientsCreateArgs} args - Arguments to create a Ep_clients.
     * @example
     * // Create one Ep_clients
     * const Ep_clients = await prisma.ep_clients.create({
     *   data: {
     *     // ... data to create a Ep_clients
     *   }
     * })
     * 
     */
    create<T extends ep_clientsCreateArgs>(args: SelectSubset<T, ep_clientsCreateArgs<ExtArgs>>): Prisma__ep_clientsClient<$Result.GetResult<Prisma.$ep_clientsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ep_clients.
     * @param {ep_clientsCreateManyArgs} args - Arguments to create many Ep_clients.
     * @example
     * // Create many Ep_clients
     * const ep_clients = await prisma.ep_clients.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ep_clientsCreateManyArgs>(args?: SelectSubset<T, ep_clientsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ep_clients and returns the data saved in the database.
     * @param {ep_clientsCreateManyAndReturnArgs} args - Arguments to create many Ep_clients.
     * @example
     * // Create many Ep_clients
     * const ep_clients = await prisma.ep_clients.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ep_clients and only return the `cli_id`
     * const ep_clientsWithCli_idOnly = await prisma.ep_clients.createManyAndReturn({
     *   select: { cli_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ep_clientsCreateManyAndReturnArgs>(args?: SelectSubset<T, ep_clientsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ep_clientsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Ep_clients.
     * @param {ep_clientsDeleteArgs} args - Arguments to delete one Ep_clients.
     * @example
     * // Delete one Ep_clients
     * const Ep_clients = await prisma.ep_clients.delete({
     *   where: {
     *     // ... filter to delete one Ep_clients
     *   }
     * })
     * 
     */
    delete<T extends ep_clientsDeleteArgs>(args: SelectSubset<T, ep_clientsDeleteArgs<ExtArgs>>): Prisma__ep_clientsClient<$Result.GetResult<Prisma.$ep_clientsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ep_clients.
     * @param {ep_clientsUpdateArgs} args - Arguments to update one Ep_clients.
     * @example
     * // Update one Ep_clients
     * const ep_clients = await prisma.ep_clients.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ep_clientsUpdateArgs>(args: SelectSubset<T, ep_clientsUpdateArgs<ExtArgs>>): Prisma__ep_clientsClient<$Result.GetResult<Prisma.$ep_clientsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ep_clients.
     * @param {ep_clientsDeleteManyArgs} args - Arguments to filter Ep_clients to delete.
     * @example
     * // Delete a few Ep_clients
     * const { count } = await prisma.ep_clients.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ep_clientsDeleteManyArgs>(args?: SelectSubset<T, ep_clientsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ep_clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ep_clientsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ep_clients
     * const ep_clients = await prisma.ep_clients.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ep_clientsUpdateManyArgs>(args: SelectSubset<T, ep_clientsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ep_clients and returns the data updated in the database.
     * @param {ep_clientsUpdateManyAndReturnArgs} args - Arguments to update many Ep_clients.
     * @example
     * // Update many Ep_clients
     * const ep_clients = await prisma.ep_clients.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Ep_clients and only return the `cli_id`
     * const ep_clientsWithCli_idOnly = await prisma.ep_clients.updateManyAndReturn({
     *   select: { cli_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ep_clientsUpdateManyAndReturnArgs>(args: SelectSubset<T, ep_clientsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ep_clientsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Ep_clients.
     * @param {ep_clientsUpsertArgs} args - Arguments to update or create a Ep_clients.
     * @example
     * // Update or create a Ep_clients
     * const ep_clients = await prisma.ep_clients.upsert({
     *   create: {
     *     // ... data to create a Ep_clients
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ep_clients we want to update
     *   }
     * })
     */
    upsert<T extends ep_clientsUpsertArgs>(args: SelectSubset<T, ep_clientsUpsertArgs<ExtArgs>>): Prisma__ep_clientsClient<$Result.GetResult<Prisma.$ep_clientsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ep_clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ep_clientsCountArgs} args - Arguments to filter Ep_clients to count.
     * @example
     * // Count the number of Ep_clients
     * const count = await prisma.ep_clients.count({
     *   where: {
     *     // ... the filter for the Ep_clients we want to count
     *   }
     * })
    **/
    count<T extends ep_clientsCountArgs>(
      args?: Subset<T, ep_clientsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Ep_clientsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ep_clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ep_clientsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Ep_clientsAggregateArgs>(args: Subset<T, Ep_clientsAggregateArgs>): Prisma.PrismaPromise<GetEp_clientsAggregateType<T>>

    /**
     * Group by Ep_clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ep_clientsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ep_clientsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ep_clientsGroupByArgs['orderBy'] }
        : { orderBy?: ep_clientsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ep_clientsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEp_clientsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ep_clients model
   */
  readonly fields: ep_clientsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ep_clients.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ep_clientsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ep_clients model
   */ 
  interface ep_clientsFieldRefs {
    readonly cli_id: FieldRef<"ep_clients", 'Int'>
    readonly cli_name: FieldRef<"ep_clients", 'String'>
    readonly cli_lastname: FieldRef<"ep_clients", 'String'>
    readonly cli_ced: FieldRef<"ep_clients", 'String'>
    readonly cli_email: FieldRef<"ep_clients", 'String'>
    readonly cli_version: FieldRef<"ep_clients", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ep_clients findUnique
   */
  export type ep_clientsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_clients
     */
    select?: ep_clientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_clients
     */
    omit?: ep_clientsOmit<ExtArgs> | null
    /**
     * Filter, which ep_clients to fetch.
     */
    where: ep_clientsWhereUniqueInput
  }

  /**
   * ep_clients findUniqueOrThrow
   */
  export type ep_clientsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_clients
     */
    select?: ep_clientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_clients
     */
    omit?: ep_clientsOmit<ExtArgs> | null
    /**
     * Filter, which ep_clients to fetch.
     */
    where: ep_clientsWhereUniqueInput
  }

  /**
   * ep_clients findFirst
   */
  export type ep_clientsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_clients
     */
    select?: ep_clientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_clients
     */
    omit?: ep_clientsOmit<ExtArgs> | null
    /**
     * Filter, which ep_clients to fetch.
     */
    where?: ep_clientsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ep_clients to fetch.
     */
    orderBy?: ep_clientsOrderByWithRelationInput | ep_clientsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ep_clients.
     */
    cursor?: ep_clientsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ep_clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ep_clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ep_clients.
     */
    distinct?: Ep_clientsScalarFieldEnum | Ep_clientsScalarFieldEnum[]
  }

  /**
   * ep_clients findFirstOrThrow
   */
  export type ep_clientsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_clients
     */
    select?: ep_clientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_clients
     */
    omit?: ep_clientsOmit<ExtArgs> | null
    /**
     * Filter, which ep_clients to fetch.
     */
    where?: ep_clientsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ep_clients to fetch.
     */
    orderBy?: ep_clientsOrderByWithRelationInput | ep_clientsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ep_clients.
     */
    cursor?: ep_clientsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ep_clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ep_clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ep_clients.
     */
    distinct?: Ep_clientsScalarFieldEnum | Ep_clientsScalarFieldEnum[]
  }

  /**
   * ep_clients findMany
   */
  export type ep_clientsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_clients
     */
    select?: ep_clientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_clients
     */
    omit?: ep_clientsOmit<ExtArgs> | null
    /**
     * Filter, which ep_clients to fetch.
     */
    where?: ep_clientsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ep_clients to fetch.
     */
    orderBy?: ep_clientsOrderByWithRelationInput | ep_clientsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ep_clients.
     */
    cursor?: ep_clientsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ep_clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ep_clients.
     */
    skip?: number
    distinct?: Ep_clientsScalarFieldEnum | Ep_clientsScalarFieldEnum[]
  }

  /**
   * ep_clients create
   */
  export type ep_clientsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_clients
     */
    select?: ep_clientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_clients
     */
    omit?: ep_clientsOmit<ExtArgs> | null
    /**
     * The data needed to create a ep_clients.
     */
    data: XOR<ep_clientsCreateInput, ep_clientsUncheckedCreateInput>
  }

  /**
   * ep_clients createMany
   */
  export type ep_clientsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ep_clients.
     */
    data: ep_clientsCreateManyInput | ep_clientsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ep_clients createManyAndReturn
   */
  export type ep_clientsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_clients
     */
    select?: ep_clientsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ep_clients
     */
    omit?: ep_clientsOmit<ExtArgs> | null
    /**
     * The data used to create many ep_clients.
     */
    data: ep_clientsCreateManyInput | ep_clientsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ep_clients update
   */
  export type ep_clientsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_clients
     */
    select?: ep_clientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_clients
     */
    omit?: ep_clientsOmit<ExtArgs> | null
    /**
     * The data needed to update a ep_clients.
     */
    data: XOR<ep_clientsUpdateInput, ep_clientsUncheckedUpdateInput>
    /**
     * Choose, which ep_clients to update.
     */
    where: ep_clientsWhereUniqueInput
  }

  /**
   * ep_clients updateMany
   */
  export type ep_clientsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ep_clients.
     */
    data: XOR<ep_clientsUpdateManyMutationInput, ep_clientsUncheckedUpdateManyInput>
    /**
     * Filter which ep_clients to update
     */
    where?: ep_clientsWhereInput
    /**
     * Limit how many ep_clients to update.
     */
    limit?: number
  }

  /**
   * ep_clients updateManyAndReturn
   */
  export type ep_clientsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_clients
     */
    select?: ep_clientsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ep_clients
     */
    omit?: ep_clientsOmit<ExtArgs> | null
    /**
     * The data used to update ep_clients.
     */
    data: XOR<ep_clientsUpdateManyMutationInput, ep_clientsUncheckedUpdateManyInput>
    /**
     * Filter which ep_clients to update
     */
    where?: ep_clientsWhereInput
    /**
     * Limit how many ep_clients to update.
     */
    limit?: number
  }

  /**
   * ep_clients upsert
   */
  export type ep_clientsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_clients
     */
    select?: ep_clientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_clients
     */
    omit?: ep_clientsOmit<ExtArgs> | null
    /**
     * The filter to search for the ep_clients to update in case it exists.
     */
    where: ep_clientsWhereUniqueInput
    /**
     * In case the ep_clients found by the `where` argument doesn't exist, create a new ep_clients with this data.
     */
    create: XOR<ep_clientsCreateInput, ep_clientsUncheckedCreateInput>
    /**
     * In case the ep_clients was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ep_clientsUpdateInput, ep_clientsUncheckedUpdateInput>
  }

  /**
   * ep_clients delete
   */
  export type ep_clientsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_clients
     */
    select?: ep_clientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_clients
     */
    omit?: ep_clientsOmit<ExtArgs> | null
    /**
     * Filter which ep_clients to delete.
     */
    where: ep_clientsWhereUniqueInput
  }

  /**
   * ep_clients deleteMany
   */
  export type ep_clientsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ep_clients to delete
     */
    where?: ep_clientsWhereInput
    /**
     * Limit how many ep_clients to delete.
     */
    limit?: number
  }

  /**
   * ep_clients without action
   */
  export type ep_clientsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_clients
     */
    select?: ep_clientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_clients
     */
    omit?: ep_clientsOmit<ExtArgs> | null
  }


  /**
   * Model ep_informartion
   */

  export type AggregateEp_informartion = {
    _count: Ep_informartionCountAggregateOutputType | null
    _avg: Ep_informartionAvgAggregateOutputType | null
    _sum: Ep_informartionSumAggregateOutputType | null
    _min: Ep_informartionMinAggregateOutputType | null
    _max: Ep_informartionMaxAggregateOutputType | null
  }

  export type Ep_informartionAvgAggregateOutputType = {
    info_id: number | null
    info_spaces: number | null
    info_version: number | null
  }

  export type Ep_informartionSumAggregateOutputType = {
    info_id: number | null
    info_spaces: number | null
    info_version: number | null
  }

  export type Ep_informartionMinAggregateOutputType = {
    info_id: number | null
    info_name: string | null
    info_location: string | null
    info_spaces: number | null
    info_version: number | null
    info_image: Uint8Array | null
    info_owner: string | null
    info_owner_ced: string | null
    info_owner_phone: string | null
    info_schedule: string | null
  }

  export type Ep_informartionMaxAggregateOutputType = {
    info_id: number | null
    info_name: string | null
    info_location: string | null
    info_spaces: number | null
    info_version: number | null
    info_image: Uint8Array | null
    info_owner: string | null
    info_owner_ced: string | null
    info_owner_phone: string | null
    info_schedule: string | null
  }

  export type Ep_informartionCountAggregateOutputType = {
    info_id: number
    info_name: number
    info_location: number
    info_spaces: number
    info_version: number
    info_image: number
    info_owner: number
    info_owner_ced: number
    info_owner_phone: number
    info_schedule: number
    _all: number
  }


  export type Ep_informartionAvgAggregateInputType = {
    info_id?: true
    info_spaces?: true
    info_version?: true
  }

  export type Ep_informartionSumAggregateInputType = {
    info_id?: true
    info_spaces?: true
    info_version?: true
  }

  export type Ep_informartionMinAggregateInputType = {
    info_id?: true
    info_name?: true
    info_location?: true
    info_spaces?: true
    info_version?: true
    info_image?: true
    info_owner?: true
    info_owner_ced?: true
    info_owner_phone?: true
    info_schedule?: true
  }

  export type Ep_informartionMaxAggregateInputType = {
    info_id?: true
    info_name?: true
    info_location?: true
    info_spaces?: true
    info_version?: true
    info_image?: true
    info_owner?: true
    info_owner_ced?: true
    info_owner_phone?: true
    info_schedule?: true
  }

  export type Ep_informartionCountAggregateInputType = {
    info_id?: true
    info_name?: true
    info_location?: true
    info_spaces?: true
    info_version?: true
    info_image?: true
    info_owner?: true
    info_owner_ced?: true
    info_owner_phone?: true
    info_schedule?: true
    _all?: true
  }

  export type Ep_informartionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ep_informartion to aggregate.
     */
    where?: ep_informartionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ep_informartions to fetch.
     */
    orderBy?: ep_informartionOrderByWithRelationInput | ep_informartionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ep_informartionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ep_informartions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ep_informartions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ep_informartions
    **/
    _count?: true | Ep_informartionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Ep_informartionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Ep_informartionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Ep_informartionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Ep_informartionMaxAggregateInputType
  }

  export type GetEp_informartionAggregateType<T extends Ep_informartionAggregateArgs> = {
        [P in keyof T & keyof AggregateEp_informartion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEp_informartion[P]>
      : GetScalarType<T[P], AggregateEp_informartion[P]>
  }




  export type ep_informartionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ep_informartionWhereInput
    orderBy?: ep_informartionOrderByWithAggregationInput | ep_informartionOrderByWithAggregationInput[]
    by: Ep_informartionScalarFieldEnum[] | Ep_informartionScalarFieldEnum
    having?: ep_informartionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Ep_informartionCountAggregateInputType | true
    _avg?: Ep_informartionAvgAggregateInputType
    _sum?: Ep_informartionSumAggregateInputType
    _min?: Ep_informartionMinAggregateInputType
    _max?: Ep_informartionMaxAggregateInputType
  }

  export type Ep_informartionGroupByOutputType = {
    info_id: number
    info_name: string
    info_location: string
    info_spaces: number
    info_version: number
    info_image: Uint8Array
    info_owner: string
    info_owner_ced: string
    info_owner_phone: string
    info_schedule: string
    _count: Ep_informartionCountAggregateOutputType | null
    _avg: Ep_informartionAvgAggregateOutputType | null
    _sum: Ep_informartionSumAggregateOutputType | null
    _min: Ep_informartionMinAggregateOutputType | null
    _max: Ep_informartionMaxAggregateOutputType | null
  }

  type GetEp_informartionGroupByPayload<T extends ep_informartionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Ep_informartionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Ep_informartionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Ep_informartionGroupByOutputType[P]>
            : GetScalarType<T[P], Ep_informartionGroupByOutputType[P]>
        }
      >
    >


  export type ep_informartionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    info_id?: boolean
    info_name?: boolean
    info_location?: boolean
    info_spaces?: boolean
    info_version?: boolean
    info_image?: boolean
    info_owner?: boolean
    info_owner_ced?: boolean
    info_owner_phone?: boolean
    info_schedule?: boolean
  }, ExtArgs["result"]["ep_informartion"]>

  export type ep_informartionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    info_id?: boolean
    info_name?: boolean
    info_location?: boolean
    info_spaces?: boolean
    info_version?: boolean
    info_image?: boolean
    info_owner?: boolean
    info_owner_ced?: boolean
    info_owner_phone?: boolean
    info_schedule?: boolean
  }, ExtArgs["result"]["ep_informartion"]>

  export type ep_informartionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    info_id?: boolean
    info_name?: boolean
    info_location?: boolean
    info_spaces?: boolean
    info_version?: boolean
    info_image?: boolean
    info_owner?: boolean
    info_owner_ced?: boolean
    info_owner_phone?: boolean
    info_schedule?: boolean
  }, ExtArgs["result"]["ep_informartion"]>

  export type ep_informartionSelectScalar = {
    info_id?: boolean
    info_name?: boolean
    info_location?: boolean
    info_spaces?: boolean
    info_version?: boolean
    info_image?: boolean
    info_owner?: boolean
    info_owner_ced?: boolean
    info_owner_phone?: boolean
    info_schedule?: boolean
  }

  export type ep_informartionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"info_id" | "info_name" | "info_location" | "info_spaces" | "info_version" | "info_image" | "info_owner" | "info_owner_ced" | "info_owner_phone" | "info_schedule", ExtArgs["result"]["ep_informartion"]>

  export type $ep_informartionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ep_informartion"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      info_id: number
      info_name: string
      info_location: string
      info_spaces: number
      info_version: number
      info_image: Uint8Array
      info_owner: string
      info_owner_ced: string
      info_owner_phone: string
      info_schedule: string
    }, ExtArgs["result"]["ep_informartion"]>
    composites: {}
  }

  type ep_informartionGetPayload<S extends boolean | null | undefined | ep_informartionDefaultArgs> = $Result.GetResult<Prisma.$ep_informartionPayload, S>

  type ep_informartionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ep_informartionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Ep_informartionCountAggregateInputType | true
    }

  export interface ep_informartionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ep_informartion'], meta: { name: 'ep_informartion' } }
    /**
     * Find zero or one Ep_informartion that matches the filter.
     * @param {ep_informartionFindUniqueArgs} args - Arguments to find a Ep_informartion
     * @example
     * // Get one Ep_informartion
     * const ep_informartion = await prisma.ep_informartion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ep_informartionFindUniqueArgs>(args: SelectSubset<T, ep_informartionFindUniqueArgs<ExtArgs>>): Prisma__ep_informartionClient<$Result.GetResult<Prisma.$ep_informartionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ep_informartion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ep_informartionFindUniqueOrThrowArgs} args - Arguments to find a Ep_informartion
     * @example
     * // Get one Ep_informartion
     * const ep_informartion = await prisma.ep_informartion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ep_informartionFindUniqueOrThrowArgs>(args: SelectSubset<T, ep_informartionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ep_informartionClient<$Result.GetResult<Prisma.$ep_informartionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ep_informartion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ep_informartionFindFirstArgs} args - Arguments to find a Ep_informartion
     * @example
     * // Get one Ep_informartion
     * const ep_informartion = await prisma.ep_informartion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ep_informartionFindFirstArgs>(args?: SelectSubset<T, ep_informartionFindFirstArgs<ExtArgs>>): Prisma__ep_informartionClient<$Result.GetResult<Prisma.$ep_informartionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ep_informartion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ep_informartionFindFirstOrThrowArgs} args - Arguments to find a Ep_informartion
     * @example
     * // Get one Ep_informartion
     * const ep_informartion = await prisma.ep_informartion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ep_informartionFindFirstOrThrowArgs>(args?: SelectSubset<T, ep_informartionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ep_informartionClient<$Result.GetResult<Prisma.$ep_informartionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ep_informartions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ep_informartionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ep_informartions
     * const ep_informartions = await prisma.ep_informartion.findMany()
     * 
     * // Get first 10 Ep_informartions
     * const ep_informartions = await prisma.ep_informartion.findMany({ take: 10 })
     * 
     * // Only select the `info_id`
     * const ep_informartionWithInfo_idOnly = await prisma.ep_informartion.findMany({ select: { info_id: true } })
     * 
     */
    findMany<T extends ep_informartionFindManyArgs>(args?: SelectSubset<T, ep_informartionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ep_informartionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ep_informartion.
     * @param {ep_informartionCreateArgs} args - Arguments to create a Ep_informartion.
     * @example
     * // Create one Ep_informartion
     * const Ep_informartion = await prisma.ep_informartion.create({
     *   data: {
     *     // ... data to create a Ep_informartion
     *   }
     * })
     * 
     */
    create<T extends ep_informartionCreateArgs>(args: SelectSubset<T, ep_informartionCreateArgs<ExtArgs>>): Prisma__ep_informartionClient<$Result.GetResult<Prisma.$ep_informartionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ep_informartions.
     * @param {ep_informartionCreateManyArgs} args - Arguments to create many Ep_informartions.
     * @example
     * // Create many Ep_informartions
     * const ep_informartion = await prisma.ep_informartion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ep_informartionCreateManyArgs>(args?: SelectSubset<T, ep_informartionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ep_informartions and returns the data saved in the database.
     * @param {ep_informartionCreateManyAndReturnArgs} args - Arguments to create many Ep_informartions.
     * @example
     * // Create many Ep_informartions
     * const ep_informartion = await prisma.ep_informartion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ep_informartions and only return the `info_id`
     * const ep_informartionWithInfo_idOnly = await prisma.ep_informartion.createManyAndReturn({
     *   select: { info_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ep_informartionCreateManyAndReturnArgs>(args?: SelectSubset<T, ep_informartionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ep_informartionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Ep_informartion.
     * @param {ep_informartionDeleteArgs} args - Arguments to delete one Ep_informartion.
     * @example
     * // Delete one Ep_informartion
     * const Ep_informartion = await prisma.ep_informartion.delete({
     *   where: {
     *     // ... filter to delete one Ep_informartion
     *   }
     * })
     * 
     */
    delete<T extends ep_informartionDeleteArgs>(args: SelectSubset<T, ep_informartionDeleteArgs<ExtArgs>>): Prisma__ep_informartionClient<$Result.GetResult<Prisma.$ep_informartionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ep_informartion.
     * @param {ep_informartionUpdateArgs} args - Arguments to update one Ep_informartion.
     * @example
     * // Update one Ep_informartion
     * const ep_informartion = await prisma.ep_informartion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ep_informartionUpdateArgs>(args: SelectSubset<T, ep_informartionUpdateArgs<ExtArgs>>): Prisma__ep_informartionClient<$Result.GetResult<Prisma.$ep_informartionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ep_informartions.
     * @param {ep_informartionDeleteManyArgs} args - Arguments to filter Ep_informartions to delete.
     * @example
     * // Delete a few Ep_informartions
     * const { count } = await prisma.ep_informartion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ep_informartionDeleteManyArgs>(args?: SelectSubset<T, ep_informartionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ep_informartions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ep_informartionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ep_informartions
     * const ep_informartion = await prisma.ep_informartion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ep_informartionUpdateManyArgs>(args: SelectSubset<T, ep_informartionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ep_informartions and returns the data updated in the database.
     * @param {ep_informartionUpdateManyAndReturnArgs} args - Arguments to update many Ep_informartions.
     * @example
     * // Update many Ep_informartions
     * const ep_informartion = await prisma.ep_informartion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Ep_informartions and only return the `info_id`
     * const ep_informartionWithInfo_idOnly = await prisma.ep_informartion.updateManyAndReturn({
     *   select: { info_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ep_informartionUpdateManyAndReturnArgs>(args: SelectSubset<T, ep_informartionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ep_informartionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Ep_informartion.
     * @param {ep_informartionUpsertArgs} args - Arguments to update or create a Ep_informartion.
     * @example
     * // Update or create a Ep_informartion
     * const ep_informartion = await prisma.ep_informartion.upsert({
     *   create: {
     *     // ... data to create a Ep_informartion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ep_informartion we want to update
     *   }
     * })
     */
    upsert<T extends ep_informartionUpsertArgs>(args: SelectSubset<T, ep_informartionUpsertArgs<ExtArgs>>): Prisma__ep_informartionClient<$Result.GetResult<Prisma.$ep_informartionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ep_informartions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ep_informartionCountArgs} args - Arguments to filter Ep_informartions to count.
     * @example
     * // Count the number of Ep_informartions
     * const count = await prisma.ep_informartion.count({
     *   where: {
     *     // ... the filter for the Ep_informartions we want to count
     *   }
     * })
    **/
    count<T extends ep_informartionCountArgs>(
      args?: Subset<T, ep_informartionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Ep_informartionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ep_informartion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ep_informartionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Ep_informartionAggregateArgs>(args: Subset<T, Ep_informartionAggregateArgs>): Prisma.PrismaPromise<GetEp_informartionAggregateType<T>>

    /**
     * Group by Ep_informartion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ep_informartionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ep_informartionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ep_informartionGroupByArgs['orderBy'] }
        : { orderBy?: ep_informartionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ep_informartionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEp_informartionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ep_informartion model
   */
  readonly fields: ep_informartionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ep_informartion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ep_informartionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ep_informartion model
   */ 
  interface ep_informartionFieldRefs {
    readonly info_id: FieldRef<"ep_informartion", 'Int'>
    readonly info_name: FieldRef<"ep_informartion", 'String'>
    readonly info_location: FieldRef<"ep_informartion", 'String'>
    readonly info_spaces: FieldRef<"ep_informartion", 'Int'>
    readonly info_version: FieldRef<"ep_informartion", 'Int'>
    readonly info_image: FieldRef<"ep_informartion", 'Bytes'>
    readonly info_owner: FieldRef<"ep_informartion", 'String'>
    readonly info_owner_ced: FieldRef<"ep_informartion", 'String'>
    readonly info_owner_phone: FieldRef<"ep_informartion", 'String'>
    readonly info_schedule: FieldRef<"ep_informartion", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ep_informartion findUnique
   */
  export type ep_informartionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_informartion
     */
    select?: ep_informartionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_informartion
     */
    omit?: ep_informartionOmit<ExtArgs> | null
    /**
     * Filter, which ep_informartion to fetch.
     */
    where: ep_informartionWhereUniqueInput
  }

  /**
   * ep_informartion findUniqueOrThrow
   */
  export type ep_informartionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_informartion
     */
    select?: ep_informartionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_informartion
     */
    omit?: ep_informartionOmit<ExtArgs> | null
    /**
     * Filter, which ep_informartion to fetch.
     */
    where: ep_informartionWhereUniqueInput
  }

  /**
   * ep_informartion findFirst
   */
  export type ep_informartionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_informartion
     */
    select?: ep_informartionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_informartion
     */
    omit?: ep_informartionOmit<ExtArgs> | null
    /**
     * Filter, which ep_informartion to fetch.
     */
    where?: ep_informartionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ep_informartions to fetch.
     */
    orderBy?: ep_informartionOrderByWithRelationInput | ep_informartionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ep_informartions.
     */
    cursor?: ep_informartionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ep_informartions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ep_informartions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ep_informartions.
     */
    distinct?: Ep_informartionScalarFieldEnum | Ep_informartionScalarFieldEnum[]
  }

  /**
   * ep_informartion findFirstOrThrow
   */
  export type ep_informartionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_informartion
     */
    select?: ep_informartionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_informartion
     */
    omit?: ep_informartionOmit<ExtArgs> | null
    /**
     * Filter, which ep_informartion to fetch.
     */
    where?: ep_informartionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ep_informartions to fetch.
     */
    orderBy?: ep_informartionOrderByWithRelationInput | ep_informartionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ep_informartions.
     */
    cursor?: ep_informartionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ep_informartions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ep_informartions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ep_informartions.
     */
    distinct?: Ep_informartionScalarFieldEnum | Ep_informartionScalarFieldEnum[]
  }

  /**
   * ep_informartion findMany
   */
  export type ep_informartionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_informartion
     */
    select?: ep_informartionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_informartion
     */
    omit?: ep_informartionOmit<ExtArgs> | null
    /**
     * Filter, which ep_informartions to fetch.
     */
    where?: ep_informartionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ep_informartions to fetch.
     */
    orderBy?: ep_informartionOrderByWithRelationInput | ep_informartionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ep_informartions.
     */
    cursor?: ep_informartionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ep_informartions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ep_informartions.
     */
    skip?: number
    distinct?: Ep_informartionScalarFieldEnum | Ep_informartionScalarFieldEnum[]
  }

  /**
   * ep_informartion create
   */
  export type ep_informartionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_informartion
     */
    select?: ep_informartionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_informartion
     */
    omit?: ep_informartionOmit<ExtArgs> | null
    /**
     * The data needed to create a ep_informartion.
     */
    data: XOR<ep_informartionCreateInput, ep_informartionUncheckedCreateInput>
  }

  /**
   * ep_informartion createMany
   */
  export type ep_informartionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ep_informartions.
     */
    data: ep_informartionCreateManyInput | ep_informartionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ep_informartion createManyAndReturn
   */
  export type ep_informartionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_informartion
     */
    select?: ep_informartionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ep_informartion
     */
    omit?: ep_informartionOmit<ExtArgs> | null
    /**
     * The data used to create many ep_informartions.
     */
    data: ep_informartionCreateManyInput | ep_informartionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ep_informartion update
   */
  export type ep_informartionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_informartion
     */
    select?: ep_informartionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_informartion
     */
    omit?: ep_informartionOmit<ExtArgs> | null
    /**
     * The data needed to update a ep_informartion.
     */
    data: XOR<ep_informartionUpdateInput, ep_informartionUncheckedUpdateInput>
    /**
     * Choose, which ep_informartion to update.
     */
    where: ep_informartionWhereUniqueInput
  }

  /**
   * ep_informartion updateMany
   */
  export type ep_informartionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ep_informartions.
     */
    data: XOR<ep_informartionUpdateManyMutationInput, ep_informartionUncheckedUpdateManyInput>
    /**
     * Filter which ep_informartions to update
     */
    where?: ep_informartionWhereInput
    /**
     * Limit how many ep_informartions to update.
     */
    limit?: number
  }

  /**
   * ep_informartion updateManyAndReturn
   */
  export type ep_informartionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_informartion
     */
    select?: ep_informartionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ep_informartion
     */
    omit?: ep_informartionOmit<ExtArgs> | null
    /**
     * The data used to update ep_informartions.
     */
    data: XOR<ep_informartionUpdateManyMutationInput, ep_informartionUncheckedUpdateManyInput>
    /**
     * Filter which ep_informartions to update
     */
    where?: ep_informartionWhereInput
    /**
     * Limit how many ep_informartions to update.
     */
    limit?: number
  }

  /**
   * ep_informartion upsert
   */
  export type ep_informartionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_informartion
     */
    select?: ep_informartionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_informartion
     */
    omit?: ep_informartionOmit<ExtArgs> | null
    /**
     * The filter to search for the ep_informartion to update in case it exists.
     */
    where: ep_informartionWhereUniqueInput
    /**
     * In case the ep_informartion found by the `where` argument doesn't exist, create a new ep_informartion with this data.
     */
    create: XOR<ep_informartionCreateInput, ep_informartionUncheckedCreateInput>
    /**
     * In case the ep_informartion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ep_informartionUpdateInput, ep_informartionUncheckedUpdateInput>
  }

  /**
   * ep_informartion delete
   */
  export type ep_informartionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_informartion
     */
    select?: ep_informartionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_informartion
     */
    omit?: ep_informartionOmit<ExtArgs> | null
    /**
     * Filter which ep_informartion to delete.
     */
    where: ep_informartionWhereUniqueInput
  }

  /**
   * ep_informartion deleteMany
   */
  export type ep_informartionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ep_informartions to delete
     */
    where?: ep_informartionWhereInput
    /**
     * Limit how many ep_informartions to delete.
     */
    limit?: number
  }

  /**
   * ep_informartion without action
   */
  export type ep_informartionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_informartion
     */
    select?: ep_informartionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_informartion
     */
    omit?: ep_informartionOmit<ExtArgs> | null
  }


  /**
   * Model ep_packages
   */

  export type AggregateEp_packages = {
    _count: Ep_packagesCountAggregateOutputType | null
    _avg: Ep_packagesAvgAggregateOutputType | null
    _sum: Ep_packagesSumAggregateOutputType | null
    _min: Ep_packagesMinAggregateOutputType | null
    _max: Ep_packagesMaxAggregateOutputType | null
  }

  export type Ep_packagesAvgAggregateOutputType = {
    pack_id: number | null
    pack_price: number | null
    pack_version: number | null
  }

  export type Ep_packagesSumAggregateOutputType = {
    pack_id: number | null
    pack_price: number | null
    pack_version: number | null
  }

  export type Ep_packagesMinAggregateOutputType = {
    pack_id: number | null
    pack_name: string | null
    pack_price: number | null
    pack_version: number | null
  }

  export type Ep_packagesMaxAggregateOutputType = {
    pack_id: number | null
    pack_name: string | null
    pack_price: number | null
    pack_version: number | null
  }

  export type Ep_packagesCountAggregateOutputType = {
    pack_id: number
    pack_name: number
    pack_price: number
    pack_version: number
    _all: number
  }


  export type Ep_packagesAvgAggregateInputType = {
    pack_id?: true
    pack_price?: true
    pack_version?: true
  }

  export type Ep_packagesSumAggregateInputType = {
    pack_id?: true
    pack_price?: true
    pack_version?: true
  }

  export type Ep_packagesMinAggregateInputType = {
    pack_id?: true
    pack_name?: true
    pack_price?: true
    pack_version?: true
  }

  export type Ep_packagesMaxAggregateInputType = {
    pack_id?: true
    pack_name?: true
    pack_price?: true
    pack_version?: true
  }

  export type Ep_packagesCountAggregateInputType = {
    pack_id?: true
    pack_name?: true
    pack_price?: true
    pack_version?: true
    _all?: true
  }

  export type Ep_packagesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ep_packages to aggregate.
     */
    where?: ep_packagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ep_packages to fetch.
     */
    orderBy?: ep_packagesOrderByWithRelationInput | ep_packagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ep_packagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ep_packages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ep_packages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ep_packages
    **/
    _count?: true | Ep_packagesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Ep_packagesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Ep_packagesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Ep_packagesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Ep_packagesMaxAggregateInputType
  }

  export type GetEp_packagesAggregateType<T extends Ep_packagesAggregateArgs> = {
        [P in keyof T & keyof AggregateEp_packages]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEp_packages[P]>
      : GetScalarType<T[P], AggregateEp_packages[P]>
  }




  export type ep_packagesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ep_packagesWhereInput
    orderBy?: ep_packagesOrderByWithAggregationInput | ep_packagesOrderByWithAggregationInput[]
    by: Ep_packagesScalarFieldEnum[] | Ep_packagesScalarFieldEnum
    having?: ep_packagesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Ep_packagesCountAggregateInputType | true
    _avg?: Ep_packagesAvgAggregateInputType
    _sum?: Ep_packagesSumAggregateInputType
    _min?: Ep_packagesMinAggregateInputType
    _max?: Ep_packagesMaxAggregateInputType
  }

  export type Ep_packagesGroupByOutputType = {
    pack_id: number
    pack_name: string
    pack_price: number
    pack_version: number
    _count: Ep_packagesCountAggregateOutputType | null
    _avg: Ep_packagesAvgAggregateOutputType | null
    _sum: Ep_packagesSumAggregateOutputType | null
    _min: Ep_packagesMinAggregateOutputType | null
    _max: Ep_packagesMaxAggregateOutputType | null
  }

  type GetEp_packagesGroupByPayload<T extends ep_packagesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Ep_packagesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Ep_packagesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Ep_packagesGroupByOutputType[P]>
            : GetScalarType<T[P], Ep_packagesGroupByOutputType[P]>
        }
      >
    >


  export type ep_packagesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    pack_id?: boolean
    pack_name?: boolean
    pack_price?: boolean
    pack_version?: boolean
  }, ExtArgs["result"]["ep_packages"]>

  export type ep_packagesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    pack_id?: boolean
    pack_name?: boolean
    pack_price?: boolean
    pack_version?: boolean
  }, ExtArgs["result"]["ep_packages"]>

  export type ep_packagesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    pack_id?: boolean
    pack_name?: boolean
    pack_price?: boolean
    pack_version?: boolean
  }, ExtArgs["result"]["ep_packages"]>

  export type ep_packagesSelectScalar = {
    pack_id?: boolean
    pack_name?: boolean
    pack_price?: boolean
    pack_version?: boolean
  }

  export type ep_packagesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"pack_id" | "pack_name" | "pack_price" | "pack_version", ExtArgs["result"]["ep_packages"]>

  export type $ep_packagesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ep_packages"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      pack_id: number
      pack_name: string
      pack_price: number
      pack_version: number
    }, ExtArgs["result"]["ep_packages"]>
    composites: {}
  }

  type ep_packagesGetPayload<S extends boolean | null | undefined | ep_packagesDefaultArgs> = $Result.GetResult<Prisma.$ep_packagesPayload, S>

  type ep_packagesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ep_packagesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Ep_packagesCountAggregateInputType | true
    }

  export interface ep_packagesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ep_packages'], meta: { name: 'ep_packages' } }
    /**
     * Find zero or one Ep_packages that matches the filter.
     * @param {ep_packagesFindUniqueArgs} args - Arguments to find a Ep_packages
     * @example
     * // Get one Ep_packages
     * const ep_packages = await prisma.ep_packages.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ep_packagesFindUniqueArgs>(args: SelectSubset<T, ep_packagesFindUniqueArgs<ExtArgs>>): Prisma__ep_packagesClient<$Result.GetResult<Prisma.$ep_packagesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ep_packages that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ep_packagesFindUniqueOrThrowArgs} args - Arguments to find a Ep_packages
     * @example
     * // Get one Ep_packages
     * const ep_packages = await prisma.ep_packages.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ep_packagesFindUniqueOrThrowArgs>(args: SelectSubset<T, ep_packagesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ep_packagesClient<$Result.GetResult<Prisma.$ep_packagesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ep_packages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ep_packagesFindFirstArgs} args - Arguments to find a Ep_packages
     * @example
     * // Get one Ep_packages
     * const ep_packages = await prisma.ep_packages.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ep_packagesFindFirstArgs>(args?: SelectSubset<T, ep_packagesFindFirstArgs<ExtArgs>>): Prisma__ep_packagesClient<$Result.GetResult<Prisma.$ep_packagesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ep_packages that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ep_packagesFindFirstOrThrowArgs} args - Arguments to find a Ep_packages
     * @example
     * // Get one Ep_packages
     * const ep_packages = await prisma.ep_packages.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ep_packagesFindFirstOrThrowArgs>(args?: SelectSubset<T, ep_packagesFindFirstOrThrowArgs<ExtArgs>>): Prisma__ep_packagesClient<$Result.GetResult<Prisma.$ep_packagesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ep_packages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ep_packagesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ep_packages
     * const ep_packages = await prisma.ep_packages.findMany()
     * 
     * // Get first 10 Ep_packages
     * const ep_packages = await prisma.ep_packages.findMany({ take: 10 })
     * 
     * // Only select the `pack_id`
     * const ep_packagesWithPack_idOnly = await prisma.ep_packages.findMany({ select: { pack_id: true } })
     * 
     */
    findMany<T extends ep_packagesFindManyArgs>(args?: SelectSubset<T, ep_packagesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ep_packagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ep_packages.
     * @param {ep_packagesCreateArgs} args - Arguments to create a Ep_packages.
     * @example
     * // Create one Ep_packages
     * const Ep_packages = await prisma.ep_packages.create({
     *   data: {
     *     // ... data to create a Ep_packages
     *   }
     * })
     * 
     */
    create<T extends ep_packagesCreateArgs>(args: SelectSubset<T, ep_packagesCreateArgs<ExtArgs>>): Prisma__ep_packagesClient<$Result.GetResult<Prisma.$ep_packagesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ep_packages.
     * @param {ep_packagesCreateManyArgs} args - Arguments to create many Ep_packages.
     * @example
     * // Create many Ep_packages
     * const ep_packages = await prisma.ep_packages.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ep_packagesCreateManyArgs>(args?: SelectSubset<T, ep_packagesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ep_packages and returns the data saved in the database.
     * @param {ep_packagesCreateManyAndReturnArgs} args - Arguments to create many Ep_packages.
     * @example
     * // Create many Ep_packages
     * const ep_packages = await prisma.ep_packages.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ep_packages and only return the `pack_id`
     * const ep_packagesWithPack_idOnly = await prisma.ep_packages.createManyAndReturn({
     *   select: { pack_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ep_packagesCreateManyAndReturnArgs>(args?: SelectSubset<T, ep_packagesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ep_packagesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Ep_packages.
     * @param {ep_packagesDeleteArgs} args - Arguments to delete one Ep_packages.
     * @example
     * // Delete one Ep_packages
     * const Ep_packages = await prisma.ep_packages.delete({
     *   where: {
     *     // ... filter to delete one Ep_packages
     *   }
     * })
     * 
     */
    delete<T extends ep_packagesDeleteArgs>(args: SelectSubset<T, ep_packagesDeleteArgs<ExtArgs>>): Prisma__ep_packagesClient<$Result.GetResult<Prisma.$ep_packagesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ep_packages.
     * @param {ep_packagesUpdateArgs} args - Arguments to update one Ep_packages.
     * @example
     * // Update one Ep_packages
     * const ep_packages = await prisma.ep_packages.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ep_packagesUpdateArgs>(args: SelectSubset<T, ep_packagesUpdateArgs<ExtArgs>>): Prisma__ep_packagesClient<$Result.GetResult<Prisma.$ep_packagesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ep_packages.
     * @param {ep_packagesDeleteManyArgs} args - Arguments to filter Ep_packages to delete.
     * @example
     * // Delete a few Ep_packages
     * const { count } = await prisma.ep_packages.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ep_packagesDeleteManyArgs>(args?: SelectSubset<T, ep_packagesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ep_packages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ep_packagesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ep_packages
     * const ep_packages = await prisma.ep_packages.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ep_packagesUpdateManyArgs>(args: SelectSubset<T, ep_packagesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ep_packages and returns the data updated in the database.
     * @param {ep_packagesUpdateManyAndReturnArgs} args - Arguments to update many Ep_packages.
     * @example
     * // Update many Ep_packages
     * const ep_packages = await prisma.ep_packages.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Ep_packages and only return the `pack_id`
     * const ep_packagesWithPack_idOnly = await prisma.ep_packages.updateManyAndReturn({
     *   select: { pack_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ep_packagesUpdateManyAndReturnArgs>(args: SelectSubset<T, ep_packagesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ep_packagesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Ep_packages.
     * @param {ep_packagesUpsertArgs} args - Arguments to update or create a Ep_packages.
     * @example
     * // Update or create a Ep_packages
     * const ep_packages = await prisma.ep_packages.upsert({
     *   create: {
     *     // ... data to create a Ep_packages
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ep_packages we want to update
     *   }
     * })
     */
    upsert<T extends ep_packagesUpsertArgs>(args: SelectSubset<T, ep_packagesUpsertArgs<ExtArgs>>): Prisma__ep_packagesClient<$Result.GetResult<Prisma.$ep_packagesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ep_packages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ep_packagesCountArgs} args - Arguments to filter Ep_packages to count.
     * @example
     * // Count the number of Ep_packages
     * const count = await prisma.ep_packages.count({
     *   where: {
     *     // ... the filter for the Ep_packages we want to count
     *   }
     * })
    **/
    count<T extends ep_packagesCountArgs>(
      args?: Subset<T, ep_packagesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Ep_packagesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ep_packages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ep_packagesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Ep_packagesAggregateArgs>(args: Subset<T, Ep_packagesAggregateArgs>): Prisma.PrismaPromise<GetEp_packagesAggregateType<T>>

    /**
     * Group by Ep_packages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ep_packagesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ep_packagesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ep_packagesGroupByArgs['orderBy'] }
        : { orderBy?: ep_packagesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ep_packagesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEp_packagesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ep_packages model
   */
  readonly fields: ep_packagesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ep_packages.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ep_packagesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ep_packages model
   */ 
  interface ep_packagesFieldRefs {
    readonly pack_id: FieldRef<"ep_packages", 'Int'>
    readonly pack_name: FieldRef<"ep_packages", 'String'>
    readonly pack_price: FieldRef<"ep_packages", 'Int'>
    readonly pack_version: FieldRef<"ep_packages", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ep_packages findUnique
   */
  export type ep_packagesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_packages
     */
    select?: ep_packagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_packages
     */
    omit?: ep_packagesOmit<ExtArgs> | null
    /**
     * Filter, which ep_packages to fetch.
     */
    where: ep_packagesWhereUniqueInput
  }

  /**
   * ep_packages findUniqueOrThrow
   */
  export type ep_packagesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_packages
     */
    select?: ep_packagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_packages
     */
    omit?: ep_packagesOmit<ExtArgs> | null
    /**
     * Filter, which ep_packages to fetch.
     */
    where: ep_packagesWhereUniqueInput
  }

  /**
   * ep_packages findFirst
   */
  export type ep_packagesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_packages
     */
    select?: ep_packagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_packages
     */
    omit?: ep_packagesOmit<ExtArgs> | null
    /**
     * Filter, which ep_packages to fetch.
     */
    where?: ep_packagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ep_packages to fetch.
     */
    orderBy?: ep_packagesOrderByWithRelationInput | ep_packagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ep_packages.
     */
    cursor?: ep_packagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ep_packages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ep_packages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ep_packages.
     */
    distinct?: Ep_packagesScalarFieldEnum | Ep_packagesScalarFieldEnum[]
  }

  /**
   * ep_packages findFirstOrThrow
   */
  export type ep_packagesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_packages
     */
    select?: ep_packagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_packages
     */
    omit?: ep_packagesOmit<ExtArgs> | null
    /**
     * Filter, which ep_packages to fetch.
     */
    where?: ep_packagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ep_packages to fetch.
     */
    orderBy?: ep_packagesOrderByWithRelationInput | ep_packagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ep_packages.
     */
    cursor?: ep_packagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ep_packages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ep_packages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ep_packages.
     */
    distinct?: Ep_packagesScalarFieldEnum | Ep_packagesScalarFieldEnum[]
  }

  /**
   * ep_packages findMany
   */
  export type ep_packagesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_packages
     */
    select?: ep_packagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_packages
     */
    omit?: ep_packagesOmit<ExtArgs> | null
    /**
     * Filter, which ep_packages to fetch.
     */
    where?: ep_packagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ep_packages to fetch.
     */
    orderBy?: ep_packagesOrderByWithRelationInput | ep_packagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ep_packages.
     */
    cursor?: ep_packagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ep_packages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ep_packages.
     */
    skip?: number
    distinct?: Ep_packagesScalarFieldEnum | Ep_packagesScalarFieldEnum[]
  }

  /**
   * ep_packages create
   */
  export type ep_packagesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_packages
     */
    select?: ep_packagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_packages
     */
    omit?: ep_packagesOmit<ExtArgs> | null
    /**
     * The data needed to create a ep_packages.
     */
    data: XOR<ep_packagesCreateInput, ep_packagesUncheckedCreateInput>
  }

  /**
   * ep_packages createMany
   */
  export type ep_packagesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ep_packages.
     */
    data: ep_packagesCreateManyInput | ep_packagesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ep_packages createManyAndReturn
   */
  export type ep_packagesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_packages
     */
    select?: ep_packagesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ep_packages
     */
    omit?: ep_packagesOmit<ExtArgs> | null
    /**
     * The data used to create many ep_packages.
     */
    data: ep_packagesCreateManyInput | ep_packagesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ep_packages update
   */
  export type ep_packagesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_packages
     */
    select?: ep_packagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_packages
     */
    omit?: ep_packagesOmit<ExtArgs> | null
    /**
     * The data needed to update a ep_packages.
     */
    data: XOR<ep_packagesUpdateInput, ep_packagesUncheckedUpdateInput>
    /**
     * Choose, which ep_packages to update.
     */
    where: ep_packagesWhereUniqueInput
  }

  /**
   * ep_packages updateMany
   */
  export type ep_packagesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ep_packages.
     */
    data: XOR<ep_packagesUpdateManyMutationInput, ep_packagesUncheckedUpdateManyInput>
    /**
     * Filter which ep_packages to update
     */
    where?: ep_packagesWhereInput
    /**
     * Limit how many ep_packages to update.
     */
    limit?: number
  }

  /**
   * ep_packages updateManyAndReturn
   */
  export type ep_packagesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_packages
     */
    select?: ep_packagesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ep_packages
     */
    omit?: ep_packagesOmit<ExtArgs> | null
    /**
     * The data used to update ep_packages.
     */
    data: XOR<ep_packagesUpdateManyMutationInput, ep_packagesUncheckedUpdateManyInput>
    /**
     * Filter which ep_packages to update
     */
    where?: ep_packagesWhereInput
    /**
     * Limit how many ep_packages to update.
     */
    limit?: number
  }

  /**
   * ep_packages upsert
   */
  export type ep_packagesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_packages
     */
    select?: ep_packagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_packages
     */
    omit?: ep_packagesOmit<ExtArgs> | null
    /**
     * The filter to search for the ep_packages to update in case it exists.
     */
    where: ep_packagesWhereUniqueInput
    /**
     * In case the ep_packages found by the `where` argument doesn't exist, create a new ep_packages with this data.
     */
    create: XOR<ep_packagesCreateInput, ep_packagesUncheckedCreateInput>
    /**
     * In case the ep_packages was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ep_packagesUpdateInput, ep_packagesUncheckedUpdateInput>
  }

  /**
   * ep_packages delete
   */
  export type ep_packagesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_packages
     */
    select?: ep_packagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_packages
     */
    omit?: ep_packagesOmit<ExtArgs> | null
    /**
     * Filter which ep_packages to delete.
     */
    where: ep_packagesWhereUniqueInput
  }

  /**
   * ep_packages deleteMany
   */
  export type ep_packagesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ep_packages to delete
     */
    where?: ep_packagesWhereInput
    /**
     * Limit how many ep_packages to delete.
     */
    limit?: number
  }

  /**
   * ep_packages without action
   */
  export type ep_packagesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_packages
     */
    select?: ep_packagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_packages
     */
    omit?: ep_packagesOmit<ExtArgs> | null
  }


  /**
   * Model ep_role
   */

  export type AggregateEp_role = {
    _count: Ep_roleCountAggregateOutputType | null
    _avg: Ep_roleAvgAggregateOutputType | null
    _sum: Ep_roleSumAggregateOutputType | null
    _min: Ep_roleMinAggregateOutputType | null
    _max: Ep_roleMaxAggregateOutputType | null
  }

  export type Ep_roleAvgAggregateOutputType = {
    rol_id: number | null
    rol_version: number | null
  }

  export type Ep_roleSumAggregateOutputType = {
    rol_id: number | null
    rol_version: number | null
  }

  export type Ep_roleMinAggregateOutputType = {
    rol_id: number | null
    rol_name: string | null
    rol_version: number | null
  }

  export type Ep_roleMaxAggregateOutputType = {
    rol_id: number | null
    rol_name: string | null
    rol_version: number | null
  }

  export type Ep_roleCountAggregateOutputType = {
    rol_id: number
    rol_name: number
    rol_version: number
    _all: number
  }


  export type Ep_roleAvgAggregateInputType = {
    rol_id?: true
    rol_version?: true
  }

  export type Ep_roleSumAggregateInputType = {
    rol_id?: true
    rol_version?: true
  }

  export type Ep_roleMinAggregateInputType = {
    rol_id?: true
    rol_name?: true
    rol_version?: true
  }

  export type Ep_roleMaxAggregateInputType = {
    rol_id?: true
    rol_name?: true
    rol_version?: true
  }

  export type Ep_roleCountAggregateInputType = {
    rol_id?: true
    rol_name?: true
    rol_version?: true
    _all?: true
  }

  export type Ep_roleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ep_role to aggregate.
     */
    where?: ep_roleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ep_roles to fetch.
     */
    orderBy?: ep_roleOrderByWithRelationInput | ep_roleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ep_roleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ep_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ep_roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ep_roles
    **/
    _count?: true | Ep_roleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Ep_roleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Ep_roleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Ep_roleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Ep_roleMaxAggregateInputType
  }

  export type GetEp_roleAggregateType<T extends Ep_roleAggregateArgs> = {
        [P in keyof T & keyof AggregateEp_role]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEp_role[P]>
      : GetScalarType<T[P], AggregateEp_role[P]>
  }




  export type ep_roleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ep_roleWhereInput
    orderBy?: ep_roleOrderByWithAggregationInput | ep_roleOrderByWithAggregationInput[]
    by: Ep_roleScalarFieldEnum[] | Ep_roleScalarFieldEnum
    having?: ep_roleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Ep_roleCountAggregateInputType | true
    _avg?: Ep_roleAvgAggregateInputType
    _sum?: Ep_roleSumAggregateInputType
    _min?: Ep_roleMinAggregateInputType
    _max?: Ep_roleMaxAggregateInputType
  }

  export type Ep_roleGroupByOutputType = {
    rol_id: number
    rol_name: string
    rol_version: number
    _count: Ep_roleCountAggregateOutputType | null
    _avg: Ep_roleAvgAggregateOutputType | null
    _sum: Ep_roleSumAggregateOutputType | null
    _min: Ep_roleMinAggregateOutputType | null
    _max: Ep_roleMaxAggregateOutputType | null
  }

  type GetEp_roleGroupByPayload<T extends ep_roleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Ep_roleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Ep_roleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Ep_roleGroupByOutputType[P]>
            : GetScalarType<T[P], Ep_roleGroupByOutputType[P]>
        }
      >
    >


  export type ep_roleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    rol_id?: boolean
    rol_name?: boolean
    rol_version?: boolean
  }, ExtArgs["result"]["ep_role"]>

  export type ep_roleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    rol_id?: boolean
    rol_name?: boolean
    rol_version?: boolean
  }, ExtArgs["result"]["ep_role"]>

  export type ep_roleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    rol_id?: boolean
    rol_name?: boolean
    rol_version?: boolean
  }, ExtArgs["result"]["ep_role"]>

  export type ep_roleSelectScalar = {
    rol_id?: boolean
    rol_name?: boolean
    rol_version?: boolean
  }

  export type ep_roleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"rol_id" | "rol_name" | "rol_version", ExtArgs["result"]["ep_role"]>

  export type $ep_rolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ep_role"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      rol_id: number
      rol_name: string
      rol_version: number
    }, ExtArgs["result"]["ep_role"]>
    composites: {}
  }

  type ep_roleGetPayload<S extends boolean | null | undefined | ep_roleDefaultArgs> = $Result.GetResult<Prisma.$ep_rolePayload, S>

  type ep_roleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ep_roleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Ep_roleCountAggregateInputType | true
    }

  export interface ep_roleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ep_role'], meta: { name: 'ep_role' } }
    /**
     * Find zero or one Ep_role that matches the filter.
     * @param {ep_roleFindUniqueArgs} args - Arguments to find a Ep_role
     * @example
     * // Get one Ep_role
     * const ep_role = await prisma.ep_role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ep_roleFindUniqueArgs>(args: SelectSubset<T, ep_roleFindUniqueArgs<ExtArgs>>): Prisma__ep_roleClient<$Result.GetResult<Prisma.$ep_rolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ep_role that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ep_roleFindUniqueOrThrowArgs} args - Arguments to find a Ep_role
     * @example
     * // Get one Ep_role
     * const ep_role = await prisma.ep_role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ep_roleFindUniqueOrThrowArgs>(args: SelectSubset<T, ep_roleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ep_roleClient<$Result.GetResult<Prisma.$ep_rolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ep_role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ep_roleFindFirstArgs} args - Arguments to find a Ep_role
     * @example
     * // Get one Ep_role
     * const ep_role = await prisma.ep_role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ep_roleFindFirstArgs>(args?: SelectSubset<T, ep_roleFindFirstArgs<ExtArgs>>): Prisma__ep_roleClient<$Result.GetResult<Prisma.$ep_rolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ep_role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ep_roleFindFirstOrThrowArgs} args - Arguments to find a Ep_role
     * @example
     * // Get one Ep_role
     * const ep_role = await prisma.ep_role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ep_roleFindFirstOrThrowArgs>(args?: SelectSubset<T, ep_roleFindFirstOrThrowArgs<ExtArgs>>): Prisma__ep_roleClient<$Result.GetResult<Prisma.$ep_rolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ep_roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ep_roleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ep_roles
     * const ep_roles = await prisma.ep_role.findMany()
     * 
     * // Get first 10 Ep_roles
     * const ep_roles = await prisma.ep_role.findMany({ take: 10 })
     * 
     * // Only select the `rol_id`
     * const ep_roleWithRol_idOnly = await prisma.ep_role.findMany({ select: { rol_id: true } })
     * 
     */
    findMany<T extends ep_roleFindManyArgs>(args?: SelectSubset<T, ep_roleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ep_rolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ep_role.
     * @param {ep_roleCreateArgs} args - Arguments to create a Ep_role.
     * @example
     * // Create one Ep_role
     * const Ep_role = await prisma.ep_role.create({
     *   data: {
     *     // ... data to create a Ep_role
     *   }
     * })
     * 
     */
    create<T extends ep_roleCreateArgs>(args: SelectSubset<T, ep_roleCreateArgs<ExtArgs>>): Prisma__ep_roleClient<$Result.GetResult<Prisma.$ep_rolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ep_roles.
     * @param {ep_roleCreateManyArgs} args - Arguments to create many Ep_roles.
     * @example
     * // Create many Ep_roles
     * const ep_role = await prisma.ep_role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ep_roleCreateManyArgs>(args?: SelectSubset<T, ep_roleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ep_roles and returns the data saved in the database.
     * @param {ep_roleCreateManyAndReturnArgs} args - Arguments to create many Ep_roles.
     * @example
     * // Create many Ep_roles
     * const ep_role = await prisma.ep_role.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ep_roles and only return the `rol_id`
     * const ep_roleWithRol_idOnly = await prisma.ep_role.createManyAndReturn({
     *   select: { rol_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ep_roleCreateManyAndReturnArgs>(args?: SelectSubset<T, ep_roleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ep_rolePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Ep_role.
     * @param {ep_roleDeleteArgs} args - Arguments to delete one Ep_role.
     * @example
     * // Delete one Ep_role
     * const Ep_role = await prisma.ep_role.delete({
     *   where: {
     *     // ... filter to delete one Ep_role
     *   }
     * })
     * 
     */
    delete<T extends ep_roleDeleteArgs>(args: SelectSubset<T, ep_roleDeleteArgs<ExtArgs>>): Prisma__ep_roleClient<$Result.GetResult<Prisma.$ep_rolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ep_role.
     * @param {ep_roleUpdateArgs} args - Arguments to update one Ep_role.
     * @example
     * // Update one Ep_role
     * const ep_role = await prisma.ep_role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ep_roleUpdateArgs>(args: SelectSubset<T, ep_roleUpdateArgs<ExtArgs>>): Prisma__ep_roleClient<$Result.GetResult<Prisma.$ep_rolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ep_roles.
     * @param {ep_roleDeleteManyArgs} args - Arguments to filter Ep_roles to delete.
     * @example
     * // Delete a few Ep_roles
     * const { count } = await prisma.ep_role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ep_roleDeleteManyArgs>(args?: SelectSubset<T, ep_roleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ep_roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ep_roleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ep_roles
     * const ep_role = await prisma.ep_role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ep_roleUpdateManyArgs>(args: SelectSubset<T, ep_roleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ep_roles and returns the data updated in the database.
     * @param {ep_roleUpdateManyAndReturnArgs} args - Arguments to update many Ep_roles.
     * @example
     * // Update many Ep_roles
     * const ep_role = await prisma.ep_role.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Ep_roles and only return the `rol_id`
     * const ep_roleWithRol_idOnly = await prisma.ep_role.updateManyAndReturn({
     *   select: { rol_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ep_roleUpdateManyAndReturnArgs>(args: SelectSubset<T, ep_roleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ep_rolePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Ep_role.
     * @param {ep_roleUpsertArgs} args - Arguments to update or create a Ep_role.
     * @example
     * // Update or create a Ep_role
     * const ep_role = await prisma.ep_role.upsert({
     *   create: {
     *     // ... data to create a Ep_role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ep_role we want to update
     *   }
     * })
     */
    upsert<T extends ep_roleUpsertArgs>(args: SelectSubset<T, ep_roleUpsertArgs<ExtArgs>>): Prisma__ep_roleClient<$Result.GetResult<Prisma.$ep_rolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ep_roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ep_roleCountArgs} args - Arguments to filter Ep_roles to count.
     * @example
     * // Count the number of Ep_roles
     * const count = await prisma.ep_role.count({
     *   where: {
     *     // ... the filter for the Ep_roles we want to count
     *   }
     * })
    **/
    count<T extends ep_roleCountArgs>(
      args?: Subset<T, ep_roleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Ep_roleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ep_role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ep_roleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Ep_roleAggregateArgs>(args: Subset<T, Ep_roleAggregateArgs>): Prisma.PrismaPromise<GetEp_roleAggregateType<T>>

    /**
     * Group by Ep_role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ep_roleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ep_roleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ep_roleGroupByArgs['orderBy'] }
        : { orderBy?: ep_roleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ep_roleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEp_roleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ep_role model
   */
  readonly fields: ep_roleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ep_role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ep_roleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ep_role model
   */ 
  interface ep_roleFieldRefs {
    readonly rol_id: FieldRef<"ep_role", 'Int'>
    readonly rol_name: FieldRef<"ep_role", 'String'>
    readonly rol_version: FieldRef<"ep_role", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ep_role findUnique
   */
  export type ep_roleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_role
     */
    select?: ep_roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_role
     */
    omit?: ep_roleOmit<ExtArgs> | null
    /**
     * Filter, which ep_role to fetch.
     */
    where: ep_roleWhereUniqueInput
  }

  /**
   * ep_role findUniqueOrThrow
   */
  export type ep_roleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_role
     */
    select?: ep_roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_role
     */
    omit?: ep_roleOmit<ExtArgs> | null
    /**
     * Filter, which ep_role to fetch.
     */
    where: ep_roleWhereUniqueInput
  }

  /**
   * ep_role findFirst
   */
  export type ep_roleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_role
     */
    select?: ep_roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_role
     */
    omit?: ep_roleOmit<ExtArgs> | null
    /**
     * Filter, which ep_role to fetch.
     */
    where?: ep_roleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ep_roles to fetch.
     */
    orderBy?: ep_roleOrderByWithRelationInput | ep_roleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ep_roles.
     */
    cursor?: ep_roleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ep_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ep_roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ep_roles.
     */
    distinct?: Ep_roleScalarFieldEnum | Ep_roleScalarFieldEnum[]
  }

  /**
   * ep_role findFirstOrThrow
   */
  export type ep_roleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_role
     */
    select?: ep_roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_role
     */
    omit?: ep_roleOmit<ExtArgs> | null
    /**
     * Filter, which ep_role to fetch.
     */
    where?: ep_roleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ep_roles to fetch.
     */
    orderBy?: ep_roleOrderByWithRelationInput | ep_roleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ep_roles.
     */
    cursor?: ep_roleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ep_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ep_roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ep_roles.
     */
    distinct?: Ep_roleScalarFieldEnum | Ep_roleScalarFieldEnum[]
  }

  /**
   * ep_role findMany
   */
  export type ep_roleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_role
     */
    select?: ep_roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_role
     */
    omit?: ep_roleOmit<ExtArgs> | null
    /**
     * Filter, which ep_roles to fetch.
     */
    where?: ep_roleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ep_roles to fetch.
     */
    orderBy?: ep_roleOrderByWithRelationInput | ep_roleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ep_roles.
     */
    cursor?: ep_roleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ep_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ep_roles.
     */
    skip?: number
    distinct?: Ep_roleScalarFieldEnum | Ep_roleScalarFieldEnum[]
  }

  /**
   * ep_role create
   */
  export type ep_roleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_role
     */
    select?: ep_roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_role
     */
    omit?: ep_roleOmit<ExtArgs> | null
    /**
     * The data needed to create a ep_role.
     */
    data: XOR<ep_roleCreateInput, ep_roleUncheckedCreateInput>
  }

  /**
   * ep_role createMany
   */
  export type ep_roleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ep_roles.
     */
    data: ep_roleCreateManyInput | ep_roleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ep_role createManyAndReturn
   */
  export type ep_roleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_role
     */
    select?: ep_roleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ep_role
     */
    omit?: ep_roleOmit<ExtArgs> | null
    /**
     * The data used to create many ep_roles.
     */
    data: ep_roleCreateManyInput | ep_roleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ep_role update
   */
  export type ep_roleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_role
     */
    select?: ep_roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_role
     */
    omit?: ep_roleOmit<ExtArgs> | null
    /**
     * The data needed to update a ep_role.
     */
    data: XOR<ep_roleUpdateInput, ep_roleUncheckedUpdateInput>
    /**
     * Choose, which ep_role to update.
     */
    where: ep_roleWhereUniqueInput
  }

  /**
   * ep_role updateMany
   */
  export type ep_roleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ep_roles.
     */
    data: XOR<ep_roleUpdateManyMutationInput, ep_roleUncheckedUpdateManyInput>
    /**
     * Filter which ep_roles to update
     */
    where?: ep_roleWhereInput
    /**
     * Limit how many ep_roles to update.
     */
    limit?: number
  }

  /**
   * ep_role updateManyAndReturn
   */
  export type ep_roleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_role
     */
    select?: ep_roleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ep_role
     */
    omit?: ep_roleOmit<ExtArgs> | null
    /**
     * The data used to update ep_roles.
     */
    data: XOR<ep_roleUpdateManyMutationInput, ep_roleUncheckedUpdateManyInput>
    /**
     * Filter which ep_roles to update
     */
    where?: ep_roleWhereInput
    /**
     * Limit how many ep_roles to update.
     */
    limit?: number
  }

  /**
   * ep_role upsert
   */
  export type ep_roleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_role
     */
    select?: ep_roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_role
     */
    omit?: ep_roleOmit<ExtArgs> | null
    /**
     * The filter to search for the ep_role to update in case it exists.
     */
    where: ep_roleWhereUniqueInput
    /**
     * In case the ep_role found by the `where` argument doesn't exist, create a new ep_role with this data.
     */
    create: XOR<ep_roleCreateInput, ep_roleUncheckedCreateInput>
    /**
     * In case the ep_role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ep_roleUpdateInput, ep_roleUncheckedUpdateInput>
  }

  /**
   * ep_role delete
   */
  export type ep_roleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_role
     */
    select?: ep_roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_role
     */
    omit?: ep_roleOmit<ExtArgs> | null
    /**
     * Filter which ep_role to delete.
     */
    where: ep_roleWhereUniqueInput
  }

  /**
   * ep_role deleteMany
   */
  export type ep_roleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ep_roles to delete
     */
    where?: ep_roleWhereInput
    /**
     * Limit how many ep_roles to delete.
     */
    limit?: number
  }

  /**
   * ep_role without action
   */
  export type ep_roleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_role
     */
    select?: ep_roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_role
     */
    omit?: ep_roleOmit<ExtArgs> | null
  }


  /**
   * Model ep_server
   */

  export type AggregateEp_server = {
    _count: Ep_serverCountAggregateOutputType | null
    _avg: Ep_serverAvgAggregateOutputType | null
    _sum: Ep_serverSumAggregateOutputType | null
    _min: Ep_serverMinAggregateOutputType | null
    _max: Ep_serverMaxAggregateOutputType | null
  }

  export type Ep_serverAvgAggregateOutputType = {
    server_id: number | null
    server_timeout: number | null
    server_version: number | null
  }

  export type Ep_serverSumAggregateOutputType = {
    server_id: number | null
    server_timeout: number | null
    server_version: number | null
  }

  export type Ep_serverMinAggregateOutputType = {
    server_id: number | null
    server_type: string | null
    server_port: string | null
    server_protocol: string | null
    server_mail: string | null
    server_password: string | null
    server_timeout: number | null
    server_version: number | null
  }

  export type Ep_serverMaxAggregateOutputType = {
    server_id: number | null
    server_type: string | null
    server_port: string | null
    server_protocol: string | null
    server_mail: string | null
    server_password: string | null
    server_timeout: number | null
    server_version: number | null
  }

  export type Ep_serverCountAggregateOutputType = {
    server_id: number
    server_type: number
    server_port: number
    server_protocol: number
    server_mail: number
    server_password: number
    server_timeout: number
    server_version: number
    _all: number
  }


  export type Ep_serverAvgAggregateInputType = {
    server_id?: true
    server_timeout?: true
    server_version?: true
  }

  export type Ep_serverSumAggregateInputType = {
    server_id?: true
    server_timeout?: true
    server_version?: true
  }

  export type Ep_serverMinAggregateInputType = {
    server_id?: true
    server_type?: true
    server_port?: true
    server_protocol?: true
    server_mail?: true
    server_password?: true
    server_timeout?: true
    server_version?: true
  }

  export type Ep_serverMaxAggregateInputType = {
    server_id?: true
    server_type?: true
    server_port?: true
    server_protocol?: true
    server_mail?: true
    server_password?: true
    server_timeout?: true
    server_version?: true
  }

  export type Ep_serverCountAggregateInputType = {
    server_id?: true
    server_type?: true
    server_port?: true
    server_protocol?: true
    server_mail?: true
    server_password?: true
    server_timeout?: true
    server_version?: true
    _all?: true
  }

  export type Ep_serverAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ep_server to aggregate.
     */
    where?: ep_serverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ep_servers to fetch.
     */
    orderBy?: ep_serverOrderByWithRelationInput | ep_serverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ep_serverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ep_servers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ep_servers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ep_servers
    **/
    _count?: true | Ep_serverCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Ep_serverAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Ep_serverSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Ep_serverMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Ep_serverMaxAggregateInputType
  }

  export type GetEp_serverAggregateType<T extends Ep_serverAggregateArgs> = {
        [P in keyof T & keyof AggregateEp_server]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEp_server[P]>
      : GetScalarType<T[P], AggregateEp_server[P]>
  }




  export type ep_serverGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ep_serverWhereInput
    orderBy?: ep_serverOrderByWithAggregationInput | ep_serverOrderByWithAggregationInput[]
    by: Ep_serverScalarFieldEnum[] | Ep_serverScalarFieldEnum
    having?: ep_serverScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Ep_serverCountAggregateInputType | true
    _avg?: Ep_serverAvgAggregateInputType
    _sum?: Ep_serverSumAggregateInputType
    _min?: Ep_serverMinAggregateInputType
    _max?: Ep_serverMaxAggregateInputType
  }

  export type Ep_serverGroupByOutputType = {
    server_id: number
    server_type: string
    server_port: string
    server_protocol: string
    server_mail: string
    server_password: string
    server_timeout: number
    server_version: number
    _count: Ep_serverCountAggregateOutputType | null
    _avg: Ep_serverAvgAggregateOutputType | null
    _sum: Ep_serverSumAggregateOutputType | null
    _min: Ep_serverMinAggregateOutputType | null
    _max: Ep_serverMaxAggregateOutputType | null
  }

  type GetEp_serverGroupByPayload<T extends ep_serverGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Ep_serverGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Ep_serverGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Ep_serverGroupByOutputType[P]>
            : GetScalarType<T[P], Ep_serverGroupByOutputType[P]>
        }
      >
    >


  export type ep_serverSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    server_id?: boolean
    server_type?: boolean
    server_port?: boolean
    server_protocol?: boolean
    server_mail?: boolean
    server_password?: boolean
    server_timeout?: boolean
    server_version?: boolean
  }, ExtArgs["result"]["ep_server"]>

  export type ep_serverSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    server_id?: boolean
    server_type?: boolean
    server_port?: boolean
    server_protocol?: boolean
    server_mail?: boolean
    server_password?: boolean
    server_timeout?: boolean
    server_version?: boolean
  }, ExtArgs["result"]["ep_server"]>

  export type ep_serverSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    server_id?: boolean
    server_type?: boolean
    server_port?: boolean
    server_protocol?: boolean
    server_mail?: boolean
    server_password?: boolean
    server_timeout?: boolean
    server_version?: boolean
  }, ExtArgs["result"]["ep_server"]>

  export type ep_serverSelectScalar = {
    server_id?: boolean
    server_type?: boolean
    server_port?: boolean
    server_protocol?: boolean
    server_mail?: boolean
    server_password?: boolean
    server_timeout?: boolean
    server_version?: boolean
  }

  export type ep_serverOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"server_id" | "server_type" | "server_port" | "server_protocol" | "server_mail" | "server_password" | "server_timeout" | "server_version", ExtArgs["result"]["ep_server"]>

  export type $ep_serverPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ep_server"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      server_id: number
      server_type: string
      server_port: string
      server_protocol: string
      server_mail: string
      server_password: string
      server_timeout: number
      server_version: number
    }, ExtArgs["result"]["ep_server"]>
    composites: {}
  }

  type ep_serverGetPayload<S extends boolean | null | undefined | ep_serverDefaultArgs> = $Result.GetResult<Prisma.$ep_serverPayload, S>

  type ep_serverCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ep_serverFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Ep_serverCountAggregateInputType | true
    }

  export interface ep_serverDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ep_server'], meta: { name: 'ep_server' } }
    /**
     * Find zero or one Ep_server that matches the filter.
     * @param {ep_serverFindUniqueArgs} args - Arguments to find a Ep_server
     * @example
     * // Get one Ep_server
     * const ep_server = await prisma.ep_server.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ep_serverFindUniqueArgs>(args: SelectSubset<T, ep_serverFindUniqueArgs<ExtArgs>>): Prisma__ep_serverClient<$Result.GetResult<Prisma.$ep_serverPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ep_server that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ep_serverFindUniqueOrThrowArgs} args - Arguments to find a Ep_server
     * @example
     * // Get one Ep_server
     * const ep_server = await prisma.ep_server.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ep_serverFindUniqueOrThrowArgs>(args: SelectSubset<T, ep_serverFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ep_serverClient<$Result.GetResult<Prisma.$ep_serverPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ep_server that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ep_serverFindFirstArgs} args - Arguments to find a Ep_server
     * @example
     * // Get one Ep_server
     * const ep_server = await prisma.ep_server.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ep_serverFindFirstArgs>(args?: SelectSubset<T, ep_serverFindFirstArgs<ExtArgs>>): Prisma__ep_serverClient<$Result.GetResult<Prisma.$ep_serverPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ep_server that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ep_serverFindFirstOrThrowArgs} args - Arguments to find a Ep_server
     * @example
     * // Get one Ep_server
     * const ep_server = await prisma.ep_server.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ep_serverFindFirstOrThrowArgs>(args?: SelectSubset<T, ep_serverFindFirstOrThrowArgs<ExtArgs>>): Prisma__ep_serverClient<$Result.GetResult<Prisma.$ep_serverPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ep_servers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ep_serverFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ep_servers
     * const ep_servers = await prisma.ep_server.findMany()
     * 
     * // Get first 10 Ep_servers
     * const ep_servers = await prisma.ep_server.findMany({ take: 10 })
     * 
     * // Only select the `server_id`
     * const ep_serverWithServer_idOnly = await prisma.ep_server.findMany({ select: { server_id: true } })
     * 
     */
    findMany<T extends ep_serverFindManyArgs>(args?: SelectSubset<T, ep_serverFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ep_serverPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ep_server.
     * @param {ep_serverCreateArgs} args - Arguments to create a Ep_server.
     * @example
     * // Create one Ep_server
     * const Ep_server = await prisma.ep_server.create({
     *   data: {
     *     // ... data to create a Ep_server
     *   }
     * })
     * 
     */
    create<T extends ep_serverCreateArgs>(args: SelectSubset<T, ep_serverCreateArgs<ExtArgs>>): Prisma__ep_serverClient<$Result.GetResult<Prisma.$ep_serverPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ep_servers.
     * @param {ep_serverCreateManyArgs} args - Arguments to create many Ep_servers.
     * @example
     * // Create many Ep_servers
     * const ep_server = await prisma.ep_server.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ep_serverCreateManyArgs>(args?: SelectSubset<T, ep_serverCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ep_servers and returns the data saved in the database.
     * @param {ep_serverCreateManyAndReturnArgs} args - Arguments to create many Ep_servers.
     * @example
     * // Create many Ep_servers
     * const ep_server = await prisma.ep_server.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ep_servers and only return the `server_id`
     * const ep_serverWithServer_idOnly = await prisma.ep_server.createManyAndReturn({
     *   select: { server_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ep_serverCreateManyAndReturnArgs>(args?: SelectSubset<T, ep_serverCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ep_serverPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Ep_server.
     * @param {ep_serverDeleteArgs} args - Arguments to delete one Ep_server.
     * @example
     * // Delete one Ep_server
     * const Ep_server = await prisma.ep_server.delete({
     *   where: {
     *     // ... filter to delete one Ep_server
     *   }
     * })
     * 
     */
    delete<T extends ep_serverDeleteArgs>(args: SelectSubset<T, ep_serverDeleteArgs<ExtArgs>>): Prisma__ep_serverClient<$Result.GetResult<Prisma.$ep_serverPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ep_server.
     * @param {ep_serverUpdateArgs} args - Arguments to update one Ep_server.
     * @example
     * // Update one Ep_server
     * const ep_server = await prisma.ep_server.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ep_serverUpdateArgs>(args: SelectSubset<T, ep_serverUpdateArgs<ExtArgs>>): Prisma__ep_serverClient<$Result.GetResult<Prisma.$ep_serverPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ep_servers.
     * @param {ep_serverDeleteManyArgs} args - Arguments to filter Ep_servers to delete.
     * @example
     * // Delete a few Ep_servers
     * const { count } = await prisma.ep_server.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ep_serverDeleteManyArgs>(args?: SelectSubset<T, ep_serverDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ep_servers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ep_serverUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ep_servers
     * const ep_server = await prisma.ep_server.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ep_serverUpdateManyArgs>(args: SelectSubset<T, ep_serverUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ep_servers and returns the data updated in the database.
     * @param {ep_serverUpdateManyAndReturnArgs} args - Arguments to update many Ep_servers.
     * @example
     * // Update many Ep_servers
     * const ep_server = await prisma.ep_server.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Ep_servers and only return the `server_id`
     * const ep_serverWithServer_idOnly = await prisma.ep_server.updateManyAndReturn({
     *   select: { server_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ep_serverUpdateManyAndReturnArgs>(args: SelectSubset<T, ep_serverUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ep_serverPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Ep_server.
     * @param {ep_serverUpsertArgs} args - Arguments to update or create a Ep_server.
     * @example
     * // Update or create a Ep_server
     * const ep_server = await prisma.ep_server.upsert({
     *   create: {
     *     // ... data to create a Ep_server
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ep_server we want to update
     *   }
     * })
     */
    upsert<T extends ep_serverUpsertArgs>(args: SelectSubset<T, ep_serverUpsertArgs<ExtArgs>>): Prisma__ep_serverClient<$Result.GetResult<Prisma.$ep_serverPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ep_servers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ep_serverCountArgs} args - Arguments to filter Ep_servers to count.
     * @example
     * // Count the number of Ep_servers
     * const count = await prisma.ep_server.count({
     *   where: {
     *     // ... the filter for the Ep_servers we want to count
     *   }
     * })
    **/
    count<T extends ep_serverCountArgs>(
      args?: Subset<T, ep_serverCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Ep_serverCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ep_server.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ep_serverAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Ep_serverAggregateArgs>(args: Subset<T, Ep_serverAggregateArgs>): Prisma.PrismaPromise<GetEp_serverAggregateType<T>>

    /**
     * Group by Ep_server.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ep_serverGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ep_serverGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ep_serverGroupByArgs['orderBy'] }
        : { orderBy?: ep_serverGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ep_serverGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEp_serverGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ep_server model
   */
  readonly fields: ep_serverFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ep_server.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ep_serverClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ep_server model
   */ 
  interface ep_serverFieldRefs {
    readonly server_id: FieldRef<"ep_server", 'Int'>
    readonly server_type: FieldRef<"ep_server", 'String'>
    readonly server_port: FieldRef<"ep_server", 'String'>
    readonly server_protocol: FieldRef<"ep_server", 'String'>
    readonly server_mail: FieldRef<"ep_server", 'String'>
    readonly server_password: FieldRef<"ep_server", 'String'>
    readonly server_timeout: FieldRef<"ep_server", 'Int'>
    readonly server_version: FieldRef<"ep_server", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ep_server findUnique
   */
  export type ep_serverFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_server
     */
    select?: ep_serverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_server
     */
    omit?: ep_serverOmit<ExtArgs> | null
    /**
     * Filter, which ep_server to fetch.
     */
    where: ep_serverWhereUniqueInput
  }

  /**
   * ep_server findUniqueOrThrow
   */
  export type ep_serverFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_server
     */
    select?: ep_serverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_server
     */
    omit?: ep_serverOmit<ExtArgs> | null
    /**
     * Filter, which ep_server to fetch.
     */
    where: ep_serverWhereUniqueInput
  }

  /**
   * ep_server findFirst
   */
  export type ep_serverFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_server
     */
    select?: ep_serverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_server
     */
    omit?: ep_serverOmit<ExtArgs> | null
    /**
     * Filter, which ep_server to fetch.
     */
    where?: ep_serverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ep_servers to fetch.
     */
    orderBy?: ep_serverOrderByWithRelationInput | ep_serverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ep_servers.
     */
    cursor?: ep_serverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ep_servers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ep_servers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ep_servers.
     */
    distinct?: Ep_serverScalarFieldEnum | Ep_serverScalarFieldEnum[]
  }

  /**
   * ep_server findFirstOrThrow
   */
  export type ep_serverFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_server
     */
    select?: ep_serverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_server
     */
    omit?: ep_serverOmit<ExtArgs> | null
    /**
     * Filter, which ep_server to fetch.
     */
    where?: ep_serverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ep_servers to fetch.
     */
    orderBy?: ep_serverOrderByWithRelationInput | ep_serverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ep_servers.
     */
    cursor?: ep_serverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ep_servers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ep_servers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ep_servers.
     */
    distinct?: Ep_serverScalarFieldEnum | Ep_serverScalarFieldEnum[]
  }

  /**
   * ep_server findMany
   */
  export type ep_serverFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_server
     */
    select?: ep_serverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_server
     */
    omit?: ep_serverOmit<ExtArgs> | null
    /**
     * Filter, which ep_servers to fetch.
     */
    where?: ep_serverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ep_servers to fetch.
     */
    orderBy?: ep_serverOrderByWithRelationInput | ep_serverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ep_servers.
     */
    cursor?: ep_serverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ep_servers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ep_servers.
     */
    skip?: number
    distinct?: Ep_serverScalarFieldEnum | Ep_serverScalarFieldEnum[]
  }

  /**
   * ep_server create
   */
  export type ep_serverCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_server
     */
    select?: ep_serverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_server
     */
    omit?: ep_serverOmit<ExtArgs> | null
    /**
     * The data needed to create a ep_server.
     */
    data: XOR<ep_serverCreateInput, ep_serverUncheckedCreateInput>
  }

  /**
   * ep_server createMany
   */
  export type ep_serverCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ep_servers.
     */
    data: ep_serverCreateManyInput | ep_serverCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ep_server createManyAndReturn
   */
  export type ep_serverCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_server
     */
    select?: ep_serverSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ep_server
     */
    omit?: ep_serverOmit<ExtArgs> | null
    /**
     * The data used to create many ep_servers.
     */
    data: ep_serverCreateManyInput | ep_serverCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ep_server update
   */
  export type ep_serverUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_server
     */
    select?: ep_serverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_server
     */
    omit?: ep_serverOmit<ExtArgs> | null
    /**
     * The data needed to update a ep_server.
     */
    data: XOR<ep_serverUpdateInput, ep_serverUncheckedUpdateInput>
    /**
     * Choose, which ep_server to update.
     */
    where: ep_serverWhereUniqueInput
  }

  /**
   * ep_server updateMany
   */
  export type ep_serverUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ep_servers.
     */
    data: XOR<ep_serverUpdateManyMutationInput, ep_serverUncheckedUpdateManyInput>
    /**
     * Filter which ep_servers to update
     */
    where?: ep_serverWhereInput
    /**
     * Limit how many ep_servers to update.
     */
    limit?: number
  }

  /**
   * ep_server updateManyAndReturn
   */
  export type ep_serverUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_server
     */
    select?: ep_serverSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ep_server
     */
    omit?: ep_serverOmit<ExtArgs> | null
    /**
     * The data used to update ep_servers.
     */
    data: XOR<ep_serverUpdateManyMutationInput, ep_serverUncheckedUpdateManyInput>
    /**
     * Filter which ep_servers to update
     */
    where?: ep_serverWhereInput
    /**
     * Limit how many ep_servers to update.
     */
    limit?: number
  }

  /**
   * ep_server upsert
   */
  export type ep_serverUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_server
     */
    select?: ep_serverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_server
     */
    omit?: ep_serverOmit<ExtArgs> | null
    /**
     * The filter to search for the ep_server to update in case it exists.
     */
    where: ep_serverWhereUniqueInput
    /**
     * In case the ep_server found by the `where` argument doesn't exist, create a new ep_server with this data.
     */
    create: XOR<ep_serverCreateInput, ep_serverUncheckedCreateInput>
    /**
     * In case the ep_server was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ep_serverUpdateInput, ep_serverUncheckedUpdateInput>
  }

  /**
   * ep_server delete
   */
  export type ep_serverDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_server
     */
    select?: ep_serverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_server
     */
    omit?: ep_serverOmit<ExtArgs> | null
    /**
     * Filter which ep_server to delete.
     */
    where: ep_serverWhereUniqueInput
  }

  /**
   * ep_server deleteMany
   */
  export type ep_serverDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ep_servers to delete
     */
    where?: ep_serverWhereInput
    /**
     * Limit how many ep_servers to delete.
     */
    limit?: number
  }

  /**
   * ep_server without action
   */
  export type ep_serverDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_server
     */
    select?: ep_serverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_server
     */
    omit?: ep_serverOmit<ExtArgs> | null
  }


  /**
   * Model ep_tax
   */

  export type AggregateEp_tax = {
    _count: Ep_taxCountAggregateOutputType | null
    _avg: Ep_taxAvgAggregateOutputType | null
    _sum: Ep_taxSumAggregateOutputType | null
    _min: Ep_taxMinAggregateOutputType | null
    _max: Ep_taxMaxAggregateOutputType | null
  }

  export type Ep_taxAvgAggregateOutputType = {
    tax_id: number | null
    tax_price: number | null
    tax_version: number | null
  }

  export type Ep_taxSumAggregateOutputType = {
    tax_id: number | null
    tax_price: number | null
    tax_version: number | null
  }

  export type Ep_taxMinAggregateOutputType = {
    tax_id: number | null
    tax_price: number | null
    tax_version: number | null
  }

  export type Ep_taxMaxAggregateOutputType = {
    tax_id: number | null
    tax_price: number | null
    tax_version: number | null
  }

  export type Ep_taxCountAggregateOutputType = {
    tax_id: number
    tax_price: number
    tax_version: number
    _all: number
  }


  export type Ep_taxAvgAggregateInputType = {
    tax_id?: true
    tax_price?: true
    tax_version?: true
  }

  export type Ep_taxSumAggregateInputType = {
    tax_id?: true
    tax_price?: true
    tax_version?: true
  }

  export type Ep_taxMinAggregateInputType = {
    tax_id?: true
    tax_price?: true
    tax_version?: true
  }

  export type Ep_taxMaxAggregateInputType = {
    tax_id?: true
    tax_price?: true
    tax_version?: true
  }

  export type Ep_taxCountAggregateInputType = {
    tax_id?: true
    tax_price?: true
    tax_version?: true
    _all?: true
  }

  export type Ep_taxAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ep_tax to aggregate.
     */
    where?: ep_taxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ep_taxes to fetch.
     */
    orderBy?: ep_taxOrderByWithRelationInput | ep_taxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ep_taxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ep_taxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ep_taxes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ep_taxes
    **/
    _count?: true | Ep_taxCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Ep_taxAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Ep_taxSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Ep_taxMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Ep_taxMaxAggregateInputType
  }

  export type GetEp_taxAggregateType<T extends Ep_taxAggregateArgs> = {
        [P in keyof T & keyof AggregateEp_tax]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEp_tax[P]>
      : GetScalarType<T[P], AggregateEp_tax[P]>
  }




  export type ep_taxGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ep_taxWhereInput
    orderBy?: ep_taxOrderByWithAggregationInput | ep_taxOrderByWithAggregationInput[]
    by: Ep_taxScalarFieldEnum[] | Ep_taxScalarFieldEnum
    having?: ep_taxScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Ep_taxCountAggregateInputType | true
    _avg?: Ep_taxAvgAggregateInputType
    _sum?: Ep_taxSumAggregateInputType
    _min?: Ep_taxMinAggregateInputType
    _max?: Ep_taxMaxAggregateInputType
  }

  export type Ep_taxGroupByOutputType = {
    tax_id: number
    tax_price: number
    tax_version: number
    _count: Ep_taxCountAggregateOutputType | null
    _avg: Ep_taxAvgAggregateOutputType | null
    _sum: Ep_taxSumAggregateOutputType | null
    _min: Ep_taxMinAggregateOutputType | null
    _max: Ep_taxMaxAggregateOutputType | null
  }

  type GetEp_taxGroupByPayload<T extends ep_taxGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Ep_taxGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Ep_taxGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Ep_taxGroupByOutputType[P]>
            : GetScalarType<T[P], Ep_taxGroupByOutputType[P]>
        }
      >
    >


  export type ep_taxSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tax_id?: boolean
    tax_price?: boolean
    tax_version?: boolean
  }, ExtArgs["result"]["ep_tax"]>

  export type ep_taxSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tax_id?: boolean
    tax_price?: boolean
    tax_version?: boolean
  }, ExtArgs["result"]["ep_tax"]>

  export type ep_taxSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tax_id?: boolean
    tax_price?: boolean
    tax_version?: boolean
  }, ExtArgs["result"]["ep_tax"]>

  export type ep_taxSelectScalar = {
    tax_id?: boolean
    tax_price?: boolean
    tax_version?: boolean
  }

  export type ep_taxOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"tax_id" | "tax_price" | "tax_version", ExtArgs["result"]["ep_tax"]>

  export type $ep_taxPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ep_tax"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      tax_id: number
      tax_price: number
      tax_version: number
    }, ExtArgs["result"]["ep_tax"]>
    composites: {}
  }

  type ep_taxGetPayload<S extends boolean | null | undefined | ep_taxDefaultArgs> = $Result.GetResult<Prisma.$ep_taxPayload, S>

  type ep_taxCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ep_taxFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Ep_taxCountAggregateInputType | true
    }

  export interface ep_taxDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ep_tax'], meta: { name: 'ep_tax' } }
    /**
     * Find zero or one Ep_tax that matches the filter.
     * @param {ep_taxFindUniqueArgs} args - Arguments to find a Ep_tax
     * @example
     * // Get one Ep_tax
     * const ep_tax = await prisma.ep_tax.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ep_taxFindUniqueArgs>(args: SelectSubset<T, ep_taxFindUniqueArgs<ExtArgs>>): Prisma__ep_taxClient<$Result.GetResult<Prisma.$ep_taxPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ep_tax that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ep_taxFindUniqueOrThrowArgs} args - Arguments to find a Ep_tax
     * @example
     * // Get one Ep_tax
     * const ep_tax = await prisma.ep_tax.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ep_taxFindUniqueOrThrowArgs>(args: SelectSubset<T, ep_taxFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ep_taxClient<$Result.GetResult<Prisma.$ep_taxPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ep_tax that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ep_taxFindFirstArgs} args - Arguments to find a Ep_tax
     * @example
     * // Get one Ep_tax
     * const ep_tax = await prisma.ep_tax.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ep_taxFindFirstArgs>(args?: SelectSubset<T, ep_taxFindFirstArgs<ExtArgs>>): Prisma__ep_taxClient<$Result.GetResult<Prisma.$ep_taxPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ep_tax that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ep_taxFindFirstOrThrowArgs} args - Arguments to find a Ep_tax
     * @example
     * // Get one Ep_tax
     * const ep_tax = await prisma.ep_tax.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ep_taxFindFirstOrThrowArgs>(args?: SelectSubset<T, ep_taxFindFirstOrThrowArgs<ExtArgs>>): Prisma__ep_taxClient<$Result.GetResult<Prisma.$ep_taxPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ep_taxes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ep_taxFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ep_taxes
     * const ep_taxes = await prisma.ep_tax.findMany()
     * 
     * // Get first 10 Ep_taxes
     * const ep_taxes = await prisma.ep_tax.findMany({ take: 10 })
     * 
     * // Only select the `tax_id`
     * const ep_taxWithTax_idOnly = await prisma.ep_tax.findMany({ select: { tax_id: true } })
     * 
     */
    findMany<T extends ep_taxFindManyArgs>(args?: SelectSubset<T, ep_taxFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ep_taxPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ep_tax.
     * @param {ep_taxCreateArgs} args - Arguments to create a Ep_tax.
     * @example
     * // Create one Ep_tax
     * const Ep_tax = await prisma.ep_tax.create({
     *   data: {
     *     // ... data to create a Ep_tax
     *   }
     * })
     * 
     */
    create<T extends ep_taxCreateArgs>(args: SelectSubset<T, ep_taxCreateArgs<ExtArgs>>): Prisma__ep_taxClient<$Result.GetResult<Prisma.$ep_taxPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ep_taxes.
     * @param {ep_taxCreateManyArgs} args - Arguments to create many Ep_taxes.
     * @example
     * // Create many Ep_taxes
     * const ep_tax = await prisma.ep_tax.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ep_taxCreateManyArgs>(args?: SelectSubset<T, ep_taxCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ep_taxes and returns the data saved in the database.
     * @param {ep_taxCreateManyAndReturnArgs} args - Arguments to create many Ep_taxes.
     * @example
     * // Create many Ep_taxes
     * const ep_tax = await prisma.ep_tax.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ep_taxes and only return the `tax_id`
     * const ep_taxWithTax_idOnly = await prisma.ep_tax.createManyAndReturn({
     *   select: { tax_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ep_taxCreateManyAndReturnArgs>(args?: SelectSubset<T, ep_taxCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ep_taxPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Ep_tax.
     * @param {ep_taxDeleteArgs} args - Arguments to delete one Ep_tax.
     * @example
     * // Delete one Ep_tax
     * const Ep_tax = await prisma.ep_tax.delete({
     *   where: {
     *     // ... filter to delete one Ep_tax
     *   }
     * })
     * 
     */
    delete<T extends ep_taxDeleteArgs>(args: SelectSubset<T, ep_taxDeleteArgs<ExtArgs>>): Prisma__ep_taxClient<$Result.GetResult<Prisma.$ep_taxPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ep_tax.
     * @param {ep_taxUpdateArgs} args - Arguments to update one Ep_tax.
     * @example
     * // Update one Ep_tax
     * const ep_tax = await prisma.ep_tax.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ep_taxUpdateArgs>(args: SelectSubset<T, ep_taxUpdateArgs<ExtArgs>>): Prisma__ep_taxClient<$Result.GetResult<Prisma.$ep_taxPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ep_taxes.
     * @param {ep_taxDeleteManyArgs} args - Arguments to filter Ep_taxes to delete.
     * @example
     * // Delete a few Ep_taxes
     * const { count } = await prisma.ep_tax.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ep_taxDeleteManyArgs>(args?: SelectSubset<T, ep_taxDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ep_taxes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ep_taxUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ep_taxes
     * const ep_tax = await prisma.ep_tax.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ep_taxUpdateManyArgs>(args: SelectSubset<T, ep_taxUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ep_taxes and returns the data updated in the database.
     * @param {ep_taxUpdateManyAndReturnArgs} args - Arguments to update many Ep_taxes.
     * @example
     * // Update many Ep_taxes
     * const ep_tax = await prisma.ep_tax.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Ep_taxes and only return the `tax_id`
     * const ep_taxWithTax_idOnly = await prisma.ep_tax.updateManyAndReturn({
     *   select: { tax_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ep_taxUpdateManyAndReturnArgs>(args: SelectSubset<T, ep_taxUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ep_taxPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Ep_tax.
     * @param {ep_taxUpsertArgs} args - Arguments to update or create a Ep_tax.
     * @example
     * // Update or create a Ep_tax
     * const ep_tax = await prisma.ep_tax.upsert({
     *   create: {
     *     // ... data to create a Ep_tax
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ep_tax we want to update
     *   }
     * })
     */
    upsert<T extends ep_taxUpsertArgs>(args: SelectSubset<T, ep_taxUpsertArgs<ExtArgs>>): Prisma__ep_taxClient<$Result.GetResult<Prisma.$ep_taxPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ep_taxes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ep_taxCountArgs} args - Arguments to filter Ep_taxes to count.
     * @example
     * // Count the number of Ep_taxes
     * const count = await prisma.ep_tax.count({
     *   where: {
     *     // ... the filter for the Ep_taxes we want to count
     *   }
     * })
    **/
    count<T extends ep_taxCountArgs>(
      args?: Subset<T, ep_taxCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Ep_taxCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ep_tax.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ep_taxAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Ep_taxAggregateArgs>(args: Subset<T, Ep_taxAggregateArgs>): Prisma.PrismaPromise<GetEp_taxAggregateType<T>>

    /**
     * Group by Ep_tax.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ep_taxGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ep_taxGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ep_taxGroupByArgs['orderBy'] }
        : { orderBy?: ep_taxGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ep_taxGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEp_taxGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ep_tax model
   */
  readonly fields: ep_taxFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ep_tax.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ep_taxClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ep_tax model
   */ 
  interface ep_taxFieldRefs {
    readonly tax_id: FieldRef<"ep_tax", 'Int'>
    readonly tax_price: FieldRef<"ep_tax", 'Int'>
    readonly tax_version: FieldRef<"ep_tax", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ep_tax findUnique
   */
  export type ep_taxFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_tax
     */
    select?: ep_taxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_tax
     */
    omit?: ep_taxOmit<ExtArgs> | null
    /**
     * Filter, which ep_tax to fetch.
     */
    where: ep_taxWhereUniqueInput
  }

  /**
   * ep_tax findUniqueOrThrow
   */
  export type ep_taxFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_tax
     */
    select?: ep_taxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_tax
     */
    omit?: ep_taxOmit<ExtArgs> | null
    /**
     * Filter, which ep_tax to fetch.
     */
    where: ep_taxWhereUniqueInput
  }

  /**
   * ep_tax findFirst
   */
  export type ep_taxFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_tax
     */
    select?: ep_taxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_tax
     */
    omit?: ep_taxOmit<ExtArgs> | null
    /**
     * Filter, which ep_tax to fetch.
     */
    where?: ep_taxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ep_taxes to fetch.
     */
    orderBy?: ep_taxOrderByWithRelationInput | ep_taxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ep_taxes.
     */
    cursor?: ep_taxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ep_taxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ep_taxes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ep_taxes.
     */
    distinct?: Ep_taxScalarFieldEnum | Ep_taxScalarFieldEnum[]
  }

  /**
   * ep_tax findFirstOrThrow
   */
  export type ep_taxFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_tax
     */
    select?: ep_taxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_tax
     */
    omit?: ep_taxOmit<ExtArgs> | null
    /**
     * Filter, which ep_tax to fetch.
     */
    where?: ep_taxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ep_taxes to fetch.
     */
    orderBy?: ep_taxOrderByWithRelationInput | ep_taxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ep_taxes.
     */
    cursor?: ep_taxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ep_taxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ep_taxes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ep_taxes.
     */
    distinct?: Ep_taxScalarFieldEnum | Ep_taxScalarFieldEnum[]
  }

  /**
   * ep_tax findMany
   */
  export type ep_taxFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_tax
     */
    select?: ep_taxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_tax
     */
    omit?: ep_taxOmit<ExtArgs> | null
    /**
     * Filter, which ep_taxes to fetch.
     */
    where?: ep_taxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ep_taxes to fetch.
     */
    orderBy?: ep_taxOrderByWithRelationInput | ep_taxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ep_taxes.
     */
    cursor?: ep_taxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ep_taxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ep_taxes.
     */
    skip?: number
    distinct?: Ep_taxScalarFieldEnum | Ep_taxScalarFieldEnum[]
  }

  /**
   * ep_tax create
   */
  export type ep_taxCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_tax
     */
    select?: ep_taxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_tax
     */
    omit?: ep_taxOmit<ExtArgs> | null
    /**
     * The data needed to create a ep_tax.
     */
    data: XOR<ep_taxCreateInput, ep_taxUncheckedCreateInput>
  }

  /**
   * ep_tax createMany
   */
  export type ep_taxCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ep_taxes.
     */
    data: ep_taxCreateManyInput | ep_taxCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ep_tax createManyAndReturn
   */
  export type ep_taxCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_tax
     */
    select?: ep_taxSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ep_tax
     */
    omit?: ep_taxOmit<ExtArgs> | null
    /**
     * The data used to create many ep_taxes.
     */
    data: ep_taxCreateManyInput | ep_taxCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ep_tax update
   */
  export type ep_taxUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_tax
     */
    select?: ep_taxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_tax
     */
    omit?: ep_taxOmit<ExtArgs> | null
    /**
     * The data needed to update a ep_tax.
     */
    data: XOR<ep_taxUpdateInput, ep_taxUncheckedUpdateInput>
    /**
     * Choose, which ep_tax to update.
     */
    where: ep_taxWhereUniqueInput
  }

  /**
   * ep_tax updateMany
   */
  export type ep_taxUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ep_taxes.
     */
    data: XOR<ep_taxUpdateManyMutationInput, ep_taxUncheckedUpdateManyInput>
    /**
     * Filter which ep_taxes to update
     */
    where?: ep_taxWhereInput
    /**
     * Limit how many ep_taxes to update.
     */
    limit?: number
  }

  /**
   * ep_tax updateManyAndReturn
   */
  export type ep_taxUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_tax
     */
    select?: ep_taxSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ep_tax
     */
    omit?: ep_taxOmit<ExtArgs> | null
    /**
     * The data used to update ep_taxes.
     */
    data: XOR<ep_taxUpdateManyMutationInput, ep_taxUncheckedUpdateManyInput>
    /**
     * Filter which ep_taxes to update
     */
    where?: ep_taxWhereInput
    /**
     * Limit how many ep_taxes to update.
     */
    limit?: number
  }

  /**
   * ep_tax upsert
   */
  export type ep_taxUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_tax
     */
    select?: ep_taxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_tax
     */
    omit?: ep_taxOmit<ExtArgs> | null
    /**
     * The filter to search for the ep_tax to update in case it exists.
     */
    where: ep_taxWhereUniqueInput
    /**
     * In case the ep_tax found by the `where` argument doesn't exist, create a new ep_tax with this data.
     */
    create: XOR<ep_taxCreateInput, ep_taxUncheckedCreateInput>
    /**
     * In case the ep_tax was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ep_taxUpdateInput, ep_taxUncheckedUpdateInput>
  }

  /**
   * ep_tax delete
   */
  export type ep_taxDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_tax
     */
    select?: ep_taxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_tax
     */
    omit?: ep_taxOmit<ExtArgs> | null
    /**
     * Filter which ep_tax to delete.
     */
    where: ep_taxWhereUniqueInput
  }

  /**
   * ep_tax deleteMany
   */
  export type ep_taxDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ep_taxes to delete
     */
    where?: ep_taxWhereInput
    /**
     * Limit how many ep_taxes to delete.
     */
    limit?: number
  }

  /**
   * ep_tax without action
   */
  export type ep_taxDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_tax
     */
    select?: ep_taxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_tax
     */
    omit?: ep_taxOmit<ExtArgs> | null
  }


  /**
   * Model ep_users
   */

  export type AggregateEp_users = {
    _count: Ep_usersCountAggregateOutputType | null
    _avg: Ep_usersAvgAggregateOutputType | null
    _sum: Ep_usersSumAggregateOutputType | null
    _min: Ep_usersMinAggregateOutputType | null
    _max: Ep_usersMaxAggregateOutputType | null
  }

  export type Ep_usersAvgAggregateOutputType = {
    users_id: number | null
    users_version: number | null
  }

  export type Ep_usersSumAggregateOutputType = {
    users_id: number | null
    users_version: number | null
  }

  export type Ep_usersMinAggregateOutputType = {
    users_id: number | null
    users_name: string | null
    users_lastname: string | null
    users_ced: string | null
    users_version: number | null
    user_username: string | null
    user_password: string | null
    users_email: string | null
  }

  export type Ep_usersMaxAggregateOutputType = {
    users_id: number | null
    users_name: string | null
    users_lastname: string | null
    users_ced: string | null
    users_version: number | null
    user_username: string | null
    user_password: string | null
    users_email: string | null
  }

  export type Ep_usersCountAggregateOutputType = {
    users_id: number
    users_name: number
    users_lastname: number
    users_ced: number
    users_version: number
    user_username: number
    user_password: number
    users_email: number
    _all: number
  }


  export type Ep_usersAvgAggregateInputType = {
    users_id?: true
    users_version?: true
  }

  export type Ep_usersSumAggregateInputType = {
    users_id?: true
    users_version?: true
  }

  export type Ep_usersMinAggregateInputType = {
    users_id?: true
    users_name?: true
    users_lastname?: true
    users_ced?: true
    users_version?: true
    user_username?: true
    user_password?: true
    users_email?: true
  }

  export type Ep_usersMaxAggregateInputType = {
    users_id?: true
    users_name?: true
    users_lastname?: true
    users_ced?: true
    users_version?: true
    user_username?: true
    user_password?: true
    users_email?: true
  }

  export type Ep_usersCountAggregateInputType = {
    users_id?: true
    users_name?: true
    users_lastname?: true
    users_ced?: true
    users_version?: true
    user_username?: true
    user_password?: true
    users_email?: true
    _all?: true
  }

  export type Ep_usersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ep_users to aggregate.
     */
    where?: ep_usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ep_users to fetch.
     */
    orderBy?: ep_usersOrderByWithRelationInput | ep_usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ep_usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ep_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ep_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ep_users
    **/
    _count?: true | Ep_usersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Ep_usersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Ep_usersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Ep_usersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Ep_usersMaxAggregateInputType
  }

  export type GetEp_usersAggregateType<T extends Ep_usersAggregateArgs> = {
        [P in keyof T & keyof AggregateEp_users]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEp_users[P]>
      : GetScalarType<T[P], AggregateEp_users[P]>
  }




  export type ep_usersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ep_usersWhereInput
    orderBy?: ep_usersOrderByWithAggregationInput | ep_usersOrderByWithAggregationInput[]
    by: Ep_usersScalarFieldEnum[] | Ep_usersScalarFieldEnum
    having?: ep_usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Ep_usersCountAggregateInputType | true
    _avg?: Ep_usersAvgAggregateInputType
    _sum?: Ep_usersSumAggregateInputType
    _min?: Ep_usersMinAggregateInputType
    _max?: Ep_usersMaxAggregateInputType
  }

  export type Ep_usersGroupByOutputType = {
    users_id: number
    users_name: string
    users_lastname: string
    users_ced: string
    users_version: number
    user_username: string
    user_password: string
    users_email: string
    _count: Ep_usersCountAggregateOutputType | null
    _avg: Ep_usersAvgAggregateOutputType | null
    _sum: Ep_usersSumAggregateOutputType | null
    _min: Ep_usersMinAggregateOutputType | null
    _max: Ep_usersMaxAggregateOutputType | null
  }

  type GetEp_usersGroupByPayload<T extends ep_usersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Ep_usersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Ep_usersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Ep_usersGroupByOutputType[P]>
            : GetScalarType<T[P], Ep_usersGroupByOutputType[P]>
        }
      >
    >


  export type ep_usersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    users_id?: boolean
    users_name?: boolean
    users_lastname?: boolean
    users_ced?: boolean
    users_version?: boolean
    user_username?: boolean
    user_password?: boolean
    users_email?: boolean
    ep_cash_per_day?: boolean | ep_users$ep_cash_per_dayArgs<ExtArgs>
    notes?: boolean | ep_users$notesArgs<ExtArgs>
    _count?: boolean | Ep_usersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ep_users"]>

  export type ep_usersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    users_id?: boolean
    users_name?: boolean
    users_lastname?: boolean
    users_ced?: boolean
    users_version?: boolean
    user_username?: boolean
    user_password?: boolean
    users_email?: boolean
  }, ExtArgs["result"]["ep_users"]>

  export type ep_usersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    users_id?: boolean
    users_name?: boolean
    users_lastname?: boolean
    users_ced?: boolean
    users_version?: boolean
    user_username?: boolean
    user_password?: boolean
    users_email?: boolean
  }, ExtArgs["result"]["ep_users"]>

  export type ep_usersSelectScalar = {
    users_id?: boolean
    users_name?: boolean
    users_lastname?: boolean
    users_ced?: boolean
    users_version?: boolean
    user_username?: boolean
    user_password?: boolean
    users_email?: boolean
  }

  export type ep_usersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"users_id" | "users_name" | "users_lastname" | "users_ced" | "users_version" | "user_username" | "user_password" | "users_email", ExtArgs["result"]["ep_users"]>
  export type ep_usersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ep_cash_per_day?: boolean | ep_users$ep_cash_per_dayArgs<ExtArgs>
    notes?: boolean | ep_users$notesArgs<ExtArgs>
    _count?: boolean | Ep_usersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ep_usersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ep_usersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ep_usersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ep_users"
    objects: {
      ep_cash_per_day: Prisma.$ep_cash_per_dayPayload<ExtArgs>[]
      notes: Prisma.$ep_notesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      users_id: number
      users_name: string
      users_lastname: string
      users_ced: string
      users_version: number
      user_username: string
      user_password: string
      users_email: string
    }, ExtArgs["result"]["ep_users"]>
    composites: {}
  }

  type ep_usersGetPayload<S extends boolean | null | undefined | ep_usersDefaultArgs> = $Result.GetResult<Prisma.$ep_usersPayload, S>

  type ep_usersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ep_usersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Ep_usersCountAggregateInputType | true
    }

  export interface ep_usersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ep_users'], meta: { name: 'ep_users' } }
    /**
     * Find zero or one Ep_users that matches the filter.
     * @param {ep_usersFindUniqueArgs} args - Arguments to find a Ep_users
     * @example
     * // Get one Ep_users
     * const ep_users = await prisma.ep_users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ep_usersFindUniqueArgs>(args: SelectSubset<T, ep_usersFindUniqueArgs<ExtArgs>>): Prisma__ep_usersClient<$Result.GetResult<Prisma.$ep_usersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ep_users that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ep_usersFindUniqueOrThrowArgs} args - Arguments to find a Ep_users
     * @example
     * // Get one Ep_users
     * const ep_users = await prisma.ep_users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ep_usersFindUniqueOrThrowArgs>(args: SelectSubset<T, ep_usersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ep_usersClient<$Result.GetResult<Prisma.$ep_usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ep_users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ep_usersFindFirstArgs} args - Arguments to find a Ep_users
     * @example
     * // Get one Ep_users
     * const ep_users = await prisma.ep_users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ep_usersFindFirstArgs>(args?: SelectSubset<T, ep_usersFindFirstArgs<ExtArgs>>): Prisma__ep_usersClient<$Result.GetResult<Prisma.$ep_usersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ep_users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ep_usersFindFirstOrThrowArgs} args - Arguments to find a Ep_users
     * @example
     * // Get one Ep_users
     * const ep_users = await prisma.ep_users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ep_usersFindFirstOrThrowArgs>(args?: SelectSubset<T, ep_usersFindFirstOrThrowArgs<ExtArgs>>): Prisma__ep_usersClient<$Result.GetResult<Prisma.$ep_usersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ep_users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ep_usersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ep_users
     * const ep_users = await prisma.ep_users.findMany()
     * 
     * // Get first 10 Ep_users
     * const ep_users = await prisma.ep_users.findMany({ take: 10 })
     * 
     * // Only select the `users_id`
     * const ep_usersWithUsers_idOnly = await prisma.ep_users.findMany({ select: { users_id: true } })
     * 
     */
    findMany<T extends ep_usersFindManyArgs>(args?: SelectSubset<T, ep_usersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ep_usersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ep_users.
     * @param {ep_usersCreateArgs} args - Arguments to create a Ep_users.
     * @example
     * // Create one Ep_users
     * const Ep_users = await prisma.ep_users.create({
     *   data: {
     *     // ... data to create a Ep_users
     *   }
     * })
     * 
     */
    create<T extends ep_usersCreateArgs>(args: SelectSubset<T, ep_usersCreateArgs<ExtArgs>>): Prisma__ep_usersClient<$Result.GetResult<Prisma.$ep_usersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ep_users.
     * @param {ep_usersCreateManyArgs} args - Arguments to create many Ep_users.
     * @example
     * // Create many Ep_users
     * const ep_users = await prisma.ep_users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ep_usersCreateManyArgs>(args?: SelectSubset<T, ep_usersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ep_users and returns the data saved in the database.
     * @param {ep_usersCreateManyAndReturnArgs} args - Arguments to create many Ep_users.
     * @example
     * // Create many Ep_users
     * const ep_users = await prisma.ep_users.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ep_users and only return the `users_id`
     * const ep_usersWithUsers_idOnly = await prisma.ep_users.createManyAndReturn({
     *   select: { users_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ep_usersCreateManyAndReturnArgs>(args?: SelectSubset<T, ep_usersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ep_usersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Ep_users.
     * @param {ep_usersDeleteArgs} args - Arguments to delete one Ep_users.
     * @example
     * // Delete one Ep_users
     * const Ep_users = await prisma.ep_users.delete({
     *   where: {
     *     // ... filter to delete one Ep_users
     *   }
     * })
     * 
     */
    delete<T extends ep_usersDeleteArgs>(args: SelectSubset<T, ep_usersDeleteArgs<ExtArgs>>): Prisma__ep_usersClient<$Result.GetResult<Prisma.$ep_usersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ep_users.
     * @param {ep_usersUpdateArgs} args - Arguments to update one Ep_users.
     * @example
     * // Update one Ep_users
     * const ep_users = await prisma.ep_users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ep_usersUpdateArgs>(args: SelectSubset<T, ep_usersUpdateArgs<ExtArgs>>): Prisma__ep_usersClient<$Result.GetResult<Prisma.$ep_usersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ep_users.
     * @param {ep_usersDeleteManyArgs} args - Arguments to filter Ep_users to delete.
     * @example
     * // Delete a few Ep_users
     * const { count } = await prisma.ep_users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ep_usersDeleteManyArgs>(args?: SelectSubset<T, ep_usersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ep_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ep_usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ep_users
     * const ep_users = await prisma.ep_users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ep_usersUpdateManyArgs>(args: SelectSubset<T, ep_usersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ep_users and returns the data updated in the database.
     * @param {ep_usersUpdateManyAndReturnArgs} args - Arguments to update many Ep_users.
     * @example
     * // Update many Ep_users
     * const ep_users = await prisma.ep_users.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Ep_users and only return the `users_id`
     * const ep_usersWithUsers_idOnly = await prisma.ep_users.updateManyAndReturn({
     *   select: { users_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ep_usersUpdateManyAndReturnArgs>(args: SelectSubset<T, ep_usersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ep_usersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Ep_users.
     * @param {ep_usersUpsertArgs} args - Arguments to update or create a Ep_users.
     * @example
     * // Update or create a Ep_users
     * const ep_users = await prisma.ep_users.upsert({
     *   create: {
     *     // ... data to create a Ep_users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ep_users we want to update
     *   }
     * })
     */
    upsert<T extends ep_usersUpsertArgs>(args: SelectSubset<T, ep_usersUpsertArgs<ExtArgs>>): Prisma__ep_usersClient<$Result.GetResult<Prisma.$ep_usersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ep_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ep_usersCountArgs} args - Arguments to filter Ep_users to count.
     * @example
     * // Count the number of Ep_users
     * const count = await prisma.ep_users.count({
     *   where: {
     *     // ... the filter for the Ep_users we want to count
     *   }
     * })
    **/
    count<T extends ep_usersCountArgs>(
      args?: Subset<T, ep_usersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Ep_usersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ep_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ep_usersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Ep_usersAggregateArgs>(args: Subset<T, Ep_usersAggregateArgs>): Prisma.PrismaPromise<GetEp_usersAggregateType<T>>

    /**
     * Group by Ep_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ep_usersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ep_usersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ep_usersGroupByArgs['orderBy'] }
        : { orderBy?: ep_usersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ep_usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEp_usersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ep_users model
   */
  readonly fields: ep_usersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ep_users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ep_usersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ep_cash_per_day<T extends ep_users$ep_cash_per_dayArgs<ExtArgs> = {}>(args?: Subset<T, ep_users$ep_cash_per_dayArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ep_cash_per_dayPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notes<T extends ep_users$notesArgs<ExtArgs> = {}>(args?: Subset<T, ep_users$notesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ep_notesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ep_users model
   */ 
  interface ep_usersFieldRefs {
    readonly users_id: FieldRef<"ep_users", 'Int'>
    readonly users_name: FieldRef<"ep_users", 'String'>
    readonly users_lastname: FieldRef<"ep_users", 'String'>
    readonly users_ced: FieldRef<"ep_users", 'String'>
    readonly users_version: FieldRef<"ep_users", 'Int'>
    readonly user_username: FieldRef<"ep_users", 'String'>
    readonly user_password: FieldRef<"ep_users", 'String'>
    readonly users_email: FieldRef<"ep_users", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ep_users findUnique
   */
  export type ep_usersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_users
     */
    select?: ep_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_users
     */
    omit?: ep_usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ep_usersInclude<ExtArgs> | null
    /**
     * Filter, which ep_users to fetch.
     */
    where: ep_usersWhereUniqueInput
  }

  /**
   * ep_users findUniqueOrThrow
   */
  export type ep_usersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_users
     */
    select?: ep_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_users
     */
    omit?: ep_usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ep_usersInclude<ExtArgs> | null
    /**
     * Filter, which ep_users to fetch.
     */
    where: ep_usersWhereUniqueInput
  }

  /**
   * ep_users findFirst
   */
  export type ep_usersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_users
     */
    select?: ep_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_users
     */
    omit?: ep_usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ep_usersInclude<ExtArgs> | null
    /**
     * Filter, which ep_users to fetch.
     */
    where?: ep_usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ep_users to fetch.
     */
    orderBy?: ep_usersOrderByWithRelationInput | ep_usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ep_users.
     */
    cursor?: ep_usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ep_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ep_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ep_users.
     */
    distinct?: Ep_usersScalarFieldEnum | Ep_usersScalarFieldEnum[]
  }

  /**
   * ep_users findFirstOrThrow
   */
  export type ep_usersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_users
     */
    select?: ep_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_users
     */
    omit?: ep_usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ep_usersInclude<ExtArgs> | null
    /**
     * Filter, which ep_users to fetch.
     */
    where?: ep_usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ep_users to fetch.
     */
    orderBy?: ep_usersOrderByWithRelationInput | ep_usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ep_users.
     */
    cursor?: ep_usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ep_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ep_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ep_users.
     */
    distinct?: Ep_usersScalarFieldEnum | Ep_usersScalarFieldEnum[]
  }

  /**
   * ep_users findMany
   */
  export type ep_usersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_users
     */
    select?: ep_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_users
     */
    omit?: ep_usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ep_usersInclude<ExtArgs> | null
    /**
     * Filter, which ep_users to fetch.
     */
    where?: ep_usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ep_users to fetch.
     */
    orderBy?: ep_usersOrderByWithRelationInput | ep_usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ep_users.
     */
    cursor?: ep_usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ep_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ep_users.
     */
    skip?: number
    distinct?: Ep_usersScalarFieldEnum | Ep_usersScalarFieldEnum[]
  }

  /**
   * ep_users create
   */
  export type ep_usersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_users
     */
    select?: ep_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_users
     */
    omit?: ep_usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ep_usersInclude<ExtArgs> | null
    /**
     * The data needed to create a ep_users.
     */
    data: XOR<ep_usersCreateInput, ep_usersUncheckedCreateInput>
  }

  /**
   * ep_users createMany
   */
  export type ep_usersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ep_users.
     */
    data: ep_usersCreateManyInput | ep_usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ep_users createManyAndReturn
   */
  export type ep_usersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_users
     */
    select?: ep_usersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ep_users
     */
    omit?: ep_usersOmit<ExtArgs> | null
    /**
     * The data used to create many ep_users.
     */
    data: ep_usersCreateManyInput | ep_usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ep_users update
   */
  export type ep_usersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_users
     */
    select?: ep_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_users
     */
    omit?: ep_usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ep_usersInclude<ExtArgs> | null
    /**
     * The data needed to update a ep_users.
     */
    data: XOR<ep_usersUpdateInput, ep_usersUncheckedUpdateInput>
    /**
     * Choose, which ep_users to update.
     */
    where: ep_usersWhereUniqueInput
  }

  /**
   * ep_users updateMany
   */
  export type ep_usersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ep_users.
     */
    data: XOR<ep_usersUpdateManyMutationInput, ep_usersUncheckedUpdateManyInput>
    /**
     * Filter which ep_users to update
     */
    where?: ep_usersWhereInput
    /**
     * Limit how many ep_users to update.
     */
    limit?: number
  }

  /**
   * ep_users updateManyAndReturn
   */
  export type ep_usersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_users
     */
    select?: ep_usersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ep_users
     */
    omit?: ep_usersOmit<ExtArgs> | null
    /**
     * The data used to update ep_users.
     */
    data: XOR<ep_usersUpdateManyMutationInput, ep_usersUncheckedUpdateManyInput>
    /**
     * Filter which ep_users to update
     */
    where?: ep_usersWhereInput
    /**
     * Limit how many ep_users to update.
     */
    limit?: number
  }

  /**
   * ep_users upsert
   */
  export type ep_usersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_users
     */
    select?: ep_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_users
     */
    omit?: ep_usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ep_usersInclude<ExtArgs> | null
    /**
     * The filter to search for the ep_users to update in case it exists.
     */
    where: ep_usersWhereUniqueInput
    /**
     * In case the ep_users found by the `where` argument doesn't exist, create a new ep_users with this data.
     */
    create: XOR<ep_usersCreateInput, ep_usersUncheckedCreateInput>
    /**
     * In case the ep_users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ep_usersUpdateInput, ep_usersUncheckedUpdateInput>
  }

  /**
   * ep_users delete
   */
  export type ep_usersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_users
     */
    select?: ep_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_users
     */
    omit?: ep_usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ep_usersInclude<ExtArgs> | null
    /**
     * Filter which ep_users to delete.
     */
    where: ep_usersWhereUniqueInput
  }

  /**
   * ep_users deleteMany
   */
  export type ep_usersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ep_users to delete
     */
    where?: ep_usersWhereInput
    /**
     * Limit how many ep_users to delete.
     */
    limit?: number
  }

  /**
   * ep_users.ep_cash_per_day
   */
  export type ep_users$ep_cash_per_dayArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_cash_per_day
     */
    select?: ep_cash_per_daySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_cash_per_day
     */
    omit?: ep_cash_per_dayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ep_cash_per_dayInclude<ExtArgs> | null
    where?: ep_cash_per_dayWhereInput
    orderBy?: ep_cash_per_dayOrderByWithRelationInput | ep_cash_per_dayOrderByWithRelationInput[]
    cursor?: ep_cash_per_dayWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Ep_cash_per_dayScalarFieldEnum | Ep_cash_per_dayScalarFieldEnum[]
  }

  /**
   * ep_users.notes
   */
  export type ep_users$notesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_notes
     */
    select?: ep_notesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_notes
     */
    omit?: ep_notesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ep_notesInclude<ExtArgs> | null
    where?: ep_notesWhereInput
    orderBy?: ep_notesOrderByWithRelationInput | ep_notesOrderByWithRelationInput[]
    cursor?: ep_notesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Ep_notesScalarFieldEnum | Ep_notesScalarFieldEnum[]
  }

  /**
   * ep_users without action
   */
  export type ep_usersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_users
     */
    select?: ep_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_users
     */
    omit?: ep_usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ep_usersInclude<ExtArgs> | null
  }


  /**
   * Model ep_vehicles
   */

  export type AggregateEp_vehicles = {
    _count: Ep_vehiclesCountAggregateOutputType | null
    _avg: Ep_vehiclesAvgAggregateOutputType | null
    _sum: Ep_vehiclesSumAggregateOutputType | null
    _min: Ep_vehiclesMinAggregateOutputType | null
    _max: Ep_vehiclesMaxAggregateOutputType | null
  }

  export type Ep_vehiclesAvgAggregateOutputType = {
    veh_id: number | null
    veh_version: number | null
  }

  export type Ep_vehiclesSumAggregateOutputType = {
    veh_id: number | null
    veh_version: number | null
  }

  export type Ep_vehiclesMinAggregateOutputType = {
    veh_id: number | null
    veh_plate: string | null
    veh_reference: string | null
    veh_status: string | null
    veh_owner: string | null
    veh_color: string | null
    veh_ingress_date: Date | null
    veh_egress_date: Date | null
    veh_tax: string | null
    veh_version: number | null
  }

  export type Ep_vehiclesMaxAggregateOutputType = {
    veh_id: number | null
    veh_plate: string | null
    veh_reference: string | null
    veh_status: string | null
    veh_owner: string | null
    veh_color: string | null
    veh_ingress_date: Date | null
    veh_egress_date: Date | null
    veh_tax: string | null
    veh_version: number | null
  }

  export type Ep_vehiclesCountAggregateOutputType = {
    veh_id: number
    veh_plate: number
    veh_reference: number
    veh_status: number
    veh_owner: number
    veh_color: number
    veh_ingress_date: number
    veh_egress_date: number
    veh_tax: number
    veh_version: number
    _all: number
  }


  export type Ep_vehiclesAvgAggregateInputType = {
    veh_id?: true
    veh_version?: true
  }

  export type Ep_vehiclesSumAggregateInputType = {
    veh_id?: true
    veh_version?: true
  }

  export type Ep_vehiclesMinAggregateInputType = {
    veh_id?: true
    veh_plate?: true
    veh_reference?: true
    veh_status?: true
    veh_owner?: true
    veh_color?: true
    veh_ingress_date?: true
    veh_egress_date?: true
    veh_tax?: true
    veh_version?: true
  }

  export type Ep_vehiclesMaxAggregateInputType = {
    veh_id?: true
    veh_plate?: true
    veh_reference?: true
    veh_status?: true
    veh_owner?: true
    veh_color?: true
    veh_ingress_date?: true
    veh_egress_date?: true
    veh_tax?: true
    veh_version?: true
  }

  export type Ep_vehiclesCountAggregateInputType = {
    veh_id?: true
    veh_plate?: true
    veh_reference?: true
    veh_status?: true
    veh_owner?: true
    veh_color?: true
    veh_ingress_date?: true
    veh_egress_date?: true
    veh_tax?: true
    veh_version?: true
    _all?: true
  }

  export type Ep_vehiclesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ep_vehicles to aggregate.
     */
    where?: ep_vehiclesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ep_vehicles to fetch.
     */
    orderBy?: ep_vehiclesOrderByWithRelationInput | ep_vehiclesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ep_vehiclesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ep_vehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ep_vehicles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ep_vehicles
    **/
    _count?: true | Ep_vehiclesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Ep_vehiclesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Ep_vehiclesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Ep_vehiclesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Ep_vehiclesMaxAggregateInputType
  }

  export type GetEp_vehiclesAggregateType<T extends Ep_vehiclesAggregateArgs> = {
        [P in keyof T & keyof AggregateEp_vehicles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEp_vehicles[P]>
      : GetScalarType<T[P], AggregateEp_vehicles[P]>
  }




  export type ep_vehiclesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ep_vehiclesWhereInput
    orderBy?: ep_vehiclesOrderByWithAggregationInput | ep_vehiclesOrderByWithAggregationInput[]
    by: Ep_vehiclesScalarFieldEnum[] | Ep_vehiclesScalarFieldEnum
    having?: ep_vehiclesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Ep_vehiclesCountAggregateInputType | true
    _avg?: Ep_vehiclesAvgAggregateInputType
    _sum?: Ep_vehiclesSumAggregateInputType
    _min?: Ep_vehiclesMinAggregateInputType
    _max?: Ep_vehiclesMaxAggregateInputType
  }

  export type Ep_vehiclesGroupByOutputType = {
    veh_id: number
    veh_plate: string
    veh_reference: string
    veh_status: string | null
    veh_owner: string
    veh_color: string | null
    veh_ingress_date: Date
    veh_egress_date: Date | null
    veh_tax: string
    veh_version: number
    _count: Ep_vehiclesCountAggregateOutputType | null
    _avg: Ep_vehiclesAvgAggregateOutputType | null
    _sum: Ep_vehiclesSumAggregateOutputType | null
    _min: Ep_vehiclesMinAggregateOutputType | null
    _max: Ep_vehiclesMaxAggregateOutputType | null
  }

  type GetEp_vehiclesGroupByPayload<T extends ep_vehiclesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Ep_vehiclesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Ep_vehiclesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Ep_vehiclesGroupByOutputType[P]>
            : GetScalarType<T[P], Ep_vehiclesGroupByOutputType[P]>
        }
      >
    >


  export type ep_vehiclesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    veh_id?: boolean
    veh_plate?: boolean
    veh_reference?: boolean
    veh_status?: boolean
    veh_owner?: boolean
    veh_color?: boolean
    veh_ingress_date?: boolean
    veh_egress_date?: boolean
    veh_tax?: boolean
    veh_version?: boolean
  }, ExtArgs["result"]["ep_vehicles"]>

  export type ep_vehiclesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    veh_id?: boolean
    veh_plate?: boolean
    veh_reference?: boolean
    veh_status?: boolean
    veh_owner?: boolean
    veh_color?: boolean
    veh_ingress_date?: boolean
    veh_egress_date?: boolean
    veh_tax?: boolean
    veh_version?: boolean
  }, ExtArgs["result"]["ep_vehicles"]>

  export type ep_vehiclesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    veh_id?: boolean
    veh_plate?: boolean
    veh_reference?: boolean
    veh_status?: boolean
    veh_owner?: boolean
    veh_color?: boolean
    veh_ingress_date?: boolean
    veh_egress_date?: boolean
    veh_tax?: boolean
    veh_version?: boolean
  }, ExtArgs["result"]["ep_vehicles"]>

  export type ep_vehiclesSelectScalar = {
    veh_id?: boolean
    veh_plate?: boolean
    veh_reference?: boolean
    veh_status?: boolean
    veh_owner?: boolean
    veh_color?: boolean
    veh_ingress_date?: boolean
    veh_egress_date?: boolean
    veh_tax?: boolean
    veh_version?: boolean
  }

  export type ep_vehiclesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"veh_id" | "veh_plate" | "veh_reference" | "veh_status" | "veh_owner" | "veh_color" | "veh_ingress_date" | "veh_egress_date" | "veh_tax" | "veh_version", ExtArgs["result"]["ep_vehicles"]>

  export type $ep_vehiclesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ep_vehicles"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      veh_id: number
      veh_plate: string
      veh_reference: string
      veh_status: string | null
      veh_owner: string
      veh_color: string | null
      veh_ingress_date: Date
      veh_egress_date: Date | null
      veh_tax: string
      veh_version: number
    }, ExtArgs["result"]["ep_vehicles"]>
    composites: {}
  }

  type ep_vehiclesGetPayload<S extends boolean | null | undefined | ep_vehiclesDefaultArgs> = $Result.GetResult<Prisma.$ep_vehiclesPayload, S>

  type ep_vehiclesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ep_vehiclesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Ep_vehiclesCountAggregateInputType | true
    }

  export interface ep_vehiclesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ep_vehicles'], meta: { name: 'ep_vehicles' } }
    /**
     * Find zero or one Ep_vehicles that matches the filter.
     * @param {ep_vehiclesFindUniqueArgs} args - Arguments to find a Ep_vehicles
     * @example
     * // Get one Ep_vehicles
     * const ep_vehicles = await prisma.ep_vehicles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ep_vehiclesFindUniqueArgs>(args: SelectSubset<T, ep_vehiclesFindUniqueArgs<ExtArgs>>): Prisma__ep_vehiclesClient<$Result.GetResult<Prisma.$ep_vehiclesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ep_vehicles that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ep_vehiclesFindUniqueOrThrowArgs} args - Arguments to find a Ep_vehicles
     * @example
     * // Get one Ep_vehicles
     * const ep_vehicles = await prisma.ep_vehicles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ep_vehiclesFindUniqueOrThrowArgs>(args: SelectSubset<T, ep_vehiclesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ep_vehiclesClient<$Result.GetResult<Prisma.$ep_vehiclesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ep_vehicles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ep_vehiclesFindFirstArgs} args - Arguments to find a Ep_vehicles
     * @example
     * // Get one Ep_vehicles
     * const ep_vehicles = await prisma.ep_vehicles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ep_vehiclesFindFirstArgs>(args?: SelectSubset<T, ep_vehiclesFindFirstArgs<ExtArgs>>): Prisma__ep_vehiclesClient<$Result.GetResult<Prisma.$ep_vehiclesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ep_vehicles that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ep_vehiclesFindFirstOrThrowArgs} args - Arguments to find a Ep_vehicles
     * @example
     * // Get one Ep_vehicles
     * const ep_vehicles = await prisma.ep_vehicles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ep_vehiclesFindFirstOrThrowArgs>(args?: SelectSubset<T, ep_vehiclesFindFirstOrThrowArgs<ExtArgs>>): Prisma__ep_vehiclesClient<$Result.GetResult<Prisma.$ep_vehiclesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ep_vehicles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ep_vehiclesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ep_vehicles
     * const ep_vehicles = await prisma.ep_vehicles.findMany()
     * 
     * // Get first 10 Ep_vehicles
     * const ep_vehicles = await prisma.ep_vehicles.findMany({ take: 10 })
     * 
     * // Only select the `veh_id`
     * const ep_vehiclesWithVeh_idOnly = await prisma.ep_vehicles.findMany({ select: { veh_id: true } })
     * 
     */
    findMany<T extends ep_vehiclesFindManyArgs>(args?: SelectSubset<T, ep_vehiclesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ep_vehiclesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ep_vehicles.
     * @param {ep_vehiclesCreateArgs} args - Arguments to create a Ep_vehicles.
     * @example
     * // Create one Ep_vehicles
     * const Ep_vehicles = await prisma.ep_vehicles.create({
     *   data: {
     *     // ... data to create a Ep_vehicles
     *   }
     * })
     * 
     */
    create<T extends ep_vehiclesCreateArgs>(args: SelectSubset<T, ep_vehiclesCreateArgs<ExtArgs>>): Prisma__ep_vehiclesClient<$Result.GetResult<Prisma.$ep_vehiclesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ep_vehicles.
     * @param {ep_vehiclesCreateManyArgs} args - Arguments to create many Ep_vehicles.
     * @example
     * // Create many Ep_vehicles
     * const ep_vehicles = await prisma.ep_vehicles.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ep_vehiclesCreateManyArgs>(args?: SelectSubset<T, ep_vehiclesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ep_vehicles and returns the data saved in the database.
     * @param {ep_vehiclesCreateManyAndReturnArgs} args - Arguments to create many Ep_vehicles.
     * @example
     * // Create many Ep_vehicles
     * const ep_vehicles = await prisma.ep_vehicles.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ep_vehicles and only return the `veh_id`
     * const ep_vehiclesWithVeh_idOnly = await prisma.ep_vehicles.createManyAndReturn({
     *   select: { veh_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ep_vehiclesCreateManyAndReturnArgs>(args?: SelectSubset<T, ep_vehiclesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ep_vehiclesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Ep_vehicles.
     * @param {ep_vehiclesDeleteArgs} args - Arguments to delete one Ep_vehicles.
     * @example
     * // Delete one Ep_vehicles
     * const Ep_vehicles = await prisma.ep_vehicles.delete({
     *   where: {
     *     // ... filter to delete one Ep_vehicles
     *   }
     * })
     * 
     */
    delete<T extends ep_vehiclesDeleteArgs>(args: SelectSubset<T, ep_vehiclesDeleteArgs<ExtArgs>>): Prisma__ep_vehiclesClient<$Result.GetResult<Prisma.$ep_vehiclesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ep_vehicles.
     * @param {ep_vehiclesUpdateArgs} args - Arguments to update one Ep_vehicles.
     * @example
     * // Update one Ep_vehicles
     * const ep_vehicles = await prisma.ep_vehicles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ep_vehiclesUpdateArgs>(args: SelectSubset<T, ep_vehiclesUpdateArgs<ExtArgs>>): Prisma__ep_vehiclesClient<$Result.GetResult<Prisma.$ep_vehiclesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ep_vehicles.
     * @param {ep_vehiclesDeleteManyArgs} args - Arguments to filter Ep_vehicles to delete.
     * @example
     * // Delete a few Ep_vehicles
     * const { count } = await prisma.ep_vehicles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ep_vehiclesDeleteManyArgs>(args?: SelectSubset<T, ep_vehiclesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ep_vehicles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ep_vehiclesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ep_vehicles
     * const ep_vehicles = await prisma.ep_vehicles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ep_vehiclesUpdateManyArgs>(args: SelectSubset<T, ep_vehiclesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ep_vehicles and returns the data updated in the database.
     * @param {ep_vehiclesUpdateManyAndReturnArgs} args - Arguments to update many Ep_vehicles.
     * @example
     * // Update many Ep_vehicles
     * const ep_vehicles = await prisma.ep_vehicles.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Ep_vehicles and only return the `veh_id`
     * const ep_vehiclesWithVeh_idOnly = await prisma.ep_vehicles.updateManyAndReturn({
     *   select: { veh_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ep_vehiclesUpdateManyAndReturnArgs>(args: SelectSubset<T, ep_vehiclesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ep_vehiclesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Ep_vehicles.
     * @param {ep_vehiclesUpsertArgs} args - Arguments to update or create a Ep_vehicles.
     * @example
     * // Update or create a Ep_vehicles
     * const ep_vehicles = await prisma.ep_vehicles.upsert({
     *   create: {
     *     // ... data to create a Ep_vehicles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ep_vehicles we want to update
     *   }
     * })
     */
    upsert<T extends ep_vehiclesUpsertArgs>(args: SelectSubset<T, ep_vehiclesUpsertArgs<ExtArgs>>): Prisma__ep_vehiclesClient<$Result.GetResult<Prisma.$ep_vehiclesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ep_vehicles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ep_vehiclesCountArgs} args - Arguments to filter Ep_vehicles to count.
     * @example
     * // Count the number of Ep_vehicles
     * const count = await prisma.ep_vehicles.count({
     *   where: {
     *     // ... the filter for the Ep_vehicles we want to count
     *   }
     * })
    **/
    count<T extends ep_vehiclesCountArgs>(
      args?: Subset<T, ep_vehiclesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Ep_vehiclesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ep_vehicles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ep_vehiclesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Ep_vehiclesAggregateArgs>(args: Subset<T, Ep_vehiclesAggregateArgs>): Prisma.PrismaPromise<GetEp_vehiclesAggregateType<T>>

    /**
     * Group by Ep_vehicles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ep_vehiclesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ep_vehiclesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ep_vehiclesGroupByArgs['orderBy'] }
        : { orderBy?: ep_vehiclesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ep_vehiclesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEp_vehiclesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ep_vehicles model
   */
  readonly fields: ep_vehiclesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ep_vehicles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ep_vehiclesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ep_vehicles model
   */ 
  interface ep_vehiclesFieldRefs {
    readonly veh_id: FieldRef<"ep_vehicles", 'Int'>
    readonly veh_plate: FieldRef<"ep_vehicles", 'String'>
    readonly veh_reference: FieldRef<"ep_vehicles", 'String'>
    readonly veh_status: FieldRef<"ep_vehicles", 'String'>
    readonly veh_owner: FieldRef<"ep_vehicles", 'String'>
    readonly veh_color: FieldRef<"ep_vehicles", 'String'>
    readonly veh_ingress_date: FieldRef<"ep_vehicles", 'DateTime'>
    readonly veh_egress_date: FieldRef<"ep_vehicles", 'DateTime'>
    readonly veh_tax: FieldRef<"ep_vehicles", 'String'>
    readonly veh_version: FieldRef<"ep_vehicles", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ep_vehicles findUnique
   */
  export type ep_vehiclesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_vehicles
     */
    select?: ep_vehiclesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_vehicles
     */
    omit?: ep_vehiclesOmit<ExtArgs> | null
    /**
     * Filter, which ep_vehicles to fetch.
     */
    where: ep_vehiclesWhereUniqueInput
  }

  /**
   * ep_vehicles findUniqueOrThrow
   */
  export type ep_vehiclesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_vehicles
     */
    select?: ep_vehiclesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_vehicles
     */
    omit?: ep_vehiclesOmit<ExtArgs> | null
    /**
     * Filter, which ep_vehicles to fetch.
     */
    where: ep_vehiclesWhereUniqueInput
  }

  /**
   * ep_vehicles findFirst
   */
  export type ep_vehiclesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_vehicles
     */
    select?: ep_vehiclesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_vehicles
     */
    omit?: ep_vehiclesOmit<ExtArgs> | null
    /**
     * Filter, which ep_vehicles to fetch.
     */
    where?: ep_vehiclesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ep_vehicles to fetch.
     */
    orderBy?: ep_vehiclesOrderByWithRelationInput | ep_vehiclesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ep_vehicles.
     */
    cursor?: ep_vehiclesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ep_vehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ep_vehicles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ep_vehicles.
     */
    distinct?: Ep_vehiclesScalarFieldEnum | Ep_vehiclesScalarFieldEnum[]
  }

  /**
   * ep_vehicles findFirstOrThrow
   */
  export type ep_vehiclesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_vehicles
     */
    select?: ep_vehiclesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_vehicles
     */
    omit?: ep_vehiclesOmit<ExtArgs> | null
    /**
     * Filter, which ep_vehicles to fetch.
     */
    where?: ep_vehiclesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ep_vehicles to fetch.
     */
    orderBy?: ep_vehiclesOrderByWithRelationInput | ep_vehiclesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ep_vehicles.
     */
    cursor?: ep_vehiclesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ep_vehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ep_vehicles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ep_vehicles.
     */
    distinct?: Ep_vehiclesScalarFieldEnum | Ep_vehiclesScalarFieldEnum[]
  }

  /**
   * ep_vehicles findMany
   */
  export type ep_vehiclesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_vehicles
     */
    select?: ep_vehiclesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_vehicles
     */
    omit?: ep_vehiclesOmit<ExtArgs> | null
    /**
     * Filter, which ep_vehicles to fetch.
     */
    where?: ep_vehiclesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ep_vehicles to fetch.
     */
    orderBy?: ep_vehiclesOrderByWithRelationInput | ep_vehiclesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ep_vehicles.
     */
    cursor?: ep_vehiclesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ep_vehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ep_vehicles.
     */
    skip?: number
    distinct?: Ep_vehiclesScalarFieldEnum | Ep_vehiclesScalarFieldEnum[]
  }

  /**
   * ep_vehicles create
   */
  export type ep_vehiclesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_vehicles
     */
    select?: ep_vehiclesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_vehicles
     */
    omit?: ep_vehiclesOmit<ExtArgs> | null
    /**
     * The data needed to create a ep_vehicles.
     */
    data: XOR<ep_vehiclesCreateInput, ep_vehiclesUncheckedCreateInput>
  }

  /**
   * ep_vehicles createMany
   */
  export type ep_vehiclesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ep_vehicles.
     */
    data: ep_vehiclesCreateManyInput | ep_vehiclesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ep_vehicles createManyAndReturn
   */
  export type ep_vehiclesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_vehicles
     */
    select?: ep_vehiclesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ep_vehicles
     */
    omit?: ep_vehiclesOmit<ExtArgs> | null
    /**
     * The data used to create many ep_vehicles.
     */
    data: ep_vehiclesCreateManyInput | ep_vehiclesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ep_vehicles update
   */
  export type ep_vehiclesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_vehicles
     */
    select?: ep_vehiclesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_vehicles
     */
    omit?: ep_vehiclesOmit<ExtArgs> | null
    /**
     * The data needed to update a ep_vehicles.
     */
    data: XOR<ep_vehiclesUpdateInput, ep_vehiclesUncheckedUpdateInput>
    /**
     * Choose, which ep_vehicles to update.
     */
    where: ep_vehiclesWhereUniqueInput
  }

  /**
   * ep_vehicles updateMany
   */
  export type ep_vehiclesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ep_vehicles.
     */
    data: XOR<ep_vehiclesUpdateManyMutationInput, ep_vehiclesUncheckedUpdateManyInput>
    /**
     * Filter which ep_vehicles to update
     */
    where?: ep_vehiclesWhereInput
    /**
     * Limit how many ep_vehicles to update.
     */
    limit?: number
  }

  /**
   * ep_vehicles updateManyAndReturn
   */
  export type ep_vehiclesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_vehicles
     */
    select?: ep_vehiclesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ep_vehicles
     */
    omit?: ep_vehiclesOmit<ExtArgs> | null
    /**
     * The data used to update ep_vehicles.
     */
    data: XOR<ep_vehiclesUpdateManyMutationInput, ep_vehiclesUncheckedUpdateManyInput>
    /**
     * Filter which ep_vehicles to update
     */
    where?: ep_vehiclesWhereInput
    /**
     * Limit how many ep_vehicles to update.
     */
    limit?: number
  }

  /**
   * ep_vehicles upsert
   */
  export type ep_vehiclesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_vehicles
     */
    select?: ep_vehiclesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_vehicles
     */
    omit?: ep_vehiclesOmit<ExtArgs> | null
    /**
     * The filter to search for the ep_vehicles to update in case it exists.
     */
    where: ep_vehiclesWhereUniqueInput
    /**
     * In case the ep_vehicles found by the `where` argument doesn't exist, create a new ep_vehicles with this data.
     */
    create: XOR<ep_vehiclesCreateInput, ep_vehiclesUncheckedCreateInput>
    /**
     * In case the ep_vehicles was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ep_vehiclesUpdateInput, ep_vehiclesUncheckedUpdateInput>
  }

  /**
   * ep_vehicles delete
   */
  export type ep_vehiclesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_vehicles
     */
    select?: ep_vehiclesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_vehicles
     */
    omit?: ep_vehiclesOmit<ExtArgs> | null
    /**
     * Filter which ep_vehicles to delete.
     */
    where: ep_vehiclesWhereUniqueInput
  }

  /**
   * ep_vehicles deleteMany
   */
  export type ep_vehiclesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ep_vehicles to delete
     */
    where?: ep_vehiclesWhereInput
    /**
     * Limit how many ep_vehicles to delete.
     */
    limit?: number
  }

  /**
   * ep_vehicles without action
   */
  export type ep_vehiclesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_vehicles
     */
    select?: ep_vehiclesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_vehicles
     */
    omit?: ep_vehiclesOmit<ExtArgs> | null
  }


  /**
   * Model ep_cash_per_day
   */

  export type AggregateEp_cash_per_day = {
    _count: Ep_cash_per_dayCountAggregateOutputType | null
    _avg: Ep_cash_per_dayAvgAggregateOutputType | null
    _sum: Ep_cash_per_daySumAggregateOutputType | null
    _min: Ep_cash_per_dayMinAggregateOutputType | null
    _max: Ep_cash_per_dayMaxAggregateOutputType | null
  }

  export type Ep_cash_per_dayAvgAggregateOutputType = {
    cpd_id: number | null
    cpd_amount: Decimal | null
    cpd_user_id: number | null
    cpd_version: number | null
  }

  export type Ep_cash_per_daySumAggregateOutputType = {
    cpd_id: number | null
    cpd_amount: Decimal | null
    cpd_user_id: number | null
    cpd_version: number | null
  }

  export type Ep_cash_per_dayMinAggregateOutputType = {
    cpd_id: number | null
    cpd_amount: Decimal | null
    cpd_user_id: number | null
    cpd_date: Date | null
    cpd_version: number | null
  }

  export type Ep_cash_per_dayMaxAggregateOutputType = {
    cpd_id: number | null
    cpd_amount: Decimal | null
    cpd_user_id: number | null
    cpd_date: Date | null
    cpd_version: number | null
  }

  export type Ep_cash_per_dayCountAggregateOutputType = {
    cpd_id: number
    cpd_amount: number
    cpd_user_id: number
    cpd_date: number
    cpd_version: number
    _all: number
  }


  export type Ep_cash_per_dayAvgAggregateInputType = {
    cpd_id?: true
    cpd_amount?: true
    cpd_user_id?: true
    cpd_version?: true
  }

  export type Ep_cash_per_daySumAggregateInputType = {
    cpd_id?: true
    cpd_amount?: true
    cpd_user_id?: true
    cpd_version?: true
  }

  export type Ep_cash_per_dayMinAggregateInputType = {
    cpd_id?: true
    cpd_amount?: true
    cpd_user_id?: true
    cpd_date?: true
    cpd_version?: true
  }

  export type Ep_cash_per_dayMaxAggregateInputType = {
    cpd_id?: true
    cpd_amount?: true
    cpd_user_id?: true
    cpd_date?: true
    cpd_version?: true
  }

  export type Ep_cash_per_dayCountAggregateInputType = {
    cpd_id?: true
    cpd_amount?: true
    cpd_user_id?: true
    cpd_date?: true
    cpd_version?: true
    _all?: true
  }

  export type Ep_cash_per_dayAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ep_cash_per_day to aggregate.
     */
    where?: ep_cash_per_dayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ep_cash_per_days to fetch.
     */
    orderBy?: ep_cash_per_dayOrderByWithRelationInput | ep_cash_per_dayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ep_cash_per_dayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ep_cash_per_days from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ep_cash_per_days.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ep_cash_per_days
    **/
    _count?: true | Ep_cash_per_dayCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Ep_cash_per_dayAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Ep_cash_per_daySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Ep_cash_per_dayMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Ep_cash_per_dayMaxAggregateInputType
  }

  export type GetEp_cash_per_dayAggregateType<T extends Ep_cash_per_dayAggregateArgs> = {
        [P in keyof T & keyof AggregateEp_cash_per_day]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEp_cash_per_day[P]>
      : GetScalarType<T[P], AggregateEp_cash_per_day[P]>
  }




  export type ep_cash_per_dayGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ep_cash_per_dayWhereInput
    orderBy?: ep_cash_per_dayOrderByWithAggregationInput | ep_cash_per_dayOrderByWithAggregationInput[]
    by: Ep_cash_per_dayScalarFieldEnum[] | Ep_cash_per_dayScalarFieldEnum
    having?: ep_cash_per_dayScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Ep_cash_per_dayCountAggregateInputType | true
    _avg?: Ep_cash_per_dayAvgAggregateInputType
    _sum?: Ep_cash_per_daySumAggregateInputType
    _min?: Ep_cash_per_dayMinAggregateInputType
    _max?: Ep_cash_per_dayMaxAggregateInputType
  }

  export type Ep_cash_per_dayGroupByOutputType = {
    cpd_id: number
    cpd_amount: Decimal
    cpd_user_id: number
    cpd_date: Date
    cpd_version: number
    _count: Ep_cash_per_dayCountAggregateOutputType | null
    _avg: Ep_cash_per_dayAvgAggregateOutputType | null
    _sum: Ep_cash_per_daySumAggregateOutputType | null
    _min: Ep_cash_per_dayMinAggregateOutputType | null
    _max: Ep_cash_per_dayMaxAggregateOutputType | null
  }

  type GetEp_cash_per_dayGroupByPayload<T extends ep_cash_per_dayGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Ep_cash_per_dayGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Ep_cash_per_dayGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Ep_cash_per_dayGroupByOutputType[P]>
            : GetScalarType<T[P], Ep_cash_per_dayGroupByOutputType[P]>
        }
      >
    >


  export type ep_cash_per_daySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cpd_id?: boolean
    cpd_amount?: boolean
    cpd_user_id?: boolean
    cpd_date?: boolean
    cpd_version?: boolean
    ep_users?: boolean | ep_usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ep_cash_per_day"]>

  export type ep_cash_per_daySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cpd_id?: boolean
    cpd_amount?: boolean
    cpd_user_id?: boolean
    cpd_date?: boolean
    cpd_version?: boolean
    ep_users?: boolean | ep_usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ep_cash_per_day"]>

  export type ep_cash_per_daySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cpd_id?: boolean
    cpd_amount?: boolean
    cpd_user_id?: boolean
    cpd_date?: boolean
    cpd_version?: boolean
    ep_users?: boolean | ep_usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ep_cash_per_day"]>

  export type ep_cash_per_daySelectScalar = {
    cpd_id?: boolean
    cpd_amount?: boolean
    cpd_user_id?: boolean
    cpd_date?: boolean
    cpd_version?: boolean
  }

  export type ep_cash_per_dayOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"cpd_id" | "cpd_amount" | "cpd_user_id" | "cpd_date" | "cpd_version", ExtArgs["result"]["ep_cash_per_day"]>
  export type ep_cash_per_dayInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ep_users?: boolean | ep_usersDefaultArgs<ExtArgs>
  }
  export type ep_cash_per_dayIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ep_users?: boolean | ep_usersDefaultArgs<ExtArgs>
  }
  export type ep_cash_per_dayIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ep_users?: boolean | ep_usersDefaultArgs<ExtArgs>
  }

  export type $ep_cash_per_dayPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ep_cash_per_day"
    objects: {
      ep_users: Prisma.$ep_usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      cpd_id: number
      cpd_amount: Prisma.Decimal
      cpd_user_id: number
      cpd_date: Date
      cpd_version: number
    }, ExtArgs["result"]["ep_cash_per_day"]>
    composites: {}
  }

  type ep_cash_per_dayGetPayload<S extends boolean | null | undefined | ep_cash_per_dayDefaultArgs> = $Result.GetResult<Prisma.$ep_cash_per_dayPayload, S>

  type ep_cash_per_dayCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ep_cash_per_dayFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Ep_cash_per_dayCountAggregateInputType | true
    }

  export interface ep_cash_per_dayDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ep_cash_per_day'], meta: { name: 'ep_cash_per_day' } }
    /**
     * Find zero or one Ep_cash_per_day that matches the filter.
     * @param {ep_cash_per_dayFindUniqueArgs} args - Arguments to find a Ep_cash_per_day
     * @example
     * // Get one Ep_cash_per_day
     * const ep_cash_per_day = await prisma.ep_cash_per_day.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ep_cash_per_dayFindUniqueArgs>(args: SelectSubset<T, ep_cash_per_dayFindUniqueArgs<ExtArgs>>): Prisma__ep_cash_per_dayClient<$Result.GetResult<Prisma.$ep_cash_per_dayPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ep_cash_per_day that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ep_cash_per_dayFindUniqueOrThrowArgs} args - Arguments to find a Ep_cash_per_day
     * @example
     * // Get one Ep_cash_per_day
     * const ep_cash_per_day = await prisma.ep_cash_per_day.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ep_cash_per_dayFindUniqueOrThrowArgs>(args: SelectSubset<T, ep_cash_per_dayFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ep_cash_per_dayClient<$Result.GetResult<Prisma.$ep_cash_per_dayPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ep_cash_per_day that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ep_cash_per_dayFindFirstArgs} args - Arguments to find a Ep_cash_per_day
     * @example
     * // Get one Ep_cash_per_day
     * const ep_cash_per_day = await prisma.ep_cash_per_day.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ep_cash_per_dayFindFirstArgs>(args?: SelectSubset<T, ep_cash_per_dayFindFirstArgs<ExtArgs>>): Prisma__ep_cash_per_dayClient<$Result.GetResult<Prisma.$ep_cash_per_dayPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ep_cash_per_day that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ep_cash_per_dayFindFirstOrThrowArgs} args - Arguments to find a Ep_cash_per_day
     * @example
     * // Get one Ep_cash_per_day
     * const ep_cash_per_day = await prisma.ep_cash_per_day.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ep_cash_per_dayFindFirstOrThrowArgs>(args?: SelectSubset<T, ep_cash_per_dayFindFirstOrThrowArgs<ExtArgs>>): Prisma__ep_cash_per_dayClient<$Result.GetResult<Prisma.$ep_cash_per_dayPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ep_cash_per_days that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ep_cash_per_dayFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ep_cash_per_days
     * const ep_cash_per_days = await prisma.ep_cash_per_day.findMany()
     * 
     * // Get first 10 Ep_cash_per_days
     * const ep_cash_per_days = await prisma.ep_cash_per_day.findMany({ take: 10 })
     * 
     * // Only select the `cpd_id`
     * const ep_cash_per_dayWithCpd_idOnly = await prisma.ep_cash_per_day.findMany({ select: { cpd_id: true } })
     * 
     */
    findMany<T extends ep_cash_per_dayFindManyArgs>(args?: SelectSubset<T, ep_cash_per_dayFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ep_cash_per_dayPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ep_cash_per_day.
     * @param {ep_cash_per_dayCreateArgs} args - Arguments to create a Ep_cash_per_day.
     * @example
     * // Create one Ep_cash_per_day
     * const Ep_cash_per_day = await prisma.ep_cash_per_day.create({
     *   data: {
     *     // ... data to create a Ep_cash_per_day
     *   }
     * })
     * 
     */
    create<T extends ep_cash_per_dayCreateArgs>(args: SelectSubset<T, ep_cash_per_dayCreateArgs<ExtArgs>>): Prisma__ep_cash_per_dayClient<$Result.GetResult<Prisma.$ep_cash_per_dayPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ep_cash_per_days.
     * @param {ep_cash_per_dayCreateManyArgs} args - Arguments to create many Ep_cash_per_days.
     * @example
     * // Create many Ep_cash_per_days
     * const ep_cash_per_day = await prisma.ep_cash_per_day.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ep_cash_per_dayCreateManyArgs>(args?: SelectSubset<T, ep_cash_per_dayCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ep_cash_per_days and returns the data saved in the database.
     * @param {ep_cash_per_dayCreateManyAndReturnArgs} args - Arguments to create many Ep_cash_per_days.
     * @example
     * // Create many Ep_cash_per_days
     * const ep_cash_per_day = await prisma.ep_cash_per_day.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ep_cash_per_days and only return the `cpd_id`
     * const ep_cash_per_dayWithCpd_idOnly = await prisma.ep_cash_per_day.createManyAndReturn({
     *   select: { cpd_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ep_cash_per_dayCreateManyAndReturnArgs>(args?: SelectSubset<T, ep_cash_per_dayCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ep_cash_per_dayPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Ep_cash_per_day.
     * @param {ep_cash_per_dayDeleteArgs} args - Arguments to delete one Ep_cash_per_day.
     * @example
     * // Delete one Ep_cash_per_day
     * const Ep_cash_per_day = await prisma.ep_cash_per_day.delete({
     *   where: {
     *     // ... filter to delete one Ep_cash_per_day
     *   }
     * })
     * 
     */
    delete<T extends ep_cash_per_dayDeleteArgs>(args: SelectSubset<T, ep_cash_per_dayDeleteArgs<ExtArgs>>): Prisma__ep_cash_per_dayClient<$Result.GetResult<Prisma.$ep_cash_per_dayPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ep_cash_per_day.
     * @param {ep_cash_per_dayUpdateArgs} args - Arguments to update one Ep_cash_per_day.
     * @example
     * // Update one Ep_cash_per_day
     * const ep_cash_per_day = await prisma.ep_cash_per_day.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ep_cash_per_dayUpdateArgs>(args: SelectSubset<T, ep_cash_per_dayUpdateArgs<ExtArgs>>): Prisma__ep_cash_per_dayClient<$Result.GetResult<Prisma.$ep_cash_per_dayPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ep_cash_per_days.
     * @param {ep_cash_per_dayDeleteManyArgs} args - Arguments to filter Ep_cash_per_days to delete.
     * @example
     * // Delete a few Ep_cash_per_days
     * const { count } = await prisma.ep_cash_per_day.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ep_cash_per_dayDeleteManyArgs>(args?: SelectSubset<T, ep_cash_per_dayDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ep_cash_per_days.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ep_cash_per_dayUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ep_cash_per_days
     * const ep_cash_per_day = await prisma.ep_cash_per_day.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ep_cash_per_dayUpdateManyArgs>(args: SelectSubset<T, ep_cash_per_dayUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ep_cash_per_days and returns the data updated in the database.
     * @param {ep_cash_per_dayUpdateManyAndReturnArgs} args - Arguments to update many Ep_cash_per_days.
     * @example
     * // Update many Ep_cash_per_days
     * const ep_cash_per_day = await prisma.ep_cash_per_day.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Ep_cash_per_days and only return the `cpd_id`
     * const ep_cash_per_dayWithCpd_idOnly = await prisma.ep_cash_per_day.updateManyAndReturn({
     *   select: { cpd_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ep_cash_per_dayUpdateManyAndReturnArgs>(args: SelectSubset<T, ep_cash_per_dayUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ep_cash_per_dayPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Ep_cash_per_day.
     * @param {ep_cash_per_dayUpsertArgs} args - Arguments to update or create a Ep_cash_per_day.
     * @example
     * // Update or create a Ep_cash_per_day
     * const ep_cash_per_day = await prisma.ep_cash_per_day.upsert({
     *   create: {
     *     // ... data to create a Ep_cash_per_day
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ep_cash_per_day we want to update
     *   }
     * })
     */
    upsert<T extends ep_cash_per_dayUpsertArgs>(args: SelectSubset<T, ep_cash_per_dayUpsertArgs<ExtArgs>>): Prisma__ep_cash_per_dayClient<$Result.GetResult<Prisma.$ep_cash_per_dayPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ep_cash_per_days.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ep_cash_per_dayCountArgs} args - Arguments to filter Ep_cash_per_days to count.
     * @example
     * // Count the number of Ep_cash_per_days
     * const count = await prisma.ep_cash_per_day.count({
     *   where: {
     *     // ... the filter for the Ep_cash_per_days we want to count
     *   }
     * })
    **/
    count<T extends ep_cash_per_dayCountArgs>(
      args?: Subset<T, ep_cash_per_dayCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Ep_cash_per_dayCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ep_cash_per_day.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ep_cash_per_dayAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Ep_cash_per_dayAggregateArgs>(args: Subset<T, Ep_cash_per_dayAggregateArgs>): Prisma.PrismaPromise<GetEp_cash_per_dayAggregateType<T>>

    /**
     * Group by Ep_cash_per_day.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ep_cash_per_dayGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ep_cash_per_dayGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ep_cash_per_dayGroupByArgs['orderBy'] }
        : { orderBy?: ep_cash_per_dayGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ep_cash_per_dayGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEp_cash_per_dayGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ep_cash_per_day model
   */
  readonly fields: ep_cash_per_dayFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ep_cash_per_day.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ep_cash_per_dayClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ep_users<T extends ep_usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ep_usersDefaultArgs<ExtArgs>>): Prisma__ep_usersClient<$Result.GetResult<Prisma.$ep_usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ep_cash_per_day model
   */ 
  interface ep_cash_per_dayFieldRefs {
    readonly cpd_id: FieldRef<"ep_cash_per_day", 'Int'>
    readonly cpd_amount: FieldRef<"ep_cash_per_day", 'Decimal'>
    readonly cpd_user_id: FieldRef<"ep_cash_per_day", 'Int'>
    readonly cpd_date: FieldRef<"ep_cash_per_day", 'DateTime'>
    readonly cpd_version: FieldRef<"ep_cash_per_day", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ep_cash_per_day findUnique
   */
  export type ep_cash_per_dayFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_cash_per_day
     */
    select?: ep_cash_per_daySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_cash_per_day
     */
    omit?: ep_cash_per_dayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ep_cash_per_dayInclude<ExtArgs> | null
    /**
     * Filter, which ep_cash_per_day to fetch.
     */
    where: ep_cash_per_dayWhereUniqueInput
  }

  /**
   * ep_cash_per_day findUniqueOrThrow
   */
  export type ep_cash_per_dayFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_cash_per_day
     */
    select?: ep_cash_per_daySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_cash_per_day
     */
    omit?: ep_cash_per_dayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ep_cash_per_dayInclude<ExtArgs> | null
    /**
     * Filter, which ep_cash_per_day to fetch.
     */
    where: ep_cash_per_dayWhereUniqueInput
  }

  /**
   * ep_cash_per_day findFirst
   */
  export type ep_cash_per_dayFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_cash_per_day
     */
    select?: ep_cash_per_daySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_cash_per_day
     */
    omit?: ep_cash_per_dayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ep_cash_per_dayInclude<ExtArgs> | null
    /**
     * Filter, which ep_cash_per_day to fetch.
     */
    where?: ep_cash_per_dayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ep_cash_per_days to fetch.
     */
    orderBy?: ep_cash_per_dayOrderByWithRelationInput | ep_cash_per_dayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ep_cash_per_days.
     */
    cursor?: ep_cash_per_dayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ep_cash_per_days from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ep_cash_per_days.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ep_cash_per_days.
     */
    distinct?: Ep_cash_per_dayScalarFieldEnum | Ep_cash_per_dayScalarFieldEnum[]
  }

  /**
   * ep_cash_per_day findFirstOrThrow
   */
  export type ep_cash_per_dayFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_cash_per_day
     */
    select?: ep_cash_per_daySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_cash_per_day
     */
    omit?: ep_cash_per_dayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ep_cash_per_dayInclude<ExtArgs> | null
    /**
     * Filter, which ep_cash_per_day to fetch.
     */
    where?: ep_cash_per_dayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ep_cash_per_days to fetch.
     */
    orderBy?: ep_cash_per_dayOrderByWithRelationInput | ep_cash_per_dayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ep_cash_per_days.
     */
    cursor?: ep_cash_per_dayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ep_cash_per_days from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ep_cash_per_days.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ep_cash_per_days.
     */
    distinct?: Ep_cash_per_dayScalarFieldEnum | Ep_cash_per_dayScalarFieldEnum[]
  }

  /**
   * ep_cash_per_day findMany
   */
  export type ep_cash_per_dayFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_cash_per_day
     */
    select?: ep_cash_per_daySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_cash_per_day
     */
    omit?: ep_cash_per_dayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ep_cash_per_dayInclude<ExtArgs> | null
    /**
     * Filter, which ep_cash_per_days to fetch.
     */
    where?: ep_cash_per_dayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ep_cash_per_days to fetch.
     */
    orderBy?: ep_cash_per_dayOrderByWithRelationInput | ep_cash_per_dayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ep_cash_per_days.
     */
    cursor?: ep_cash_per_dayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ep_cash_per_days from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ep_cash_per_days.
     */
    skip?: number
    distinct?: Ep_cash_per_dayScalarFieldEnum | Ep_cash_per_dayScalarFieldEnum[]
  }

  /**
   * ep_cash_per_day create
   */
  export type ep_cash_per_dayCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_cash_per_day
     */
    select?: ep_cash_per_daySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_cash_per_day
     */
    omit?: ep_cash_per_dayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ep_cash_per_dayInclude<ExtArgs> | null
    /**
     * The data needed to create a ep_cash_per_day.
     */
    data: XOR<ep_cash_per_dayCreateInput, ep_cash_per_dayUncheckedCreateInput>
  }

  /**
   * ep_cash_per_day createMany
   */
  export type ep_cash_per_dayCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ep_cash_per_days.
     */
    data: ep_cash_per_dayCreateManyInput | ep_cash_per_dayCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ep_cash_per_day createManyAndReturn
   */
  export type ep_cash_per_dayCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_cash_per_day
     */
    select?: ep_cash_per_daySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ep_cash_per_day
     */
    omit?: ep_cash_per_dayOmit<ExtArgs> | null
    /**
     * The data used to create many ep_cash_per_days.
     */
    data: ep_cash_per_dayCreateManyInput | ep_cash_per_dayCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ep_cash_per_dayIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ep_cash_per_day update
   */
  export type ep_cash_per_dayUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_cash_per_day
     */
    select?: ep_cash_per_daySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_cash_per_day
     */
    omit?: ep_cash_per_dayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ep_cash_per_dayInclude<ExtArgs> | null
    /**
     * The data needed to update a ep_cash_per_day.
     */
    data: XOR<ep_cash_per_dayUpdateInput, ep_cash_per_dayUncheckedUpdateInput>
    /**
     * Choose, which ep_cash_per_day to update.
     */
    where: ep_cash_per_dayWhereUniqueInput
  }

  /**
   * ep_cash_per_day updateMany
   */
  export type ep_cash_per_dayUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ep_cash_per_days.
     */
    data: XOR<ep_cash_per_dayUpdateManyMutationInput, ep_cash_per_dayUncheckedUpdateManyInput>
    /**
     * Filter which ep_cash_per_days to update
     */
    where?: ep_cash_per_dayWhereInput
    /**
     * Limit how many ep_cash_per_days to update.
     */
    limit?: number
  }

  /**
   * ep_cash_per_day updateManyAndReturn
   */
  export type ep_cash_per_dayUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_cash_per_day
     */
    select?: ep_cash_per_daySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ep_cash_per_day
     */
    omit?: ep_cash_per_dayOmit<ExtArgs> | null
    /**
     * The data used to update ep_cash_per_days.
     */
    data: XOR<ep_cash_per_dayUpdateManyMutationInput, ep_cash_per_dayUncheckedUpdateManyInput>
    /**
     * Filter which ep_cash_per_days to update
     */
    where?: ep_cash_per_dayWhereInput
    /**
     * Limit how many ep_cash_per_days to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ep_cash_per_dayIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ep_cash_per_day upsert
   */
  export type ep_cash_per_dayUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_cash_per_day
     */
    select?: ep_cash_per_daySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_cash_per_day
     */
    omit?: ep_cash_per_dayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ep_cash_per_dayInclude<ExtArgs> | null
    /**
     * The filter to search for the ep_cash_per_day to update in case it exists.
     */
    where: ep_cash_per_dayWhereUniqueInput
    /**
     * In case the ep_cash_per_day found by the `where` argument doesn't exist, create a new ep_cash_per_day with this data.
     */
    create: XOR<ep_cash_per_dayCreateInput, ep_cash_per_dayUncheckedCreateInput>
    /**
     * In case the ep_cash_per_day was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ep_cash_per_dayUpdateInput, ep_cash_per_dayUncheckedUpdateInput>
  }

  /**
   * ep_cash_per_day delete
   */
  export type ep_cash_per_dayDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_cash_per_day
     */
    select?: ep_cash_per_daySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_cash_per_day
     */
    omit?: ep_cash_per_dayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ep_cash_per_dayInclude<ExtArgs> | null
    /**
     * Filter which ep_cash_per_day to delete.
     */
    where: ep_cash_per_dayWhereUniqueInput
  }

  /**
   * ep_cash_per_day deleteMany
   */
  export type ep_cash_per_dayDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ep_cash_per_days to delete
     */
    where?: ep_cash_per_dayWhereInput
    /**
     * Limit how many ep_cash_per_days to delete.
     */
    limit?: number
  }

  /**
   * ep_cash_per_day without action
   */
  export type ep_cash_per_dayDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_cash_per_day
     */
    select?: ep_cash_per_daySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_cash_per_day
     */
    omit?: ep_cash_per_dayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ep_cash_per_dayInclude<ExtArgs> | null
  }


  /**
   * Model ep_cashier
   */

  export type AggregateEp_cashier = {
    _count: Ep_cashierCountAggregateOutputType | null
    _avg: Ep_cashierAvgAggregateOutputType | null
    _sum: Ep_cashierSumAggregateOutputType | null
    _min: Ep_cashierMinAggregateOutputType | null
    _max: Ep_cashierMaxAggregateOutputType | null
  }

  export type Ep_cashierAvgAggregateOutputType = {
    cash_id: number | null
    cash_amount: Decimal | null
    cash_version: number | null
  }

  export type Ep_cashierSumAggregateOutputType = {
    cash_id: number | null
    cash_amount: Decimal | null
    cash_version: number | null
  }

  export type Ep_cashierMinAggregateOutputType = {
    cash_id: number | null
    cash_type: string | null
    cash_amount: Decimal | null
    cash_date: Date | null
    cash_version: number | null
    cash_movement_type: string | null
  }

  export type Ep_cashierMaxAggregateOutputType = {
    cash_id: number | null
    cash_type: string | null
    cash_amount: Decimal | null
    cash_date: Date | null
    cash_version: number | null
    cash_movement_type: string | null
  }

  export type Ep_cashierCountAggregateOutputType = {
    cash_id: number
    cash_type: number
    cash_amount: number
    cash_date: number
    cash_version: number
    cash_movement_type: number
    _all: number
  }


  export type Ep_cashierAvgAggregateInputType = {
    cash_id?: true
    cash_amount?: true
    cash_version?: true
  }

  export type Ep_cashierSumAggregateInputType = {
    cash_id?: true
    cash_amount?: true
    cash_version?: true
  }

  export type Ep_cashierMinAggregateInputType = {
    cash_id?: true
    cash_type?: true
    cash_amount?: true
    cash_date?: true
    cash_version?: true
    cash_movement_type?: true
  }

  export type Ep_cashierMaxAggregateInputType = {
    cash_id?: true
    cash_type?: true
    cash_amount?: true
    cash_date?: true
    cash_version?: true
    cash_movement_type?: true
  }

  export type Ep_cashierCountAggregateInputType = {
    cash_id?: true
    cash_type?: true
    cash_amount?: true
    cash_date?: true
    cash_version?: true
    cash_movement_type?: true
    _all?: true
  }

  export type Ep_cashierAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ep_cashier to aggregate.
     */
    where?: ep_cashierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ep_cashiers to fetch.
     */
    orderBy?: ep_cashierOrderByWithRelationInput | ep_cashierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ep_cashierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ep_cashiers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ep_cashiers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ep_cashiers
    **/
    _count?: true | Ep_cashierCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Ep_cashierAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Ep_cashierSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Ep_cashierMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Ep_cashierMaxAggregateInputType
  }

  export type GetEp_cashierAggregateType<T extends Ep_cashierAggregateArgs> = {
        [P in keyof T & keyof AggregateEp_cashier]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEp_cashier[P]>
      : GetScalarType<T[P], AggregateEp_cashier[P]>
  }




  export type ep_cashierGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ep_cashierWhereInput
    orderBy?: ep_cashierOrderByWithAggregationInput | ep_cashierOrderByWithAggregationInput[]
    by: Ep_cashierScalarFieldEnum[] | Ep_cashierScalarFieldEnum
    having?: ep_cashierScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Ep_cashierCountAggregateInputType | true
    _avg?: Ep_cashierAvgAggregateInputType
    _sum?: Ep_cashierSumAggregateInputType
    _min?: Ep_cashierMinAggregateInputType
    _max?: Ep_cashierMaxAggregateInputType
  }

  export type Ep_cashierGroupByOutputType = {
    cash_id: number
    cash_type: string
    cash_amount: Decimal
    cash_date: Date
    cash_version: number
    cash_movement_type: string | null
    _count: Ep_cashierCountAggregateOutputType | null
    _avg: Ep_cashierAvgAggregateOutputType | null
    _sum: Ep_cashierSumAggregateOutputType | null
    _min: Ep_cashierMinAggregateOutputType | null
    _max: Ep_cashierMaxAggregateOutputType | null
  }

  type GetEp_cashierGroupByPayload<T extends ep_cashierGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Ep_cashierGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Ep_cashierGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Ep_cashierGroupByOutputType[P]>
            : GetScalarType<T[P], Ep_cashierGroupByOutputType[P]>
        }
      >
    >


  export type ep_cashierSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cash_id?: boolean
    cash_type?: boolean
    cash_amount?: boolean
    cash_date?: boolean
    cash_version?: boolean
    cash_movement_type?: boolean
    transactions?: boolean | ep_cashier$transactionsArgs<ExtArgs>
    _count?: boolean | Ep_cashierCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ep_cashier"]>

  export type ep_cashierSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cash_id?: boolean
    cash_type?: boolean
    cash_amount?: boolean
    cash_date?: boolean
    cash_version?: boolean
    cash_movement_type?: boolean
  }, ExtArgs["result"]["ep_cashier"]>

  export type ep_cashierSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cash_id?: boolean
    cash_type?: boolean
    cash_amount?: boolean
    cash_date?: boolean
    cash_version?: boolean
    cash_movement_type?: boolean
  }, ExtArgs["result"]["ep_cashier"]>

  export type ep_cashierSelectScalar = {
    cash_id?: boolean
    cash_type?: boolean
    cash_amount?: boolean
    cash_date?: boolean
    cash_version?: boolean
    cash_movement_type?: boolean
  }

  export type ep_cashierOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"cash_id" | "cash_type" | "cash_amount" | "cash_date" | "cash_version" | "cash_movement_type", ExtArgs["result"]["ep_cashier"]>
  export type ep_cashierInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | ep_cashier$transactionsArgs<ExtArgs>
    _count?: boolean | Ep_cashierCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ep_cashierIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ep_cashierIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ep_cashierPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ep_cashier"
    objects: {
      transactions: Prisma.$ep_cashier_transactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      cash_id: number
      cash_type: string
      cash_amount: Prisma.Decimal
      cash_date: Date
      cash_version: number
      cash_movement_type: string | null
    }, ExtArgs["result"]["ep_cashier"]>
    composites: {}
  }

  type ep_cashierGetPayload<S extends boolean | null | undefined | ep_cashierDefaultArgs> = $Result.GetResult<Prisma.$ep_cashierPayload, S>

  type ep_cashierCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ep_cashierFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Ep_cashierCountAggregateInputType | true
    }

  export interface ep_cashierDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ep_cashier'], meta: { name: 'ep_cashier' } }
    /**
     * Find zero or one Ep_cashier that matches the filter.
     * @param {ep_cashierFindUniqueArgs} args - Arguments to find a Ep_cashier
     * @example
     * // Get one Ep_cashier
     * const ep_cashier = await prisma.ep_cashier.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ep_cashierFindUniqueArgs>(args: SelectSubset<T, ep_cashierFindUniqueArgs<ExtArgs>>): Prisma__ep_cashierClient<$Result.GetResult<Prisma.$ep_cashierPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ep_cashier that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ep_cashierFindUniqueOrThrowArgs} args - Arguments to find a Ep_cashier
     * @example
     * // Get one Ep_cashier
     * const ep_cashier = await prisma.ep_cashier.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ep_cashierFindUniqueOrThrowArgs>(args: SelectSubset<T, ep_cashierFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ep_cashierClient<$Result.GetResult<Prisma.$ep_cashierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ep_cashier that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ep_cashierFindFirstArgs} args - Arguments to find a Ep_cashier
     * @example
     * // Get one Ep_cashier
     * const ep_cashier = await prisma.ep_cashier.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ep_cashierFindFirstArgs>(args?: SelectSubset<T, ep_cashierFindFirstArgs<ExtArgs>>): Prisma__ep_cashierClient<$Result.GetResult<Prisma.$ep_cashierPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ep_cashier that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ep_cashierFindFirstOrThrowArgs} args - Arguments to find a Ep_cashier
     * @example
     * // Get one Ep_cashier
     * const ep_cashier = await prisma.ep_cashier.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ep_cashierFindFirstOrThrowArgs>(args?: SelectSubset<T, ep_cashierFindFirstOrThrowArgs<ExtArgs>>): Prisma__ep_cashierClient<$Result.GetResult<Prisma.$ep_cashierPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ep_cashiers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ep_cashierFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ep_cashiers
     * const ep_cashiers = await prisma.ep_cashier.findMany()
     * 
     * // Get first 10 Ep_cashiers
     * const ep_cashiers = await prisma.ep_cashier.findMany({ take: 10 })
     * 
     * // Only select the `cash_id`
     * const ep_cashierWithCash_idOnly = await prisma.ep_cashier.findMany({ select: { cash_id: true } })
     * 
     */
    findMany<T extends ep_cashierFindManyArgs>(args?: SelectSubset<T, ep_cashierFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ep_cashierPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ep_cashier.
     * @param {ep_cashierCreateArgs} args - Arguments to create a Ep_cashier.
     * @example
     * // Create one Ep_cashier
     * const Ep_cashier = await prisma.ep_cashier.create({
     *   data: {
     *     // ... data to create a Ep_cashier
     *   }
     * })
     * 
     */
    create<T extends ep_cashierCreateArgs>(args: SelectSubset<T, ep_cashierCreateArgs<ExtArgs>>): Prisma__ep_cashierClient<$Result.GetResult<Prisma.$ep_cashierPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ep_cashiers.
     * @param {ep_cashierCreateManyArgs} args - Arguments to create many Ep_cashiers.
     * @example
     * // Create many Ep_cashiers
     * const ep_cashier = await prisma.ep_cashier.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ep_cashierCreateManyArgs>(args?: SelectSubset<T, ep_cashierCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ep_cashiers and returns the data saved in the database.
     * @param {ep_cashierCreateManyAndReturnArgs} args - Arguments to create many Ep_cashiers.
     * @example
     * // Create many Ep_cashiers
     * const ep_cashier = await prisma.ep_cashier.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ep_cashiers and only return the `cash_id`
     * const ep_cashierWithCash_idOnly = await prisma.ep_cashier.createManyAndReturn({
     *   select: { cash_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ep_cashierCreateManyAndReturnArgs>(args?: SelectSubset<T, ep_cashierCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ep_cashierPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Ep_cashier.
     * @param {ep_cashierDeleteArgs} args - Arguments to delete one Ep_cashier.
     * @example
     * // Delete one Ep_cashier
     * const Ep_cashier = await prisma.ep_cashier.delete({
     *   where: {
     *     // ... filter to delete one Ep_cashier
     *   }
     * })
     * 
     */
    delete<T extends ep_cashierDeleteArgs>(args: SelectSubset<T, ep_cashierDeleteArgs<ExtArgs>>): Prisma__ep_cashierClient<$Result.GetResult<Prisma.$ep_cashierPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ep_cashier.
     * @param {ep_cashierUpdateArgs} args - Arguments to update one Ep_cashier.
     * @example
     * // Update one Ep_cashier
     * const ep_cashier = await prisma.ep_cashier.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ep_cashierUpdateArgs>(args: SelectSubset<T, ep_cashierUpdateArgs<ExtArgs>>): Prisma__ep_cashierClient<$Result.GetResult<Prisma.$ep_cashierPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ep_cashiers.
     * @param {ep_cashierDeleteManyArgs} args - Arguments to filter Ep_cashiers to delete.
     * @example
     * // Delete a few Ep_cashiers
     * const { count } = await prisma.ep_cashier.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ep_cashierDeleteManyArgs>(args?: SelectSubset<T, ep_cashierDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ep_cashiers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ep_cashierUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ep_cashiers
     * const ep_cashier = await prisma.ep_cashier.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ep_cashierUpdateManyArgs>(args: SelectSubset<T, ep_cashierUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ep_cashiers and returns the data updated in the database.
     * @param {ep_cashierUpdateManyAndReturnArgs} args - Arguments to update many Ep_cashiers.
     * @example
     * // Update many Ep_cashiers
     * const ep_cashier = await prisma.ep_cashier.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Ep_cashiers and only return the `cash_id`
     * const ep_cashierWithCash_idOnly = await prisma.ep_cashier.updateManyAndReturn({
     *   select: { cash_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ep_cashierUpdateManyAndReturnArgs>(args: SelectSubset<T, ep_cashierUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ep_cashierPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Ep_cashier.
     * @param {ep_cashierUpsertArgs} args - Arguments to update or create a Ep_cashier.
     * @example
     * // Update or create a Ep_cashier
     * const ep_cashier = await prisma.ep_cashier.upsert({
     *   create: {
     *     // ... data to create a Ep_cashier
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ep_cashier we want to update
     *   }
     * })
     */
    upsert<T extends ep_cashierUpsertArgs>(args: SelectSubset<T, ep_cashierUpsertArgs<ExtArgs>>): Prisma__ep_cashierClient<$Result.GetResult<Prisma.$ep_cashierPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ep_cashiers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ep_cashierCountArgs} args - Arguments to filter Ep_cashiers to count.
     * @example
     * // Count the number of Ep_cashiers
     * const count = await prisma.ep_cashier.count({
     *   where: {
     *     // ... the filter for the Ep_cashiers we want to count
     *   }
     * })
    **/
    count<T extends ep_cashierCountArgs>(
      args?: Subset<T, ep_cashierCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Ep_cashierCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ep_cashier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ep_cashierAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Ep_cashierAggregateArgs>(args: Subset<T, Ep_cashierAggregateArgs>): Prisma.PrismaPromise<GetEp_cashierAggregateType<T>>

    /**
     * Group by Ep_cashier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ep_cashierGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ep_cashierGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ep_cashierGroupByArgs['orderBy'] }
        : { orderBy?: ep_cashierGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ep_cashierGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEp_cashierGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ep_cashier model
   */
  readonly fields: ep_cashierFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ep_cashier.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ep_cashierClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transactions<T extends ep_cashier$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, ep_cashier$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ep_cashier_transactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ep_cashier model
   */ 
  interface ep_cashierFieldRefs {
    readonly cash_id: FieldRef<"ep_cashier", 'Int'>
    readonly cash_type: FieldRef<"ep_cashier", 'String'>
    readonly cash_amount: FieldRef<"ep_cashier", 'Decimal'>
    readonly cash_date: FieldRef<"ep_cashier", 'DateTime'>
    readonly cash_version: FieldRef<"ep_cashier", 'Int'>
    readonly cash_movement_type: FieldRef<"ep_cashier", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ep_cashier findUnique
   */
  export type ep_cashierFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_cashier
     */
    select?: ep_cashierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_cashier
     */
    omit?: ep_cashierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ep_cashierInclude<ExtArgs> | null
    /**
     * Filter, which ep_cashier to fetch.
     */
    where: ep_cashierWhereUniqueInput
  }

  /**
   * ep_cashier findUniqueOrThrow
   */
  export type ep_cashierFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_cashier
     */
    select?: ep_cashierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_cashier
     */
    omit?: ep_cashierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ep_cashierInclude<ExtArgs> | null
    /**
     * Filter, which ep_cashier to fetch.
     */
    where: ep_cashierWhereUniqueInput
  }

  /**
   * ep_cashier findFirst
   */
  export type ep_cashierFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_cashier
     */
    select?: ep_cashierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_cashier
     */
    omit?: ep_cashierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ep_cashierInclude<ExtArgs> | null
    /**
     * Filter, which ep_cashier to fetch.
     */
    where?: ep_cashierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ep_cashiers to fetch.
     */
    orderBy?: ep_cashierOrderByWithRelationInput | ep_cashierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ep_cashiers.
     */
    cursor?: ep_cashierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ep_cashiers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ep_cashiers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ep_cashiers.
     */
    distinct?: Ep_cashierScalarFieldEnum | Ep_cashierScalarFieldEnum[]
  }

  /**
   * ep_cashier findFirstOrThrow
   */
  export type ep_cashierFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_cashier
     */
    select?: ep_cashierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_cashier
     */
    omit?: ep_cashierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ep_cashierInclude<ExtArgs> | null
    /**
     * Filter, which ep_cashier to fetch.
     */
    where?: ep_cashierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ep_cashiers to fetch.
     */
    orderBy?: ep_cashierOrderByWithRelationInput | ep_cashierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ep_cashiers.
     */
    cursor?: ep_cashierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ep_cashiers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ep_cashiers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ep_cashiers.
     */
    distinct?: Ep_cashierScalarFieldEnum | Ep_cashierScalarFieldEnum[]
  }

  /**
   * ep_cashier findMany
   */
  export type ep_cashierFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_cashier
     */
    select?: ep_cashierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_cashier
     */
    omit?: ep_cashierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ep_cashierInclude<ExtArgs> | null
    /**
     * Filter, which ep_cashiers to fetch.
     */
    where?: ep_cashierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ep_cashiers to fetch.
     */
    orderBy?: ep_cashierOrderByWithRelationInput | ep_cashierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ep_cashiers.
     */
    cursor?: ep_cashierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ep_cashiers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ep_cashiers.
     */
    skip?: number
    distinct?: Ep_cashierScalarFieldEnum | Ep_cashierScalarFieldEnum[]
  }

  /**
   * ep_cashier create
   */
  export type ep_cashierCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_cashier
     */
    select?: ep_cashierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_cashier
     */
    omit?: ep_cashierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ep_cashierInclude<ExtArgs> | null
    /**
     * The data needed to create a ep_cashier.
     */
    data: XOR<ep_cashierCreateInput, ep_cashierUncheckedCreateInput>
  }

  /**
   * ep_cashier createMany
   */
  export type ep_cashierCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ep_cashiers.
     */
    data: ep_cashierCreateManyInput | ep_cashierCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ep_cashier createManyAndReturn
   */
  export type ep_cashierCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_cashier
     */
    select?: ep_cashierSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ep_cashier
     */
    omit?: ep_cashierOmit<ExtArgs> | null
    /**
     * The data used to create many ep_cashiers.
     */
    data: ep_cashierCreateManyInput | ep_cashierCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ep_cashier update
   */
  export type ep_cashierUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_cashier
     */
    select?: ep_cashierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_cashier
     */
    omit?: ep_cashierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ep_cashierInclude<ExtArgs> | null
    /**
     * The data needed to update a ep_cashier.
     */
    data: XOR<ep_cashierUpdateInput, ep_cashierUncheckedUpdateInput>
    /**
     * Choose, which ep_cashier to update.
     */
    where: ep_cashierWhereUniqueInput
  }

  /**
   * ep_cashier updateMany
   */
  export type ep_cashierUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ep_cashiers.
     */
    data: XOR<ep_cashierUpdateManyMutationInput, ep_cashierUncheckedUpdateManyInput>
    /**
     * Filter which ep_cashiers to update
     */
    where?: ep_cashierWhereInput
    /**
     * Limit how many ep_cashiers to update.
     */
    limit?: number
  }

  /**
   * ep_cashier updateManyAndReturn
   */
  export type ep_cashierUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_cashier
     */
    select?: ep_cashierSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ep_cashier
     */
    omit?: ep_cashierOmit<ExtArgs> | null
    /**
     * The data used to update ep_cashiers.
     */
    data: XOR<ep_cashierUpdateManyMutationInput, ep_cashierUncheckedUpdateManyInput>
    /**
     * Filter which ep_cashiers to update
     */
    where?: ep_cashierWhereInput
    /**
     * Limit how many ep_cashiers to update.
     */
    limit?: number
  }

  /**
   * ep_cashier upsert
   */
  export type ep_cashierUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_cashier
     */
    select?: ep_cashierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_cashier
     */
    omit?: ep_cashierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ep_cashierInclude<ExtArgs> | null
    /**
     * The filter to search for the ep_cashier to update in case it exists.
     */
    where: ep_cashierWhereUniqueInput
    /**
     * In case the ep_cashier found by the `where` argument doesn't exist, create a new ep_cashier with this data.
     */
    create: XOR<ep_cashierCreateInput, ep_cashierUncheckedCreateInput>
    /**
     * In case the ep_cashier was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ep_cashierUpdateInput, ep_cashierUncheckedUpdateInput>
  }

  /**
   * ep_cashier delete
   */
  export type ep_cashierDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_cashier
     */
    select?: ep_cashierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_cashier
     */
    omit?: ep_cashierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ep_cashierInclude<ExtArgs> | null
    /**
     * Filter which ep_cashier to delete.
     */
    where: ep_cashierWhereUniqueInput
  }

  /**
   * ep_cashier deleteMany
   */
  export type ep_cashierDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ep_cashiers to delete
     */
    where?: ep_cashierWhereInput
    /**
     * Limit how many ep_cashiers to delete.
     */
    limit?: number
  }

  /**
   * ep_cashier.transactions
   */
  export type ep_cashier$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_cashier_transaction
     */
    select?: ep_cashier_transactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_cashier_transaction
     */
    omit?: ep_cashier_transactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ep_cashier_transactionInclude<ExtArgs> | null
    where?: ep_cashier_transactionWhereInput
    orderBy?: ep_cashier_transactionOrderByWithRelationInput | ep_cashier_transactionOrderByWithRelationInput[]
    cursor?: ep_cashier_transactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Ep_cashier_transactionScalarFieldEnum | Ep_cashier_transactionScalarFieldEnum[]
  }

  /**
   * ep_cashier without action
   */
  export type ep_cashierDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_cashier
     */
    select?: ep_cashierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_cashier
     */
    omit?: ep_cashierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ep_cashierInclude<ExtArgs> | null
  }


  /**
   * Model ep_cashier_transaction
   */

  export type AggregateEp_cashier_transaction = {
    _count: Ep_cashier_transactionCountAggregateOutputType | null
    _avg: Ep_cashier_transactionAvgAggregateOutputType | null
    _sum: Ep_cashier_transactionSumAggregateOutputType | null
    _min: Ep_cashier_transactionMinAggregateOutputType | null
    _max: Ep_cashier_transactionMaxAggregateOutputType | null
  }

  export type Ep_cashier_transactionAvgAggregateOutputType = {
    cash_trans_id: number | null
    cash_trans_cashier_id: number | null
  }

  export type Ep_cashier_transactionSumAggregateOutputType = {
    cash_trans_id: number | null
    cash_trans_cashier_id: number | null
  }

  export type Ep_cashier_transactionMinAggregateOutputType = {
    cash_trans_id: number | null
    cash_trans_amount: string | null
    cash_trans_type: string | null
    cash_trans_method: string | null
    cash_trans_date: Date | null
    cash_trans_cashier_id: number | null
  }

  export type Ep_cashier_transactionMaxAggregateOutputType = {
    cash_trans_id: number | null
    cash_trans_amount: string | null
    cash_trans_type: string | null
    cash_trans_method: string | null
    cash_trans_date: Date | null
    cash_trans_cashier_id: number | null
  }

  export type Ep_cashier_transactionCountAggregateOutputType = {
    cash_trans_id: number
    cash_trans_amount: number
    cash_trans_type: number
    cash_trans_method: number
    cash_trans_date: number
    cash_trans_cashier_id: number
    _all: number
  }


  export type Ep_cashier_transactionAvgAggregateInputType = {
    cash_trans_id?: true
    cash_trans_cashier_id?: true
  }

  export type Ep_cashier_transactionSumAggregateInputType = {
    cash_trans_id?: true
    cash_trans_cashier_id?: true
  }

  export type Ep_cashier_transactionMinAggregateInputType = {
    cash_trans_id?: true
    cash_trans_amount?: true
    cash_trans_type?: true
    cash_trans_method?: true
    cash_trans_date?: true
    cash_trans_cashier_id?: true
  }

  export type Ep_cashier_transactionMaxAggregateInputType = {
    cash_trans_id?: true
    cash_trans_amount?: true
    cash_trans_type?: true
    cash_trans_method?: true
    cash_trans_date?: true
    cash_trans_cashier_id?: true
  }

  export type Ep_cashier_transactionCountAggregateInputType = {
    cash_trans_id?: true
    cash_trans_amount?: true
    cash_trans_type?: true
    cash_trans_method?: true
    cash_trans_date?: true
    cash_trans_cashier_id?: true
    _all?: true
  }

  export type Ep_cashier_transactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ep_cashier_transaction to aggregate.
     */
    where?: ep_cashier_transactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ep_cashier_transactions to fetch.
     */
    orderBy?: ep_cashier_transactionOrderByWithRelationInput | ep_cashier_transactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ep_cashier_transactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ep_cashier_transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ep_cashier_transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ep_cashier_transactions
    **/
    _count?: true | Ep_cashier_transactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Ep_cashier_transactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Ep_cashier_transactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Ep_cashier_transactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Ep_cashier_transactionMaxAggregateInputType
  }

  export type GetEp_cashier_transactionAggregateType<T extends Ep_cashier_transactionAggregateArgs> = {
        [P in keyof T & keyof AggregateEp_cashier_transaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEp_cashier_transaction[P]>
      : GetScalarType<T[P], AggregateEp_cashier_transaction[P]>
  }




  export type ep_cashier_transactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ep_cashier_transactionWhereInput
    orderBy?: ep_cashier_transactionOrderByWithAggregationInput | ep_cashier_transactionOrderByWithAggregationInput[]
    by: Ep_cashier_transactionScalarFieldEnum[] | Ep_cashier_transactionScalarFieldEnum
    having?: ep_cashier_transactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Ep_cashier_transactionCountAggregateInputType | true
    _avg?: Ep_cashier_transactionAvgAggregateInputType
    _sum?: Ep_cashier_transactionSumAggregateInputType
    _min?: Ep_cashier_transactionMinAggregateInputType
    _max?: Ep_cashier_transactionMaxAggregateInputType
  }

  export type Ep_cashier_transactionGroupByOutputType = {
    cash_trans_id: number
    cash_trans_amount: string
    cash_trans_type: string
    cash_trans_method: string
    cash_trans_date: Date
    cash_trans_cashier_id: number
    _count: Ep_cashier_transactionCountAggregateOutputType | null
    _avg: Ep_cashier_transactionAvgAggregateOutputType | null
    _sum: Ep_cashier_transactionSumAggregateOutputType | null
    _min: Ep_cashier_transactionMinAggregateOutputType | null
    _max: Ep_cashier_transactionMaxAggregateOutputType | null
  }

  type GetEp_cashier_transactionGroupByPayload<T extends ep_cashier_transactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Ep_cashier_transactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Ep_cashier_transactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Ep_cashier_transactionGroupByOutputType[P]>
            : GetScalarType<T[P], Ep_cashier_transactionGroupByOutputType[P]>
        }
      >
    >


  export type ep_cashier_transactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cash_trans_id?: boolean
    cash_trans_amount?: boolean
    cash_trans_type?: boolean
    cash_trans_method?: boolean
    cash_trans_date?: boolean
    cash_trans_cashier_id?: boolean
    cashier?: boolean | ep_cashierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ep_cashier_transaction"]>

  export type ep_cashier_transactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cash_trans_id?: boolean
    cash_trans_amount?: boolean
    cash_trans_type?: boolean
    cash_trans_method?: boolean
    cash_trans_date?: boolean
    cash_trans_cashier_id?: boolean
    cashier?: boolean | ep_cashierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ep_cashier_transaction"]>

  export type ep_cashier_transactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cash_trans_id?: boolean
    cash_trans_amount?: boolean
    cash_trans_type?: boolean
    cash_trans_method?: boolean
    cash_trans_date?: boolean
    cash_trans_cashier_id?: boolean
    cashier?: boolean | ep_cashierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ep_cashier_transaction"]>

  export type ep_cashier_transactionSelectScalar = {
    cash_trans_id?: boolean
    cash_trans_amount?: boolean
    cash_trans_type?: boolean
    cash_trans_method?: boolean
    cash_trans_date?: boolean
    cash_trans_cashier_id?: boolean
  }

  export type ep_cashier_transactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"cash_trans_id" | "cash_trans_amount" | "cash_trans_type" | "cash_trans_method" | "cash_trans_date" | "cash_trans_cashier_id", ExtArgs["result"]["ep_cashier_transaction"]>
  export type ep_cashier_transactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cashier?: boolean | ep_cashierDefaultArgs<ExtArgs>
  }
  export type ep_cashier_transactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cashier?: boolean | ep_cashierDefaultArgs<ExtArgs>
  }
  export type ep_cashier_transactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cashier?: boolean | ep_cashierDefaultArgs<ExtArgs>
  }

  export type $ep_cashier_transactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ep_cashier_transaction"
    objects: {
      cashier: Prisma.$ep_cashierPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      cash_trans_id: number
      cash_trans_amount: string
      cash_trans_type: string
      cash_trans_method: string
      cash_trans_date: Date
      cash_trans_cashier_id: number
    }, ExtArgs["result"]["ep_cashier_transaction"]>
    composites: {}
  }

  type ep_cashier_transactionGetPayload<S extends boolean | null | undefined | ep_cashier_transactionDefaultArgs> = $Result.GetResult<Prisma.$ep_cashier_transactionPayload, S>

  type ep_cashier_transactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ep_cashier_transactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Ep_cashier_transactionCountAggregateInputType | true
    }

  export interface ep_cashier_transactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ep_cashier_transaction'], meta: { name: 'ep_cashier_transaction' } }
    /**
     * Find zero or one Ep_cashier_transaction that matches the filter.
     * @param {ep_cashier_transactionFindUniqueArgs} args - Arguments to find a Ep_cashier_transaction
     * @example
     * // Get one Ep_cashier_transaction
     * const ep_cashier_transaction = await prisma.ep_cashier_transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ep_cashier_transactionFindUniqueArgs>(args: SelectSubset<T, ep_cashier_transactionFindUniqueArgs<ExtArgs>>): Prisma__ep_cashier_transactionClient<$Result.GetResult<Prisma.$ep_cashier_transactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ep_cashier_transaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ep_cashier_transactionFindUniqueOrThrowArgs} args - Arguments to find a Ep_cashier_transaction
     * @example
     * // Get one Ep_cashier_transaction
     * const ep_cashier_transaction = await prisma.ep_cashier_transaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ep_cashier_transactionFindUniqueOrThrowArgs>(args: SelectSubset<T, ep_cashier_transactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ep_cashier_transactionClient<$Result.GetResult<Prisma.$ep_cashier_transactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ep_cashier_transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ep_cashier_transactionFindFirstArgs} args - Arguments to find a Ep_cashier_transaction
     * @example
     * // Get one Ep_cashier_transaction
     * const ep_cashier_transaction = await prisma.ep_cashier_transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ep_cashier_transactionFindFirstArgs>(args?: SelectSubset<T, ep_cashier_transactionFindFirstArgs<ExtArgs>>): Prisma__ep_cashier_transactionClient<$Result.GetResult<Prisma.$ep_cashier_transactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ep_cashier_transaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ep_cashier_transactionFindFirstOrThrowArgs} args - Arguments to find a Ep_cashier_transaction
     * @example
     * // Get one Ep_cashier_transaction
     * const ep_cashier_transaction = await prisma.ep_cashier_transaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ep_cashier_transactionFindFirstOrThrowArgs>(args?: SelectSubset<T, ep_cashier_transactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ep_cashier_transactionClient<$Result.GetResult<Prisma.$ep_cashier_transactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ep_cashier_transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ep_cashier_transactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ep_cashier_transactions
     * const ep_cashier_transactions = await prisma.ep_cashier_transaction.findMany()
     * 
     * // Get first 10 Ep_cashier_transactions
     * const ep_cashier_transactions = await prisma.ep_cashier_transaction.findMany({ take: 10 })
     * 
     * // Only select the `cash_trans_id`
     * const ep_cashier_transactionWithCash_trans_idOnly = await prisma.ep_cashier_transaction.findMany({ select: { cash_trans_id: true } })
     * 
     */
    findMany<T extends ep_cashier_transactionFindManyArgs>(args?: SelectSubset<T, ep_cashier_transactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ep_cashier_transactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ep_cashier_transaction.
     * @param {ep_cashier_transactionCreateArgs} args - Arguments to create a Ep_cashier_transaction.
     * @example
     * // Create one Ep_cashier_transaction
     * const Ep_cashier_transaction = await prisma.ep_cashier_transaction.create({
     *   data: {
     *     // ... data to create a Ep_cashier_transaction
     *   }
     * })
     * 
     */
    create<T extends ep_cashier_transactionCreateArgs>(args: SelectSubset<T, ep_cashier_transactionCreateArgs<ExtArgs>>): Prisma__ep_cashier_transactionClient<$Result.GetResult<Prisma.$ep_cashier_transactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ep_cashier_transactions.
     * @param {ep_cashier_transactionCreateManyArgs} args - Arguments to create many Ep_cashier_transactions.
     * @example
     * // Create many Ep_cashier_transactions
     * const ep_cashier_transaction = await prisma.ep_cashier_transaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ep_cashier_transactionCreateManyArgs>(args?: SelectSubset<T, ep_cashier_transactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ep_cashier_transactions and returns the data saved in the database.
     * @param {ep_cashier_transactionCreateManyAndReturnArgs} args - Arguments to create many Ep_cashier_transactions.
     * @example
     * // Create many Ep_cashier_transactions
     * const ep_cashier_transaction = await prisma.ep_cashier_transaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ep_cashier_transactions and only return the `cash_trans_id`
     * const ep_cashier_transactionWithCash_trans_idOnly = await prisma.ep_cashier_transaction.createManyAndReturn({
     *   select: { cash_trans_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ep_cashier_transactionCreateManyAndReturnArgs>(args?: SelectSubset<T, ep_cashier_transactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ep_cashier_transactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Ep_cashier_transaction.
     * @param {ep_cashier_transactionDeleteArgs} args - Arguments to delete one Ep_cashier_transaction.
     * @example
     * // Delete one Ep_cashier_transaction
     * const Ep_cashier_transaction = await prisma.ep_cashier_transaction.delete({
     *   where: {
     *     // ... filter to delete one Ep_cashier_transaction
     *   }
     * })
     * 
     */
    delete<T extends ep_cashier_transactionDeleteArgs>(args: SelectSubset<T, ep_cashier_transactionDeleteArgs<ExtArgs>>): Prisma__ep_cashier_transactionClient<$Result.GetResult<Prisma.$ep_cashier_transactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ep_cashier_transaction.
     * @param {ep_cashier_transactionUpdateArgs} args - Arguments to update one Ep_cashier_transaction.
     * @example
     * // Update one Ep_cashier_transaction
     * const ep_cashier_transaction = await prisma.ep_cashier_transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ep_cashier_transactionUpdateArgs>(args: SelectSubset<T, ep_cashier_transactionUpdateArgs<ExtArgs>>): Prisma__ep_cashier_transactionClient<$Result.GetResult<Prisma.$ep_cashier_transactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ep_cashier_transactions.
     * @param {ep_cashier_transactionDeleteManyArgs} args - Arguments to filter Ep_cashier_transactions to delete.
     * @example
     * // Delete a few Ep_cashier_transactions
     * const { count } = await prisma.ep_cashier_transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ep_cashier_transactionDeleteManyArgs>(args?: SelectSubset<T, ep_cashier_transactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ep_cashier_transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ep_cashier_transactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ep_cashier_transactions
     * const ep_cashier_transaction = await prisma.ep_cashier_transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ep_cashier_transactionUpdateManyArgs>(args: SelectSubset<T, ep_cashier_transactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ep_cashier_transactions and returns the data updated in the database.
     * @param {ep_cashier_transactionUpdateManyAndReturnArgs} args - Arguments to update many Ep_cashier_transactions.
     * @example
     * // Update many Ep_cashier_transactions
     * const ep_cashier_transaction = await prisma.ep_cashier_transaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Ep_cashier_transactions and only return the `cash_trans_id`
     * const ep_cashier_transactionWithCash_trans_idOnly = await prisma.ep_cashier_transaction.updateManyAndReturn({
     *   select: { cash_trans_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ep_cashier_transactionUpdateManyAndReturnArgs>(args: SelectSubset<T, ep_cashier_transactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ep_cashier_transactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Ep_cashier_transaction.
     * @param {ep_cashier_transactionUpsertArgs} args - Arguments to update or create a Ep_cashier_transaction.
     * @example
     * // Update or create a Ep_cashier_transaction
     * const ep_cashier_transaction = await prisma.ep_cashier_transaction.upsert({
     *   create: {
     *     // ... data to create a Ep_cashier_transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ep_cashier_transaction we want to update
     *   }
     * })
     */
    upsert<T extends ep_cashier_transactionUpsertArgs>(args: SelectSubset<T, ep_cashier_transactionUpsertArgs<ExtArgs>>): Prisma__ep_cashier_transactionClient<$Result.GetResult<Prisma.$ep_cashier_transactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ep_cashier_transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ep_cashier_transactionCountArgs} args - Arguments to filter Ep_cashier_transactions to count.
     * @example
     * // Count the number of Ep_cashier_transactions
     * const count = await prisma.ep_cashier_transaction.count({
     *   where: {
     *     // ... the filter for the Ep_cashier_transactions we want to count
     *   }
     * })
    **/
    count<T extends ep_cashier_transactionCountArgs>(
      args?: Subset<T, ep_cashier_transactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Ep_cashier_transactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ep_cashier_transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ep_cashier_transactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Ep_cashier_transactionAggregateArgs>(args: Subset<T, Ep_cashier_transactionAggregateArgs>): Prisma.PrismaPromise<GetEp_cashier_transactionAggregateType<T>>

    /**
     * Group by Ep_cashier_transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ep_cashier_transactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ep_cashier_transactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ep_cashier_transactionGroupByArgs['orderBy'] }
        : { orderBy?: ep_cashier_transactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ep_cashier_transactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEp_cashier_transactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ep_cashier_transaction model
   */
  readonly fields: ep_cashier_transactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ep_cashier_transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ep_cashier_transactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cashier<T extends ep_cashierDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ep_cashierDefaultArgs<ExtArgs>>): Prisma__ep_cashierClient<$Result.GetResult<Prisma.$ep_cashierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ep_cashier_transaction model
   */ 
  interface ep_cashier_transactionFieldRefs {
    readonly cash_trans_id: FieldRef<"ep_cashier_transaction", 'Int'>
    readonly cash_trans_amount: FieldRef<"ep_cashier_transaction", 'String'>
    readonly cash_trans_type: FieldRef<"ep_cashier_transaction", 'String'>
    readonly cash_trans_method: FieldRef<"ep_cashier_transaction", 'String'>
    readonly cash_trans_date: FieldRef<"ep_cashier_transaction", 'DateTime'>
    readonly cash_trans_cashier_id: FieldRef<"ep_cashier_transaction", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ep_cashier_transaction findUnique
   */
  export type ep_cashier_transactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_cashier_transaction
     */
    select?: ep_cashier_transactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_cashier_transaction
     */
    omit?: ep_cashier_transactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ep_cashier_transactionInclude<ExtArgs> | null
    /**
     * Filter, which ep_cashier_transaction to fetch.
     */
    where: ep_cashier_transactionWhereUniqueInput
  }

  /**
   * ep_cashier_transaction findUniqueOrThrow
   */
  export type ep_cashier_transactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_cashier_transaction
     */
    select?: ep_cashier_transactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_cashier_transaction
     */
    omit?: ep_cashier_transactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ep_cashier_transactionInclude<ExtArgs> | null
    /**
     * Filter, which ep_cashier_transaction to fetch.
     */
    where: ep_cashier_transactionWhereUniqueInput
  }

  /**
   * ep_cashier_transaction findFirst
   */
  export type ep_cashier_transactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_cashier_transaction
     */
    select?: ep_cashier_transactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_cashier_transaction
     */
    omit?: ep_cashier_transactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ep_cashier_transactionInclude<ExtArgs> | null
    /**
     * Filter, which ep_cashier_transaction to fetch.
     */
    where?: ep_cashier_transactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ep_cashier_transactions to fetch.
     */
    orderBy?: ep_cashier_transactionOrderByWithRelationInput | ep_cashier_transactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ep_cashier_transactions.
     */
    cursor?: ep_cashier_transactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ep_cashier_transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ep_cashier_transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ep_cashier_transactions.
     */
    distinct?: Ep_cashier_transactionScalarFieldEnum | Ep_cashier_transactionScalarFieldEnum[]
  }

  /**
   * ep_cashier_transaction findFirstOrThrow
   */
  export type ep_cashier_transactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_cashier_transaction
     */
    select?: ep_cashier_transactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_cashier_transaction
     */
    omit?: ep_cashier_transactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ep_cashier_transactionInclude<ExtArgs> | null
    /**
     * Filter, which ep_cashier_transaction to fetch.
     */
    where?: ep_cashier_transactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ep_cashier_transactions to fetch.
     */
    orderBy?: ep_cashier_transactionOrderByWithRelationInput | ep_cashier_transactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ep_cashier_transactions.
     */
    cursor?: ep_cashier_transactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ep_cashier_transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ep_cashier_transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ep_cashier_transactions.
     */
    distinct?: Ep_cashier_transactionScalarFieldEnum | Ep_cashier_transactionScalarFieldEnum[]
  }

  /**
   * ep_cashier_transaction findMany
   */
  export type ep_cashier_transactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_cashier_transaction
     */
    select?: ep_cashier_transactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_cashier_transaction
     */
    omit?: ep_cashier_transactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ep_cashier_transactionInclude<ExtArgs> | null
    /**
     * Filter, which ep_cashier_transactions to fetch.
     */
    where?: ep_cashier_transactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ep_cashier_transactions to fetch.
     */
    orderBy?: ep_cashier_transactionOrderByWithRelationInput | ep_cashier_transactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ep_cashier_transactions.
     */
    cursor?: ep_cashier_transactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ep_cashier_transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ep_cashier_transactions.
     */
    skip?: number
    distinct?: Ep_cashier_transactionScalarFieldEnum | Ep_cashier_transactionScalarFieldEnum[]
  }

  /**
   * ep_cashier_transaction create
   */
  export type ep_cashier_transactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_cashier_transaction
     */
    select?: ep_cashier_transactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_cashier_transaction
     */
    omit?: ep_cashier_transactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ep_cashier_transactionInclude<ExtArgs> | null
    /**
     * The data needed to create a ep_cashier_transaction.
     */
    data: XOR<ep_cashier_transactionCreateInput, ep_cashier_transactionUncheckedCreateInput>
  }

  /**
   * ep_cashier_transaction createMany
   */
  export type ep_cashier_transactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ep_cashier_transactions.
     */
    data: ep_cashier_transactionCreateManyInput | ep_cashier_transactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ep_cashier_transaction createManyAndReturn
   */
  export type ep_cashier_transactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_cashier_transaction
     */
    select?: ep_cashier_transactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ep_cashier_transaction
     */
    omit?: ep_cashier_transactionOmit<ExtArgs> | null
    /**
     * The data used to create many ep_cashier_transactions.
     */
    data: ep_cashier_transactionCreateManyInput | ep_cashier_transactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ep_cashier_transactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ep_cashier_transaction update
   */
  export type ep_cashier_transactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_cashier_transaction
     */
    select?: ep_cashier_transactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_cashier_transaction
     */
    omit?: ep_cashier_transactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ep_cashier_transactionInclude<ExtArgs> | null
    /**
     * The data needed to update a ep_cashier_transaction.
     */
    data: XOR<ep_cashier_transactionUpdateInput, ep_cashier_transactionUncheckedUpdateInput>
    /**
     * Choose, which ep_cashier_transaction to update.
     */
    where: ep_cashier_transactionWhereUniqueInput
  }

  /**
   * ep_cashier_transaction updateMany
   */
  export type ep_cashier_transactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ep_cashier_transactions.
     */
    data: XOR<ep_cashier_transactionUpdateManyMutationInput, ep_cashier_transactionUncheckedUpdateManyInput>
    /**
     * Filter which ep_cashier_transactions to update
     */
    where?: ep_cashier_transactionWhereInput
    /**
     * Limit how many ep_cashier_transactions to update.
     */
    limit?: number
  }

  /**
   * ep_cashier_transaction updateManyAndReturn
   */
  export type ep_cashier_transactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_cashier_transaction
     */
    select?: ep_cashier_transactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ep_cashier_transaction
     */
    omit?: ep_cashier_transactionOmit<ExtArgs> | null
    /**
     * The data used to update ep_cashier_transactions.
     */
    data: XOR<ep_cashier_transactionUpdateManyMutationInput, ep_cashier_transactionUncheckedUpdateManyInput>
    /**
     * Filter which ep_cashier_transactions to update
     */
    where?: ep_cashier_transactionWhereInput
    /**
     * Limit how many ep_cashier_transactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ep_cashier_transactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ep_cashier_transaction upsert
   */
  export type ep_cashier_transactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_cashier_transaction
     */
    select?: ep_cashier_transactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_cashier_transaction
     */
    omit?: ep_cashier_transactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ep_cashier_transactionInclude<ExtArgs> | null
    /**
     * The filter to search for the ep_cashier_transaction to update in case it exists.
     */
    where: ep_cashier_transactionWhereUniqueInput
    /**
     * In case the ep_cashier_transaction found by the `where` argument doesn't exist, create a new ep_cashier_transaction with this data.
     */
    create: XOR<ep_cashier_transactionCreateInput, ep_cashier_transactionUncheckedCreateInput>
    /**
     * In case the ep_cashier_transaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ep_cashier_transactionUpdateInput, ep_cashier_transactionUncheckedUpdateInput>
  }

  /**
   * ep_cashier_transaction delete
   */
  export type ep_cashier_transactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_cashier_transaction
     */
    select?: ep_cashier_transactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_cashier_transaction
     */
    omit?: ep_cashier_transactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ep_cashier_transactionInclude<ExtArgs> | null
    /**
     * Filter which ep_cashier_transaction to delete.
     */
    where: ep_cashier_transactionWhereUniqueInput
  }

  /**
   * ep_cashier_transaction deleteMany
   */
  export type ep_cashier_transactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ep_cashier_transactions to delete
     */
    where?: ep_cashier_transactionWhereInput
    /**
     * Limit how many ep_cashier_transactions to delete.
     */
    limit?: number
  }

  /**
   * ep_cashier_transaction without action
   */
  export type ep_cashier_transactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_cashier_transaction
     */
    select?: ep_cashier_transactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_cashier_transaction
     */
    omit?: ep_cashier_transactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ep_cashier_transactionInclude<ExtArgs> | null
  }


  /**
   * Model ep_notes
   */

  export type AggregateEp_notes = {
    _count: Ep_notesCountAggregateOutputType | null
    _avg: Ep_notesAvgAggregateOutputType | null
    _sum: Ep_notesSumAggregateOutputType | null
    _min: Ep_notesMinAggregateOutputType | null
    _max: Ep_notesMaxAggregateOutputType | null
  }

  export type Ep_notesAvgAggregateOutputType = {
    ep_note_id: number | null
    ep_note_user: number | null
  }

  export type Ep_notesSumAggregateOutputType = {
    ep_note_id: number | null
    ep_note_user: number | null
  }

  export type Ep_notesMinAggregateOutputType = {
    ep_note_id: number | null
    ep_note_user: number | null
    ep_note_content: string | null
    ep_note_date: Date | null
  }

  export type Ep_notesMaxAggregateOutputType = {
    ep_note_id: number | null
    ep_note_user: number | null
    ep_note_content: string | null
    ep_note_date: Date | null
  }

  export type Ep_notesCountAggregateOutputType = {
    ep_note_id: number
    ep_note_user: number
    ep_note_content: number
    ep_note_date: number
    _all: number
  }


  export type Ep_notesAvgAggregateInputType = {
    ep_note_id?: true
    ep_note_user?: true
  }

  export type Ep_notesSumAggregateInputType = {
    ep_note_id?: true
    ep_note_user?: true
  }

  export type Ep_notesMinAggregateInputType = {
    ep_note_id?: true
    ep_note_user?: true
    ep_note_content?: true
    ep_note_date?: true
  }

  export type Ep_notesMaxAggregateInputType = {
    ep_note_id?: true
    ep_note_user?: true
    ep_note_content?: true
    ep_note_date?: true
  }

  export type Ep_notesCountAggregateInputType = {
    ep_note_id?: true
    ep_note_user?: true
    ep_note_content?: true
    ep_note_date?: true
    _all?: true
  }

  export type Ep_notesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ep_notes to aggregate.
     */
    where?: ep_notesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ep_notes to fetch.
     */
    orderBy?: ep_notesOrderByWithRelationInput | ep_notesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ep_notesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ep_notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ep_notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ep_notes
    **/
    _count?: true | Ep_notesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Ep_notesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Ep_notesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Ep_notesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Ep_notesMaxAggregateInputType
  }

  export type GetEp_notesAggregateType<T extends Ep_notesAggregateArgs> = {
        [P in keyof T & keyof AggregateEp_notes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEp_notes[P]>
      : GetScalarType<T[P], AggregateEp_notes[P]>
  }




  export type ep_notesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ep_notesWhereInput
    orderBy?: ep_notesOrderByWithAggregationInput | ep_notesOrderByWithAggregationInput[]
    by: Ep_notesScalarFieldEnum[] | Ep_notesScalarFieldEnum
    having?: ep_notesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Ep_notesCountAggregateInputType | true
    _avg?: Ep_notesAvgAggregateInputType
    _sum?: Ep_notesSumAggregateInputType
    _min?: Ep_notesMinAggregateInputType
    _max?: Ep_notesMaxAggregateInputType
  }

  export type Ep_notesGroupByOutputType = {
    ep_note_id: number
    ep_note_user: number
    ep_note_content: string
    ep_note_date: Date
    _count: Ep_notesCountAggregateOutputType | null
    _avg: Ep_notesAvgAggregateOutputType | null
    _sum: Ep_notesSumAggregateOutputType | null
    _min: Ep_notesMinAggregateOutputType | null
    _max: Ep_notesMaxAggregateOutputType | null
  }

  type GetEp_notesGroupByPayload<T extends ep_notesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Ep_notesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Ep_notesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Ep_notesGroupByOutputType[P]>
            : GetScalarType<T[P], Ep_notesGroupByOutputType[P]>
        }
      >
    >


  export type ep_notesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ep_note_id?: boolean
    ep_note_user?: boolean
    ep_note_content?: boolean
    ep_note_date?: boolean
    user?: boolean | ep_usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ep_notes"]>

  export type ep_notesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ep_note_id?: boolean
    ep_note_user?: boolean
    ep_note_content?: boolean
    ep_note_date?: boolean
    user?: boolean | ep_usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ep_notes"]>

  export type ep_notesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ep_note_id?: boolean
    ep_note_user?: boolean
    ep_note_content?: boolean
    ep_note_date?: boolean
    user?: boolean | ep_usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ep_notes"]>

  export type ep_notesSelectScalar = {
    ep_note_id?: boolean
    ep_note_user?: boolean
    ep_note_content?: boolean
    ep_note_date?: boolean
  }

  export type ep_notesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"ep_note_id" | "ep_note_user" | "ep_note_content" | "ep_note_date", ExtArgs["result"]["ep_notes"]>
  export type ep_notesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | ep_usersDefaultArgs<ExtArgs>
  }
  export type ep_notesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | ep_usersDefaultArgs<ExtArgs>
  }
  export type ep_notesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | ep_usersDefaultArgs<ExtArgs>
  }

  export type $ep_notesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ep_notes"
    objects: {
      user: Prisma.$ep_usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      ep_note_id: number
      ep_note_user: number
      ep_note_content: string
      ep_note_date: Date
    }, ExtArgs["result"]["ep_notes"]>
    composites: {}
  }

  type ep_notesGetPayload<S extends boolean | null | undefined | ep_notesDefaultArgs> = $Result.GetResult<Prisma.$ep_notesPayload, S>

  type ep_notesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ep_notesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Ep_notesCountAggregateInputType | true
    }

  export interface ep_notesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ep_notes'], meta: { name: 'ep_notes' } }
    /**
     * Find zero or one Ep_notes that matches the filter.
     * @param {ep_notesFindUniqueArgs} args - Arguments to find a Ep_notes
     * @example
     * // Get one Ep_notes
     * const ep_notes = await prisma.ep_notes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ep_notesFindUniqueArgs>(args: SelectSubset<T, ep_notesFindUniqueArgs<ExtArgs>>): Prisma__ep_notesClient<$Result.GetResult<Prisma.$ep_notesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ep_notes that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ep_notesFindUniqueOrThrowArgs} args - Arguments to find a Ep_notes
     * @example
     * // Get one Ep_notes
     * const ep_notes = await prisma.ep_notes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ep_notesFindUniqueOrThrowArgs>(args: SelectSubset<T, ep_notesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ep_notesClient<$Result.GetResult<Prisma.$ep_notesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ep_notes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ep_notesFindFirstArgs} args - Arguments to find a Ep_notes
     * @example
     * // Get one Ep_notes
     * const ep_notes = await prisma.ep_notes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ep_notesFindFirstArgs>(args?: SelectSubset<T, ep_notesFindFirstArgs<ExtArgs>>): Prisma__ep_notesClient<$Result.GetResult<Prisma.$ep_notesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ep_notes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ep_notesFindFirstOrThrowArgs} args - Arguments to find a Ep_notes
     * @example
     * // Get one Ep_notes
     * const ep_notes = await prisma.ep_notes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ep_notesFindFirstOrThrowArgs>(args?: SelectSubset<T, ep_notesFindFirstOrThrowArgs<ExtArgs>>): Prisma__ep_notesClient<$Result.GetResult<Prisma.$ep_notesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ep_notes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ep_notesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ep_notes
     * const ep_notes = await prisma.ep_notes.findMany()
     * 
     * // Get first 10 Ep_notes
     * const ep_notes = await prisma.ep_notes.findMany({ take: 10 })
     * 
     * // Only select the `ep_note_id`
     * const ep_notesWithEp_note_idOnly = await prisma.ep_notes.findMany({ select: { ep_note_id: true } })
     * 
     */
    findMany<T extends ep_notesFindManyArgs>(args?: SelectSubset<T, ep_notesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ep_notesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ep_notes.
     * @param {ep_notesCreateArgs} args - Arguments to create a Ep_notes.
     * @example
     * // Create one Ep_notes
     * const Ep_notes = await prisma.ep_notes.create({
     *   data: {
     *     // ... data to create a Ep_notes
     *   }
     * })
     * 
     */
    create<T extends ep_notesCreateArgs>(args: SelectSubset<T, ep_notesCreateArgs<ExtArgs>>): Prisma__ep_notesClient<$Result.GetResult<Prisma.$ep_notesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ep_notes.
     * @param {ep_notesCreateManyArgs} args - Arguments to create many Ep_notes.
     * @example
     * // Create many Ep_notes
     * const ep_notes = await prisma.ep_notes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ep_notesCreateManyArgs>(args?: SelectSubset<T, ep_notesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ep_notes and returns the data saved in the database.
     * @param {ep_notesCreateManyAndReturnArgs} args - Arguments to create many Ep_notes.
     * @example
     * // Create many Ep_notes
     * const ep_notes = await prisma.ep_notes.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ep_notes and only return the `ep_note_id`
     * const ep_notesWithEp_note_idOnly = await prisma.ep_notes.createManyAndReturn({
     *   select: { ep_note_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ep_notesCreateManyAndReturnArgs>(args?: SelectSubset<T, ep_notesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ep_notesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Ep_notes.
     * @param {ep_notesDeleteArgs} args - Arguments to delete one Ep_notes.
     * @example
     * // Delete one Ep_notes
     * const Ep_notes = await prisma.ep_notes.delete({
     *   where: {
     *     // ... filter to delete one Ep_notes
     *   }
     * })
     * 
     */
    delete<T extends ep_notesDeleteArgs>(args: SelectSubset<T, ep_notesDeleteArgs<ExtArgs>>): Prisma__ep_notesClient<$Result.GetResult<Prisma.$ep_notesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ep_notes.
     * @param {ep_notesUpdateArgs} args - Arguments to update one Ep_notes.
     * @example
     * // Update one Ep_notes
     * const ep_notes = await prisma.ep_notes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ep_notesUpdateArgs>(args: SelectSubset<T, ep_notesUpdateArgs<ExtArgs>>): Prisma__ep_notesClient<$Result.GetResult<Prisma.$ep_notesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ep_notes.
     * @param {ep_notesDeleteManyArgs} args - Arguments to filter Ep_notes to delete.
     * @example
     * // Delete a few Ep_notes
     * const { count } = await prisma.ep_notes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ep_notesDeleteManyArgs>(args?: SelectSubset<T, ep_notesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ep_notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ep_notesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ep_notes
     * const ep_notes = await prisma.ep_notes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ep_notesUpdateManyArgs>(args: SelectSubset<T, ep_notesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ep_notes and returns the data updated in the database.
     * @param {ep_notesUpdateManyAndReturnArgs} args - Arguments to update many Ep_notes.
     * @example
     * // Update many Ep_notes
     * const ep_notes = await prisma.ep_notes.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Ep_notes and only return the `ep_note_id`
     * const ep_notesWithEp_note_idOnly = await prisma.ep_notes.updateManyAndReturn({
     *   select: { ep_note_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ep_notesUpdateManyAndReturnArgs>(args: SelectSubset<T, ep_notesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ep_notesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Ep_notes.
     * @param {ep_notesUpsertArgs} args - Arguments to update or create a Ep_notes.
     * @example
     * // Update or create a Ep_notes
     * const ep_notes = await prisma.ep_notes.upsert({
     *   create: {
     *     // ... data to create a Ep_notes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ep_notes we want to update
     *   }
     * })
     */
    upsert<T extends ep_notesUpsertArgs>(args: SelectSubset<T, ep_notesUpsertArgs<ExtArgs>>): Prisma__ep_notesClient<$Result.GetResult<Prisma.$ep_notesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ep_notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ep_notesCountArgs} args - Arguments to filter Ep_notes to count.
     * @example
     * // Count the number of Ep_notes
     * const count = await prisma.ep_notes.count({
     *   where: {
     *     // ... the filter for the Ep_notes we want to count
     *   }
     * })
    **/
    count<T extends ep_notesCountArgs>(
      args?: Subset<T, ep_notesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Ep_notesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ep_notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ep_notesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Ep_notesAggregateArgs>(args: Subset<T, Ep_notesAggregateArgs>): Prisma.PrismaPromise<GetEp_notesAggregateType<T>>

    /**
     * Group by Ep_notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ep_notesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ep_notesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ep_notesGroupByArgs['orderBy'] }
        : { orderBy?: ep_notesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ep_notesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEp_notesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ep_notes model
   */
  readonly fields: ep_notesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ep_notes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ep_notesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends ep_usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ep_usersDefaultArgs<ExtArgs>>): Prisma__ep_usersClient<$Result.GetResult<Prisma.$ep_usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ep_notes model
   */ 
  interface ep_notesFieldRefs {
    readonly ep_note_id: FieldRef<"ep_notes", 'Int'>
    readonly ep_note_user: FieldRef<"ep_notes", 'Int'>
    readonly ep_note_content: FieldRef<"ep_notes", 'String'>
    readonly ep_note_date: FieldRef<"ep_notes", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ep_notes findUnique
   */
  export type ep_notesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_notes
     */
    select?: ep_notesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_notes
     */
    omit?: ep_notesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ep_notesInclude<ExtArgs> | null
    /**
     * Filter, which ep_notes to fetch.
     */
    where: ep_notesWhereUniqueInput
  }

  /**
   * ep_notes findUniqueOrThrow
   */
  export type ep_notesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_notes
     */
    select?: ep_notesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_notes
     */
    omit?: ep_notesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ep_notesInclude<ExtArgs> | null
    /**
     * Filter, which ep_notes to fetch.
     */
    where: ep_notesWhereUniqueInput
  }

  /**
   * ep_notes findFirst
   */
  export type ep_notesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_notes
     */
    select?: ep_notesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_notes
     */
    omit?: ep_notesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ep_notesInclude<ExtArgs> | null
    /**
     * Filter, which ep_notes to fetch.
     */
    where?: ep_notesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ep_notes to fetch.
     */
    orderBy?: ep_notesOrderByWithRelationInput | ep_notesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ep_notes.
     */
    cursor?: ep_notesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ep_notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ep_notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ep_notes.
     */
    distinct?: Ep_notesScalarFieldEnum | Ep_notesScalarFieldEnum[]
  }

  /**
   * ep_notes findFirstOrThrow
   */
  export type ep_notesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_notes
     */
    select?: ep_notesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_notes
     */
    omit?: ep_notesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ep_notesInclude<ExtArgs> | null
    /**
     * Filter, which ep_notes to fetch.
     */
    where?: ep_notesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ep_notes to fetch.
     */
    orderBy?: ep_notesOrderByWithRelationInput | ep_notesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ep_notes.
     */
    cursor?: ep_notesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ep_notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ep_notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ep_notes.
     */
    distinct?: Ep_notesScalarFieldEnum | Ep_notesScalarFieldEnum[]
  }

  /**
   * ep_notes findMany
   */
  export type ep_notesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_notes
     */
    select?: ep_notesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_notes
     */
    omit?: ep_notesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ep_notesInclude<ExtArgs> | null
    /**
     * Filter, which ep_notes to fetch.
     */
    where?: ep_notesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ep_notes to fetch.
     */
    orderBy?: ep_notesOrderByWithRelationInput | ep_notesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ep_notes.
     */
    cursor?: ep_notesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ep_notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ep_notes.
     */
    skip?: number
    distinct?: Ep_notesScalarFieldEnum | Ep_notesScalarFieldEnum[]
  }

  /**
   * ep_notes create
   */
  export type ep_notesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_notes
     */
    select?: ep_notesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_notes
     */
    omit?: ep_notesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ep_notesInclude<ExtArgs> | null
    /**
     * The data needed to create a ep_notes.
     */
    data: XOR<ep_notesCreateInput, ep_notesUncheckedCreateInput>
  }

  /**
   * ep_notes createMany
   */
  export type ep_notesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ep_notes.
     */
    data: ep_notesCreateManyInput | ep_notesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ep_notes createManyAndReturn
   */
  export type ep_notesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_notes
     */
    select?: ep_notesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ep_notes
     */
    omit?: ep_notesOmit<ExtArgs> | null
    /**
     * The data used to create many ep_notes.
     */
    data: ep_notesCreateManyInput | ep_notesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ep_notesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ep_notes update
   */
  export type ep_notesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_notes
     */
    select?: ep_notesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_notes
     */
    omit?: ep_notesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ep_notesInclude<ExtArgs> | null
    /**
     * The data needed to update a ep_notes.
     */
    data: XOR<ep_notesUpdateInput, ep_notesUncheckedUpdateInput>
    /**
     * Choose, which ep_notes to update.
     */
    where: ep_notesWhereUniqueInput
  }

  /**
   * ep_notes updateMany
   */
  export type ep_notesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ep_notes.
     */
    data: XOR<ep_notesUpdateManyMutationInput, ep_notesUncheckedUpdateManyInput>
    /**
     * Filter which ep_notes to update
     */
    where?: ep_notesWhereInput
    /**
     * Limit how many ep_notes to update.
     */
    limit?: number
  }

  /**
   * ep_notes updateManyAndReturn
   */
  export type ep_notesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_notes
     */
    select?: ep_notesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ep_notes
     */
    omit?: ep_notesOmit<ExtArgs> | null
    /**
     * The data used to update ep_notes.
     */
    data: XOR<ep_notesUpdateManyMutationInput, ep_notesUncheckedUpdateManyInput>
    /**
     * Filter which ep_notes to update
     */
    where?: ep_notesWhereInput
    /**
     * Limit how many ep_notes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ep_notesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ep_notes upsert
   */
  export type ep_notesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_notes
     */
    select?: ep_notesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_notes
     */
    omit?: ep_notesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ep_notesInclude<ExtArgs> | null
    /**
     * The filter to search for the ep_notes to update in case it exists.
     */
    where: ep_notesWhereUniqueInput
    /**
     * In case the ep_notes found by the `where` argument doesn't exist, create a new ep_notes with this data.
     */
    create: XOR<ep_notesCreateInput, ep_notesUncheckedCreateInput>
    /**
     * In case the ep_notes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ep_notesUpdateInput, ep_notesUncheckedUpdateInput>
  }

  /**
   * ep_notes delete
   */
  export type ep_notesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_notes
     */
    select?: ep_notesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_notes
     */
    omit?: ep_notesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ep_notesInclude<ExtArgs> | null
    /**
     * Filter which ep_notes to delete.
     */
    where: ep_notesWhereUniqueInput
  }

  /**
   * ep_notes deleteMany
   */
  export type ep_notesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ep_notes to delete
     */
    where?: ep_notesWhereInput
    /**
     * Limit how many ep_notes to delete.
     */
    limit?: number
  }

  /**
   * ep_notes without action
   */
  export type ep_notesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ep_notes
     */
    select?: ep_notesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ep_notes
     */
    omit?: ep_notesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ep_notesInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const Ep_clientsScalarFieldEnum: {
    cli_id: 'cli_id',
    cli_name: 'cli_name',
    cli_lastname: 'cli_lastname',
    cli_ced: 'cli_ced',
    cli_email: 'cli_email',
    cli_version: 'cli_version'
  };

  export type Ep_clientsScalarFieldEnum = (typeof Ep_clientsScalarFieldEnum)[keyof typeof Ep_clientsScalarFieldEnum]


  export const Ep_informartionScalarFieldEnum: {
    info_id: 'info_id',
    info_name: 'info_name',
    info_location: 'info_location',
    info_spaces: 'info_spaces',
    info_version: 'info_version',
    info_image: 'info_image',
    info_owner: 'info_owner',
    info_owner_ced: 'info_owner_ced',
    info_owner_phone: 'info_owner_phone',
    info_schedule: 'info_schedule'
  };

  export type Ep_informartionScalarFieldEnum = (typeof Ep_informartionScalarFieldEnum)[keyof typeof Ep_informartionScalarFieldEnum]


  export const Ep_packagesScalarFieldEnum: {
    pack_id: 'pack_id',
    pack_name: 'pack_name',
    pack_price: 'pack_price',
    pack_version: 'pack_version'
  };

  export type Ep_packagesScalarFieldEnum = (typeof Ep_packagesScalarFieldEnum)[keyof typeof Ep_packagesScalarFieldEnum]


  export const Ep_roleScalarFieldEnum: {
    rol_id: 'rol_id',
    rol_name: 'rol_name',
    rol_version: 'rol_version'
  };

  export type Ep_roleScalarFieldEnum = (typeof Ep_roleScalarFieldEnum)[keyof typeof Ep_roleScalarFieldEnum]


  export const Ep_serverScalarFieldEnum: {
    server_id: 'server_id',
    server_type: 'server_type',
    server_port: 'server_port',
    server_protocol: 'server_protocol',
    server_mail: 'server_mail',
    server_password: 'server_password',
    server_timeout: 'server_timeout',
    server_version: 'server_version'
  };

  export type Ep_serverScalarFieldEnum = (typeof Ep_serverScalarFieldEnum)[keyof typeof Ep_serverScalarFieldEnum]


  export const Ep_taxScalarFieldEnum: {
    tax_id: 'tax_id',
    tax_price: 'tax_price',
    tax_version: 'tax_version'
  };

  export type Ep_taxScalarFieldEnum = (typeof Ep_taxScalarFieldEnum)[keyof typeof Ep_taxScalarFieldEnum]


  export const Ep_usersScalarFieldEnum: {
    users_id: 'users_id',
    users_name: 'users_name',
    users_lastname: 'users_lastname',
    users_ced: 'users_ced',
    users_version: 'users_version',
    user_username: 'user_username',
    user_password: 'user_password',
    users_email: 'users_email'
  };

  export type Ep_usersScalarFieldEnum = (typeof Ep_usersScalarFieldEnum)[keyof typeof Ep_usersScalarFieldEnum]


  export const Ep_vehiclesScalarFieldEnum: {
    veh_id: 'veh_id',
    veh_plate: 'veh_plate',
    veh_reference: 'veh_reference',
    veh_status: 'veh_status',
    veh_owner: 'veh_owner',
    veh_color: 'veh_color',
    veh_ingress_date: 'veh_ingress_date',
    veh_egress_date: 'veh_egress_date',
    veh_tax: 'veh_tax',
    veh_version: 'veh_version'
  };

  export type Ep_vehiclesScalarFieldEnum = (typeof Ep_vehiclesScalarFieldEnum)[keyof typeof Ep_vehiclesScalarFieldEnum]


  export const Ep_cash_per_dayScalarFieldEnum: {
    cpd_id: 'cpd_id',
    cpd_amount: 'cpd_amount',
    cpd_user_id: 'cpd_user_id',
    cpd_date: 'cpd_date',
    cpd_version: 'cpd_version'
  };

  export type Ep_cash_per_dayScalarFieldEnum = (typeof Ep_cash_per_dayScalarFieldEnum)[keyof typeof Ep_cash_per_dayScalarFieldEnum]


  export const Ep_cashierScalarFieldEnum: {
    cash_id: 'cash_id',
    cash_type: 'cash_type',
    cash_amount: 'cash_amount',
    cash_date: 'cash_date',
    cash_version: 'cash_version',
    cash_movement_type: 'cash_movement_type'
  };

  export type Ep_cashierScalarFieldEnum = (typeof Ep_cashierScalarFieldEnum)[keyof typeof Ep_cashierScalarFieldEnum]


  export const Ep_cashier_transactionScalarFieldEnum: {
    cash_trans_id: 'cash_trans_id',
    cash_trans_amount: 'cash_trans_amount',
    cash_trans_type: 'cash_trans_type',
    cash_trans_method: 'cash_trans_method',
    cash_trans_date: 'cash_trans_date',
    cash_trans_cashier_id: 'cash_trans_cashier_id'
  };

  export type Ep_cashier_transactionScalarFieldEnum = (typeof Ep_cashier_transactionScalarFieldEnum)[keyof typeof Ep_cashier_transactionScalarFieldEnum]


  export const Ep_notesScalarFieldEnum: {
    ep_note_id: 'ep_note_id',
    ep_note_user: 'ep_note_user',
    ep_note_content: 'ep_note_content',
    ep_note_date: 'ep_note_date'
  };

  export type Ep_notesScalarFieldEnum = (typeof Ep_notesScalarFieldEnum)[keyof typeof Ep_notesScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Bytes'
   */
  export type BytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes'>
    


  /**
   * Reference to a field of type 'Bytes[]'
   */
  export type ListBytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type ep_clientsWhereInput = {
    AND?: ep_clientsWhereInput | ep_clientsWhereInput[]
    OR?: ep_clientsWhereInput[]
    NOT?: ep_clientsWhereInput | ep_clientsWhereInput[]
    cli_id?: IntFilter<"ep_clients"> | number
    cli_name?: StringNullableFilter<"ep_clients"> | string | null
    cli_lastname?: StringFilter<"ep_clients"> | string
    cli_ced?: StringFilter<"ep_clients"> | string
    cli_email?: StringNullableFilter<"ep_clients"> | string | null
    cli_version?: IntFilter<"ep_clients"> | number
  }

  export type ep_clientsOrderByWithRelationInput = {
    cli_id?: SortOrder
    cli_name?: SortOrderInput | SortOrder
    cli_lastname?: SortOrder
    cli_ced?: SortOrder
    cli_email?: SortOrderInput | SortOrder
    cli_version?: SortOrder
  }

  export type ep_clientsWhereUniqueInput = Prisma.AtLeast<{
    cli_id?: number
    AND?: ep_clientsWhereInput | ep_clientsWhereInput[]
    OR?: ep_clientsWhereInput[]
    NOT?: ep_clientsWhereInput | ep_clientsWhereInput[]
    cli_name?: StringNullableFilter<"ep_clients"> | string | null
    cli_lastname?: StringFilter<"ep_clients"> | string
    cli_ced?: StringFilter<"ep_clients"> | string
    cli_email?: StringNullableFilter<"ep_clients"> | string | null
    cli_version?: IntFilter<"ep_clients"> | number
  }, "cli_id">

  export type ep_clientsOrderByWithAggregationInput = {
    cli_id?: SortOrder
    cli_name?: SortOrderInput | SortOrder
    cli_lastname?: SortOrder
    cli_ced?: SortOrder
    cli_email?: SortOrderInput | SortOrder
    cli_version?: SortOrder
    _count?: ep_clientsCountOrderByAggregateInput
    _avg?: ep_clientsAvgOrderByAggregateInput
    _max?: ep_clientsMaxOrderByAggregateInput
    _min?: ep_clientsMinOrderByAggregateInput
    _sum?: ep_clientsSumOrderByAggregateInput
  }

  export type ep_clientsScalarWhereWithAggregatesInput = {
    AND?: ep_clientsScalarWhereWithAggregatesInput | ep_clientsScalarWhereWithAggregatesInput[]
    OR?: ep_clientsScalarWhereWithAggregatesInput[]
    NOT?: ep_clientsScalarWhereWithAggregatesInput | ep_clientsScalarWhereWithAggregatesInput[]
    cli_id?: IntWithAggregatesFilter<"ep_clients"> | number
    cli_name?: StringNullableWithAggregatesFilter<"ep_clients"> | string | null
    cli_lastname?: StringWithAggregatesFilter<"ep_clients"> | string
    cli_ced?: StringWithAggregatesFilter<"ep_clients"> | string
    cli_email?: StringNullableWithAggregatesFilter<"ep_clients"> | string | null
    cli_version?: IntWithAggregatesFilter<"ep_clients"> | number
  }

  export type ep_informartionWhereInput = {
    AND?: ep_informartionWhereInput | ep_informartionWhereInput[]
    OR?: ep_informartionWhereInput[]
    NOT?: ep_informartionWhereInput | ep_informartionWhereInput[]
    info_id?: IntFilter<"ep_informartion"> | number
    info_name?: StringFilter<"ep_informartion"> | string
    info_location?: StringFilter<"ep_informartion"> | string
    info_spaces?: IntFilter<"ep_informartion"> | number
    info_version?: IntFilter<"ep_informartion"> | number
    info_image?: BytesFilter<"ep_informartion"> | Uint8Array
    info_owner?: StringFilter<"ep_informartion"> | string
    info_owner_ced?: StringFilter<"ep_informartion"> | string
    info_owner_phone?: StringFilter<"ep_informartion"> | string
    info_schedule?: StringFilter<"ep_informartion"> | string
  }

  export type ep_informartionOrderByWithRelationInput = {
    info_id?: SortOrder
    info_name?: SortOrder
    info_location?: SortOrder
    info_spaces?: SortOrder
    info_version?: SortOrder
    info_image?: SortOrder
    info_owner?: SortOrder
    info_owner_ced?: SortOrder
    info_owner_phone?: SortOrder
    info_schedule?: SortOrder
  }

  export type ep_informartionWhereUniqueInput = Prisma.AtLeast<{
    info_id?: number
    AND?: ep_informartionWhereInput | ep_informartionWhereInput[]
    OR?: ep_informartionWhereInput[]
    NOT?: ep_informartionWhereInput | ep_informartionWhereInput[]
    info_name?: StringFilter<"ep_informartion"> | string
    info_location?: StringFilter<"ep_informartion"> | string
    info_spaces?: IntFilter<"ep_informartion"> | number
    info_version?: IntFilter<"ep_informartion"> | number
    info_image?: BytesFilter<"ep_informartion"> | Uint8Array
    info_owner?: StringFilter<"ep_informartion"> | string
    info_owner_ced?: StringFilter<"ep_informartion"> | string
    info_owner_phone?: StringFilter<"ep_informartion"> | string
    info_schedule?: StringFilter<"ep_informartion"> | string
  }, "info_id">

  export type ep_informartionOrderByWithAggregationInput = {
    info_id?: SortOrder
    info_name?: SortOrder
    info_location?: SortOrder
    info_spaces?: SortOrder
    info_version?: SortOrder
    info_image?: SortOrder
    info_owner?: SortOrder
    info_owner_ced?: SortOrder
    info_owner_phone?: SortOrder
    info_schedule?: SortOrder
    _count?: ep_informartionCountOrderByAggregateInput
    _avg?: ep_informartionAvgOrderByAggregateInput
    _max?: ep_informartionMaxOrderByAggregateInput
    _min?: ep_informartionMinOrderByAggregateInput
    _sum?: ep_informartionSumOrderByAggregateInput
  }

  export type ep_informartionScalarWhereWithAggregatesInput = {
    AND?: ep_informartionScalarWhereWithAggregatesInput | ep_informartionScalarWhereWithAggregatesInput[]
    OR?: ep_informartionScalarWhereWithAggregatesInput[]
    NOT?: ep_informartionScalarWhereWithAggregatesInput | ep_informartionScalarWhereWithAggregatesInput[]
    info_id?: IntWithAggregatesFilter<"ep_informartion"> | number
    info_name?: StringWithAggregatesFilter<"ep_informartion"> | string
    info_location?: StringWithAggregatesFilter<"ep_informartion"> | string
    info_spaces?: IntWithAggregatesFilter<"ep_informartion"> | number
    info_version?: IntWithAggregatesFilter<"ep_informartion"> | number
    info_image?: BytesWithAggregatesFilter<"ep_informartion"> | Uint8Array
    info_owner?: StringWithAggregatesFilter<"ep_informartion"> | string
    info_owner_ced?: StringWithAggregatesFilter<"ep_informartion"> | string
    info_owner_phone?: StringWithAggregatesFilter<"ep_informartion"> | string
    info_schedule?: StringWithAggregatesFilter<"ep_informartion"> | string
  }

  export type ep_packagesWhereInput = {
    AND?: ep_packagesWhereInput | ep_packagesWhereInput[]
    OR?: ep_packagesWhereInput[]
    NOT?: ep_packagesWhereInput | ep_packagesWhereInput[]
    pack_id?: IntFilter<"ep_packages"> | number
    pack_name?: StringFilter<"ep_packages"> | string
    pack_price?: IntFilter<"ep_packages"> | number
    pack_version?: IntFilter<"ep_packages"> | number
  }

  export type ep_packagesOrderByWithRelationInput = {
    pack_id?: SortOrder
    pack_name?: SortOrder
    pack_price?: SortOrder
    pack_version?: SortOrder
  }

  export type ep_packagesWhereUniqueInput = Prisma.AtLeast<{
    pack_id?: number
    AND?: ep_packagesWhereInput | ep_packagesWhereInput[]
    OR?: ep_packagesWhereInput[]
    NOT?: ep_packagesWhereInput | ep_packagesWhereInput[]
    pack_name?: StringFilter<"ep_packages"> | string
    pack_price?: IntFilter<"ep_packages"> | number
    pack_version?: IntFilter<"ep_packages"> | number
  }, "pack_id">

  export type ep_packagesOrderByWithAggregationInput = {
    pack_id?: SortOrder
    pack_name?: SortOrder
    pack_price?: SortOrder
    pack_version?: SortOrder
    _count?: ep_packagesCountOrderByAggregateInput
    _avg?: ep_packagesAvgOrderByAggregateInput
    _max?: ep_packagesMaxOrderByAggregateInput
    _min?: ep_packagesMinOrderByAggregateInput
    _sum?: ep_packagesSumOrderByAggregateInput
  }

  export type ep_packagesScalarWhereWithAggregatesInput = {
    AND?: ep_packagesScalarWhereWithAggregatesInput | ep_packagesScalarWhereWithAggregatesInput[]
    OR?: ep_packagesScalarWhereWithAggregatesInput[]
    NOT?: ep_packagesScalarWhereWithAggregatesInput | ep_packagesScalarWhereWithAggregatesInput[]
    pack_id?: IntWithAggregatesFilter<"ep_packages"> | number
    pack_name?: StringWithAggregatesFilter<"ep_packages"> | string
    pack_price?: IntWithAggregatesFilter<"ep_packages"> | number
    pack_version?: IntWithAggregatesFilter<"ep_packages"> | number
  }

  export type ep_roleWhereInput = {
    AND?: ep_roleWhereInput | ep_roleWhereInput[]
    OR?: ep_roleWhereInput[]
    NOT?: ep_roleWhereInput | ep_roleWhereInput[]
    rol_id?: IntFilter<"ep_role"> | number
    rol_name?: StringFilter<"ep_role"> | string
    rol_version?: IntFilter<"ep_role"> | number
  }

  export type ep_roleOrderByWithRelationInput = {
    rol_id?: SortOrder
    rol_name?: SortOrder
    rol_version?: SortOrder
  }

  export type ep_roleWhereUniqueInput = Prisma.AtLeast<{
    rol_id?: number
    AND?: ep_roleWhereInput | ep_roleWhereInput[]
    OR?: ep_roleWhereInput[]
    NOT?: ep_roleWhereInput | ep_roleWhereInput[]
    rol_name?: StringFilter<"ep_role"> | string
    rol_version?: IntFilter<"ep_role"> | number
  }, "rol_id">

  export type ep_roleOrderByWithAggregationInput = {
    rol_id?: SortOrder
    rol_name?: SortOrder
    rol_version?: SortOrder
    _count?: ep_roleCountOrderByAggregateInput
    _avg?: ep_roleAvgOrderByAggregateInput
    _max?: ep_roleMaxOrderByAggregateInput
    _min?: ep_roleMinOrderByAggregateInput
    _sum?: ep_roleSumOrderByAggregateInput
  }

  export type ep_roleScalarWhereWithAggregatesInput = {
    AND?: ep_roleScalarWhereWithAggregatesInput | ep_roleScalarWhereWithAggregatesInput[]
    OR?: ep_roleScalarWhereWithAggregatesInput[]
    NOT?: ep_roleScalarWhereWithAggregatesInput | ep_roleScalarWhereWithAggregatesInput[]
    rol_id?: IntWithAggregatesFilter<"ep_role"> | number
    rol_name?: StringWithAggregatesFilter<"ep_role"> | string
    rol_version?: IntWithAggregatesFilter<"ep_role"> | number
  }

  export type ep_serverWhereInput = {
    AND?: ep_serverWhereInput | ep_serverWhereInput[]
    OR?: ep_serverWhereInput[]
    NOT?: ep_serverWhereInput | ep_serverWhereInput[]
    server_id?: IntFilter<"ep_server"> | number
    server_type?: StringFilter<"ep_server"> | string
    server_port?: StringFilter<"ep_server"> | string
    server_protocol?: StringFilter<"ep_server"> | string
    server_mail?: StringFilter<"ep_server"> | string
    server_password?: StringFilter<"ep_server"> | string
    server_timeout?: IntFilter<"ep_server"> | number
    server_version?: IntFilter<"ep_server"> | number
  }

  export type ep_serverOrderByWithRelationInput = {
    server_id?: SortOrder
    server_type?: SortOrder
    server_port?: SortOrder
    server_protocol?: SortOrder
    server_mail?: SortOrder
    server_password?: SortOrder
    server_timeout?: SortOrder
    server_version?: SortOrder
  }

  export type ep_serverWhereUniqueInput = Prisma.AtLeast<{
    server_id?: number
    AND?: ep_serverWhereInput | ep_serverWhereInput[]
    OR?: ep_serverWhereInput[]
    NOT?: ep_serverWhereInput | ep_serverWhereInput[]
    server_type?: StringFilter<"ep_server"> | string
    server_port?: StringFilter<"ep_server"> | string
    server_protocol?: StringFilter<"ep_server"> | string
    server_mail?: StringFilter<"ep_server"> | string
    server_password?: StringFilter<"ep_server"> | string
    server_timeout?: IntFilter<"ep_server"> | number
    server_version?: IntFilter<"ep_server"> | number
  }, "server_id">

  export type ep_serverOrderByWithAggregationInput = {
    server_id?: SortOrder
    server_type?: SortOrder
    server_port?: SortOrder
    server_protocol?: SortOrder
    server_mail?: SortOrder
    server_password?: SortOrder
    server_timeout?: SortOrder
    server_version?: SortOrder
    _count?: ep_serverCountOrderByAggregateInput
    _avg?: ep_serverAvgOrderByAggregateInput
    _max?: ep_serverMaxOrderByAggregateInput
    _min?: ep_serverMinOrderByAggregateInput
    _sum?: ep_serverSumOrderByAggregateInput
  }

  export type ep_serverScalarWhereWithAggregatesInput = {
    AND?: ep_serverScalarWhereWithAggregatesInput | ep_serverScalarWhereWithAggregatesInput[]
    OR?: ep_serverScalarWhereWithAggregatesInput[]
    NOT?: ep_serverScalarWhereWithAggregatesInput | ep_serverScalarWhereWithAggregatesInput[]
    server_id?: IntWithAggregatesFilter<"ep_server"> | number
    server_type?: StringWithAggregatesFilter<"ep_server"> | string
    server_port?: StringWithAggregatesFilter<"ep_server"> | string
    server_protocol?: StringWithAggregatesFilter<"ep_server"> | string
    server_mail?: StringWithAggregatesFilter<"ep_server"> | string
    server_password?: StringWithAggregatesFilter<"ep_server"> | string
    server_timeout?: IntWithAggregatesFilter<"ep_server"> | number
    server_version?: IntWithAggregatesFilter<"ep_server"> | number
  }

  export type ep_taxWhereInput = {
    AND?: ep_taxWhereInput | ep_taxWhereInput[]
    OR?: ep_taxWhereInput[]
    NOT?: ep_taxWhereInput | ep_taxWhereInput[]
    tax_id?: IntFilter<"ep_tax"> | number
    tax_price?: IntFilter<"ep_tax"> | number
    tax_version?: IntFilter<"ep_tax"> | number
  }

  export type ep_taxOrderByWithRelationInput = {
    tax_id?: SortOrder
    tax_price?: SortOrder
    tax_version?: SortOrder
  }

  export type ep_taxWhereUniqueInput = Prisma.AtLeast<{
    tax_id?: number
    AND?: ep_taxWhereInput | ep_taxWhereInput[]
    OR?: ep_taxWhereInput[]
    NOT?: ep_taxWhereInput | ep_taxWhereInput[]
    tax_price?: IntFilter<"ep_tax"> | number
    tax_version?: IntFilter<"ep_tax"> | number
  }, "tax_id">

  export type ep_taxOrderByWithAggregationInput = {
    tax_id?: SortOrder
    tax_price?: SortOrder
    tax_version?: SortOrder
    _count?: ep_taxCountOrderByAggregateInput
    _avg?: ep_taxAvgOrderByAggregateInput
    _max?: ep_taxMaxOrderByAggregateInput
    _min?: ep_taxMinOrderByAggregateInput
    _sum?: ep_taxSumOrderByAggregateInput
  }

  export type ep_taxScalarWhereWithAggregatesInput = {
    AND?: ep_taxScalarWhereWithAggregatesInput | ep_taxScalarWhereWithAggregatesInput[]
    OR?: ep_taxScalarWhereWithAggregatesInput[]
    NOT?: ep_taxScalarWhereWithAggregatesInput | ep_taxScalarWhereWithAggregatesInput[]
    tax_id?: IntWithAggregatesFilter<"ep_tax"> | number
    tax_price?: IntWithAggregatesFilter<"ep_tax"> | number
    tax_version?: IntWithAggregatesFilter<"ep_tax"> | number
  }

  export type ep_usersWhereInput = {
    AND?: ep_usersWhereInput | ep_usersWhereInput[]
    OR?: ep_usersWhereInput[]
    NOT?: ep_usersWhereInput | ep_usersWhereInput[]
    users_id?: IntFilter<"ep_users"> | number
    users_name?: StringFilter<"ep_users"> | string
    users_lastname?: StringFilter<"ep_users"> | string
    users_ced?: StringFilter<"ep_users"> | string
    users_version?: IntFilter<"ep_users"> | number
    user_username?: StringFilter<"ep_users"> | string
    user_password?: StringFilter<"ep_users"> | string
    users_email?: StringFilter<"ep_users"> | string
    ep_cash_per_day?: Ep_cash_per_dayListRelationFilter
    notes?: Ep_notesListRelationFilter
  }

  export type ep_usersOrderByWithRelationInput = {
    users_id?: SortOrder
    users_name?: SortOrder
    users_lastname?: SortOrder
    users_ced?: SortOrder
    users_version?: SortOrder
    user_username?: SortOrder
    user_password?: SortOrder
    users_email?: SortOrder
    ep_cash_per_day?: ep_cash_per_dayOrderByRelationAggregateInput
    notes?: ep_notesOrderByRelationAggregateInput
  }

  export type ep_usersWhereUniqueInput = Prisma.AtLeast<{
    users_id?: number
    AND?: ep_usersWhereInput | ep_usersWhereInput[]
    OR?: ep_usersWhereInput[]
    NOT?: ep_usersWhereInput | ep_usersWhereInput[]
    users_name?: StringFilter<"ep_users"> | string
    users_lastname?: StringFilter<"ep_users"> | string
    users_ced?: StringFilter<"ep_users"> | string
    users_version?: IntFilter<"ep_users"> | number
    user_username?: StringFilter<"ep_users"> | string
    user_password?: StringFilter<"ep_users"> | string
    users_email?: StringFilter<"ep_users"> | string
    ep_cash_per_day?: Ep_cash_per_dayListRelationFilter
    notes?: Ep_notesListRelationFilter
  }, "users_id">

  export type ep_usersOrderByWithAggregationInput = {
    users_id?: SortOrder
    users_name?: SortOrder
    users_lastname?: SortOrder
    users_ced?: SortOrder
    users_version?: SortOrder
    user_username?: SortOrder
    user_password?: SortOrder
    users_email?: SortOrder
    _count?: ep_usersCountOrderByAggregateInput
    _avg?: ep_usersAvgOrderByAggregateInput
    _max?: ep_usersMaxOrderByAggregateInput
    _min?: ep_usersMinOrderByAggregateInput
    _sum?: ep_usersSumOrderByAggregateInput
  }

  export type ep_usersScalarWhereWithAggregatesInput = {
    AND?: ep_usersScalarWhereWithAggregatesInput | ep_usersScalarWhereWithAggregatesInput[]
    OR?: ep_usersScalarWhereWithAggregatesInput[]
    NOT?: ep_usersScalarWhereWithAggregatesInput | ep_usersScalarWhereWithAggregatesInput[]
    users_id?: IntWithAggregatesFilter<"ep_users"> | number
    users_name?: StringWithAggregatesFilter<"ep_users"> | string
    users_lastname?: StringWithAggregatesFilter<"ep_users"> | string
    users_ced?: StringWithAggregatesFilter<"ep_users"> | string
    users_version?: IntWithAggregatesFilter<"ep_users"> | number
    user_username?: StringWithAggregatesFilter<"ep_users"> | string
    user_password?: StringWithAggregatesFilter<"ep_users"> | string
    users_email?: StringWithAggregatesFilter<"ep_users"> | string
  }

  export type ep_vehiclesWhereInput = {
    AND?: ep_vehiclesWhereInput | ep_vehiclesWhereInput[]
    OR?: ep_vehiclesWhereInput[]
    NOT?: ep_vehiclesWhereInput | ep_vehiclesWhereInput[]
    veh_id?: IntFilter<"ep_vehicles"> | number
    veh_plate?: StringFilter<"ep_vehicles"> | string
    veh_reference?: StringFilter<"ep_vehicles"> | string
    veh_status?: StringNullableFilter<"ep_vehicles"> | string | null
    veh_owner?: StringFilter<"ep_vehicles"> | string
    veh_color?: StringNullableFilter<"ep_vehicles"> | string | null
    veh_ingress_date?: DateTimeFilter<"ep_vehicles"> | Date | string
    veh_egress_date?: DateTimeNullableFilter<"ep_vehicles"> | Date | string | null
    veh_tax?: StringFilter<"ep_vehicles"> | string
    veh_version?: IntFilter<"ep_vehicles"> | number
  }

  export type ep_vehiclesOrderByWithRelationInput = {
    veh_id?: SortOrder
    veh_plate?: SortOrder
    veh_reference?: SortOrder
    veh_status?: SortOrderInput | SortOrder
    veh_owner?: SortOrder
    veh_color?: SortOrderInput | SortOrder
    veh_ingress_date?: SortOrder
    veh_egress_date?: SortOrderInput | SortOrder
    veh_tax?: SortOrder
    veh_version?: SortOrder
  }

  export type ep_vehiclesWhereUniqueInput = Prisma.AtLeast<{
    veh_id?: number
    AND?: ep_vehiclesWhereInput | ep_vehiclesWhereInput[]
    OR?: ep_vehiclesWhereInput[]
    NOT?: ep_vehiclesWhereInput | ep_vehiclesWhereInput[]
    veh_plate?: StringFilter<"ep_vehicles"> | string
    veh_reference?: StringFilter<"ep_vehicles"> | string
    veh_status?: StringNullableFilter<"ep_vehicles"> | string | null
    veh_owner?: StringFilter<"ep_vehicles"> | string
    veh_color?: StringNullableFilter<"ep_vehicles"> | string | null
    veh_ingress_date?: DateTimeFilter<"ep_vehicles"> | Date | string
    veh_egress_date?: DateTimeNullableFilter<"ep_vehicles"> | Date | string | null
    veh_tax?: StringFilter<"ep_vehicles"> | string
    veh_version?: IntFilter<"ep_vehicles"> | number
  }, "veh_id">

  export type ep_vehiclesOrderByWithAggregationInput = {
    veh_id?: SortOrder
    veh_plate?: SortOrder
    veh_reference?: SortOrder
    veh_status?: SortOrderInput | SortOrder
    veh_owner?: SortOrder
    veh_color?: SortOrderInput | SortOrder
    veh_ingress_date?: SortOrder
    veh_egress_date?: SortOrderInput | SortOrder
    veh_tax?: SortOrder
    veh_version?: SortOrder
    _count?: ep_vehiclesCountOrderByAggregateInput
    _avg?: ep_vehiclesAvgOrderByAggregateInput
    _max?: ep_vehiclesMaxOrderByAggregateInput
    _min?: ep_vehiclesMinOrderByAggregateInput
    _sum?: ep_vehiclesSumOrderByAggregateInput
  }

  export type ep_vehiclesScalarWhereWithAggregatesInput = {
    AND?: ep_vehiclesScalarWhereWithAggregatesInput | ep_vehiclesScalarWhereWithAggregatesInput[]
    OR?: ep_vehiclesScalarWhereWithAggregatesInput[]
    NOT?: ep_vehiclesScalarWhereWithAggregatesInput | ep_vehiclesScalarWhereWithAggregatesInput[]
    veh_id?: IntWithAggregatesFilter<"ep_vehicles"> | number
    veh_plate?: StringWithAggregatesFilter<"ep_vehicles"> | string
    veh_reference?: StringWithAggregatesFilter<"ep_vehicles"> | string
    veh_status?: StringNullableWithAggregatesFilter<"ep_vehicles"> | string | null
    veh_owner?: StringWithAggregatesFilter<"ep_vehicles"> | string
    veh_color?: StringNullableWithAggregatesFilter<"ep_vehicles"> | string | null
    veh_ingress_date?: DateTimeWithAggregatesFilter<"ep_vehicles"> | Date | string
    veh_egress_date?: DateTimeNullableWithAggregatesFilter<"ep_vehicles"> | Date | string | null
    veh_tax?: StringWithAggregatesFilter<"ep_vehicles"> | string
    veh_version?: IntWithAggregatesFilter<"ep_vehicles"> | number
  }

  export type ep_cash_per_dayWhereInput = {
    AND?: ep_cash_per_dayWhereInput | ep_cash_per_dayWhereInput[]
    OR?: ep_cash_per_dayWhereInput[]
    NOT?: ep_cash_per_dayWhereInput | ep_cash_per_dayWhereInput[]
    cpd_id?: IntFilter<"ep_cash_per_day"> | number
    cpd_amount?: DecimalFilter<"ep_cash_per_day"> | Decimal | DecimalJsLike | number | string
    cpd_user_id?: IntFilter<"ep_cash_per_day"> | number
    cpd_date?: DateTimeFilter<"ep_cash_per_day"> | Date | string
    cpd_version?: IntFilter<"ep_cash_per_day"> | number
    ep_users?: XOR<Ep_usersScalarRelationFilter, ep_usersWhereInput>
  }

  export type ep_cash_per_dayOrderByWithRelationInput = {
    cpd_id?: SortOrder
    cpd_amount?: SortOrder
    cpd_user_id?: SortOrder
    cpd_date?: SortOrder
    cpd_version?: SortOrder
    ep_users?: ep_usersOrderByWithRelationInput
  }

  export type ep_cash_per_dayWhereUniqueInput = Prisma.AtLeast<{
    cpd_id?: number
    AND?: ep_cash_per_dayWhereInput | ep_cash_per_dayWhereInput[]
    OR?: ep_cash_per_dayWhereInput[]
    NOT?: ep_cash_per_dayWhereInput | ep_cash_per_dayWhereInput[]
    cpd_amount?: DecimalFilter<"ep_cash_per_day"> | Decimal | DecimalJsLike | number | string
    cpd_user_id?: IntFilter<"ep_cash_per_day"> | number
    cpd_date?: DateTimeFilter<"ep_cash_per_day"> | Date | string
    cpd_version?: IntFilter<"ep_cash_per_day"> | number
    ep_users?: XOR<Ep_usersScalarRelationFilter, ep_usersWhereInput>
  }, "cpd_id">

  export type ep_cash_per_dayOrderByWithAggregationInput = {
    cpd_id?: SortOrder
    cpd_amount?: SortOrder
    cpd_user_id?: SortOrder
    cpd_date?: SortOrder
    cpd_version?: SortOrder
    _count?: ep_cash_per_dayCountOrderByAggregateInput
    _avg?: ep_cash_per_dayAvgOrderByAggregateInput
    _max?: ep_cash_per_dayMaxOrderByAggregateInput
    _min?: ep_cash_per_dayMinOrderByAggregateInput
    _sum?: ep_cash_per_daySumOrderByAggregateInput
  }

  export type ep_cash_per_dayScalarWhereWithAggregatesInput = {
    AND?: ep_cash_per_dayScalarWhereWithAggregatesInput | ep_cash_per_dayScalarWhereWithAggregatesInput[]
    OR?: ep_cash_per_dayScalarWhereWithAggregatesInput[]
    NOT?: ep_cash_per_dayScalarWhereWithAggregatesInput | ep_cash_per_dayScalarWhereWithAggregatesInput[]
    cpd_id?: IntWithAggregatesFilter<"ep_cash_per_day"> | number
    cpd_amount?: DecimalWithAggregatesFilter<"ep_cash_per_day"> | Decimal | DecimalJsLike | number | string
    cpd_user_id?: IntWithAggregatesFilter<"ep_cash_per_day"> | number
    cpd_date?: DateTimeWithAggregatesFilter<"ep_cash_per_day"> | Date | string
    cpd_version?: IntWithAggregatesFilter<"ep_cash_per_day"> | number
  }

  export type ep_cashierWhereInput = {
    AND?: ep_cashierWhereInput | ep_cashierWhereInput[]
    OR?: ep_cashierWhereInput[]
    NOT?: ep_cashierWhereInput | ep_cashierWhereInput[]
    cash_id?: IntFilter<"ep_cashier"> | number
    cash_type?: StringFilter<"ep_cashier"> | string
    cash_amount?: DecimalFilter<"ep_cashier"> | Decimal | DecimalJsLike | number | string
    cash_date?: DateTimeFilter<"ep_cashier"> | Date | string
    cash_version?: IntFilter<"ep_cashier"> | number
    cash_movement_type?: StringNullableFilter<"ep_cashier"> | string | null
    transactions?: Ep_cashier_transactionListRelationFilter
  }

  export type ep_cashierOrderByWithRelationInput = {
    cash_id?: SortOrder
    cash_type?: SortOrder
    cash_amount?: SortOrder
    cash_date?: SortOrder
    cash_version?: SortOrder
    cash_movement_type?: SortOrderInput | SortOrder
    transactions?: ep_cashier_transactionOrderByRelationAggregateInput
  }

  export type ep_cashierWhereUniqueInput = Prisma.AtLeast<{
    cash_id?: number
    AND?: ep_cashierWhereInput | ep_cashierWhereInput[]
    OR?: ep_cashierWhereInput[]
    NOT?: ep_cashierWhereInput | ep_cashierWhereInput[]
    cash_type?: StringFilter<"ep_cashier"> | string
    cash_amount?: DecimalFilter<"ep_cashier"> | Decimal | DecimalJsLike | number | string
    cash_date?: DateTimeFilter<"ep_cashier"> | Date | string
    cash_version?: IntFilter<"ep_cashier"> | number
    cash_movement_type?: StringNullableFilter<"ep_cashier"> | string | null
    transactions?: Ep_cashier_transactionListRelationFilter
  }, "cash_id">

  export type ep_cashierOrderByWithAggregationInput = {
    cash_id?: SortOrder
    cash_type?: SortOrder
    cash_amount?: SortOrder
    cash_date?: SortOrder
    cash_version?: SortOrder
    cash_movement_type?: SortOrderInput | SortOrder
    _count?: ep_cashierCountOrderByAggregateInput
    _avg?: ep_cashierAvgOrderByAggregateInput
    _max?: ep_cashierMaxOrderByAggregateInput
    _min?: ep_cashierMinOrderByAggregateInput
    _sum?: ep_cashierSumOrderByAggregateInput
  }

  export type ep_cashierScalarWhereWithAggregatesInput = {
    AND?: ep_cashierScalarWhereWithAggregatesInput | ep_cashierScalarWhereWithAggregatesInput[]
    OR?: ep_cashierScalarWhereWithAggregatesInput[]
    NOT?: ep_cashierScalarWhereWithAggregatesInput | ep_cashierScalarWhereWithAggregatesInput[]
    cash_id?: IntWithAggregatesFilter<"ep_cashier"> | number
    cash_type?: StringWithAggregatesFilter<"ep_cashier"> | string
    cash_amount?: DecimalWithAggregatesFilter<"ep_cashier"> | Decimal | DecimalJsLike | number | string
    cash_date?: DateTimeWithAggregatesFilter<"ep_cashier"> | Date | string
    cash_version?: IntWithAggregatesFilter<"ep_cashier"> | number
    cash_movement_type?: StringNullableWithAggregatesFilter<"ep_cashier"> | string | null
  }

  export type ep_cashier_transactionWhereInput = {
    AND?: ep_cashier_transactionWhereInput | ep_cashier_transactionWhereInput[]
    OR?: ep_cashier_transactionWhereInput[]
    NOT?: ep_cashier_transactionWhereInput | ep_cashier_transactionWhereInput[]
    cash_trans_id?: IntFilter<"ep_cashier_transaction"> | number
    cash_trans_amount?: StringFilter<"ep_cashier_transaction"> | string
    cash_trans_type?: StringFilter<"ep_cashier_transaction"> | string
    cash_trans_method?: StringFilter<"ep_cashier_transaction"> | string
    cash_trans_date?: DateTimeFilter<"ep_cashier_transaction"> | Date | string
    cash_trans_cashier_id?: IntFilter<"ep_cashier_transaction"> | number
    cashier?: XOR<Ep_cashierScalarRelationFilter, ep_cashierWhereInput>
  }

  export type ep_cashier_transactionOrderByWithRelationInput = {
    cash_trans_id?: SortOrder
    cash_trans_amount?: SortOrder
    cash_trans_type?: SortOrder
    cash_trans_method?: SortOrder
    cash_trans_date?: SortOrder
    cash_trans_cashier_id?: SortOrder
    cashier?: ep_cashierOrderByWithRelationInput
  }

  export type ep_cashier_transactionWhereUniqueInput = Prisma.AtLeast<{
    cash_trans_id?: number
    AND?: ep_cashier_transactionWhereInput | ep_cashier_transactionWhereInput[]
    OR?: ep_cashier_transactionWhereInput[]
    NOT?: ep_cashier_transactionWhereInput | ep_cashier_transactionWhereInput[]
    cash_trans_amount?: StringFilter<"ep_cashier_transaction"> | string
    cash_trans_type?: StringFilter<"ep_cashier_transaction"> | string
    cash_trans_method?: StringFilter<"ep_cashier_transaction"> | string
    cash_trans_date?: DateTimeFilter<"ep_cashier_transaction"> | Date | string
    cash_trans_cashier_id?: IntFilter<"ep_cashier_transaction"> | number
    cashier?: XOR<Ep_cashierScalarRelationFilter, ep_cashierWhereInput>
  }, "cash_trans_id">

  export type ep_cashier_transactionOrderByWithAggregationInput = {
    cash_trans_id?: SortOrder
    cash_trans_amount?: SortOrder
    cash_trans_type?: SortOrder
    cash_trans_method?: SortOrder
    cash_trans_date?: SortOrder
    cash_trans_cashier_id?: SortOrder
    _count?: ep_cashier_transactionCountOrderByAggregateInput
    _avg?: ep_cashier_transactionAvgOrderByAggregateInput
    _max?: ep_cashier_transactionMaxOrderByAggregateInput
    _min?: ep_cashier_transactionMinOrderByAggregateInput
    _sum?: ep_cashier_transactionSumOrderByAggregateInput
  }

  export type ep_cashier_transactionScalarWhereWithAggregatesInput = {
    AND?: ep_cashier_transactionScalarWhereWithAggregatesInput | ep_cashier_transactionScalarWhereWithAggregatesInput[]
    OR?: ep_cashier_transactionScalarWhereWithAggregatesInput[]
    NOT?: ep_cashier_transactionScalarWhereWithAggregatesInput | ep_cashier_transactionScalarWhereWithAggregatesInput[]
    cash_trans_id?: IntWithAggregatesFilter<"ep_cashier_transaction"> | number
    cash_trans_amount?: StringWithAggregatesFilter<"ep_cashier_transaction"> | string
    cash_trans_type?: StringWithAggregatesFilter<"ep_cashier_transaction"> | string
    cash_trans_method?: StringWithAggregatesFilter<"ep_cashier_transaction"> | string
    cash_trans_date?: DateTimeWithAggregatesFilter<"ep_cashier_transaction"> | Date | string
    cash_trans_cashier_id?: IntWithAggregatesFilter<"ep_cashier_transaction"> | number
  }

  export type ep_notesWhereInput = {
    AND?: ep_notesWhereInput | ep_notesWhereInput[]
    OR?: ep_notesWhereInput[]
    NOT?: ep_notesWhereInput | ep_notesWhereInput[]
    ep_note_id?: IntFilter<"ep_notes"> | number
    ep_note_user?: IntFilter<"ep_notes"> | number
    ep_note_content?: StringFilter<"ep_notes"> | string
    ep_note_date?: DateTimeFilter<"ep_notes"> | Date | string
    user?: XOR<Ep_usersScalarRelationFilter, ep_usersWhereInput>
  }

  export type ep_notesOrderByWithRelationInput = {
    ep_note_id?: SortOrder
    ep_note_user?: SortOrder
    ep_note_content?: SortOrder
    ep_note_date?: SortOrder
    user?: ep_usersOrderByWithRelationInput
  }

  export type ep_notesWhereUniqueInput = Prisma.AtLeast<{
    ep_note_id?: number
    AND?: ep_notesWhereInput | ep_notesWhereInput[]
    OR?: ep_notesWhereInput[]
    NOT?: ep_notesWhereInput | ep_notesWhereInput[]
    ep_note_user?: IntFilter<"ep_notes"> | number
    ep_note_content?: StringFilter<"ep_notes"> | string
    ep_note_date?: DateTimeFilter<"ep_notes"> | Date | string
    user?: XOR<Ep_usersScalarRelationFilter, ep_usersWhereInput>
  }, "ep_note_id">

  export type ep_notesOrderByWithAggregationInput = {
    ep_note_id?: SortOrder
    ep_note_user?: SortOrder
    ep_note_content?: SortOrder
    ep_note_date?: SortOrder
    _count?: ep_notesCountOrderByAggregateInput
    _avg?: ep_notesAvgOrderByAggregateInput
    _max?: ep_notesMaxOrderByAggregateInput
    _min?: ep_notesMinOrderByAggregateInput
    _sum?: ep_notesSumOrderByAggregateInput
  }

  export type ep_notesScalarWhereWithAggregatesInput = {
    AND?: ep_notesScalarWhereWithAggregatesInput | ep_notesScalarWhereWithAggregatesInput[]
    OR?: ep_notesScalarWhereWithAggregatesInput[]
    NOT?: ep_notesScalarWhereWithAggregatesInput | ep_notesScalarWhereWithAggregatesInput[]
    ep_note_id?: IntWithAggregatesFilter<"ep_notes"> | number
    ep_note_user?: IntWithAggregatesFilter<"ep_notes"> | number
    ep_note_content?: StringWithAggregatesFilter<"ep_notes"> | string
    ep_note_date?: DateTimeWithAggregatesFilter<"ep_notes"> | Date | string
  }

  export type ep_clientsCreateInput = {
    cli_id: number
    cli_name?: string | null
    cli_lastname: string
    cli_ced: string
    cli_email?: string | null
    cli_version: number
  }

  export type ep_clientsUncheckedCreateInput = {
    cli_id: number
    cli_name?: string | null
    cli_lastname: string
    cli_ced: string
    cli_email?: string | null
    cli_version: number
  }

  export type ep_clientsUpdateInput = {
    cli_id?: IntFieldUpdateOperationsInput | number
    cli_name?: NullableStringFieldUpdateOperationsInput | string | null
    cli_lastname?: StringFieldUpdateOperationsInput | string
    cli_ced?: StringFieldUpdateOperationsInput | string
    cli_email?: NullableStringFieldUpdateOperationsInput | string | null
    cli_version?: IntFieldUpdateOperationsInput | number
  }

  export type ep_clientsUncheckedUpdateInput = {
    cli_id?: IntFieldUpdateOperationsInput | number
    cli_name?: NullableStringFieldUpdateOperationsInput | string | null
    cli_lastname?: StringFieldUpdateOperationsInput | string
    cli_ced?: StringFieldUpdateOperationsInput | string
    cli_email?: NullableStringFieldUpdateOperationsInput | string | null
    cli_version?: IntFieldUpdateOperationsInput | number
  }

  export type ep_clientsCreateManyInput = {
    cli_id: number
    cli_name?: string | null
    cli_lastname: string
    cli_ced: string
    cli_email?: string | null
    cli_version: number
  }

  export type ep_clientsUpdateManyMutationInput = {
    cli_id?: IntFieldUpdateOperationsInput | number
    cli_name?: NullableStringFieldUpdateOperationsInput | string | null
    cli_lastname?: StringFieldUpdateOperationsInput | string
    cli_ced?: StringFieldUpdateOperationsInput | string
    cli_email?: NullableStringFieldUpdateOperationsInput | string | null
    cli_version?: IntFieldUpdateOperationsInput | number
  }

  export type ep_clientsUncheckedUpdateManyInput = {
    cli_id?: IntFieldUpdateOperationsInput | number
    cli_name?: NullableStringFieldUpdateOperationsInput | string | null
    cli_lastname?: StringFieldUpdateOperationsInput | string
    cli_ced?: StringFieldUpdateOperationsInput | string
    cli_email?: NullableStringFieldUpdateOperationsInput | string | null
    cli_version?: IntFieldUpdateOperationsInput | number
  }

  export type ep_informartionCreateInput = {
    info_name: string
    info_location: string
    info_spaces: number
    info_version: number
    info_image: Uint8Array
    info_owner: string
    info_owner_ced: string
    info_owner_phone: string
    info_schedule: string
  }

  export type ep_informartionUncheckedCreateInput = {
    info_id?: number
    info_name: string
    info_location: string
    info_spaces: number
    info_version: number
    info_image: Uint8Array
    info_owner: string
    info_owner_ced: string
    info_owner_phone: string
    info_schedule: string
  }

  export type ep_informartionUpdateInput = {
    info_name?: StringFieldUpdateOperationsInput | string
    info_location?: StringFieldUpdateOperationsInput | string
    info_spaces?: IntFieldUpdateOperationsInput | number
    info_version?: IntFieldUpdateOperationsInput | number
    info_image?: BytesFieldUpdateOperationsInput | Uint8Array
    info_owner?: StringFieldUpdateOperationsInput | string
    info_owner_ced?: StringFieldUpdateOperationsInput | string
    info_owner_phone?: StringFieldUpdateOperationsInput | string
    info_schedule?: StringFieldUpdateOperationsInput | string
  }

  export type ep_informartionUncheckedUpdateInput = {
    info_id?: IntFieldUpdateOperationsInput | number
    info_name?: StringFieldUpdateOperationsInput | string
    info_location?: StringFieldUpdateOperationsInput | string
    info_spaces?: IntFieldUpdateOperationsInput | number
    info_version?: IntFieldUpdateOperationsInput | number
    info_image?: BytesFieldUpdateOperationsInput | Uint8Array
    info_owner?: StringFieldUpdateOperationsInput | string
    info_owner_ced?: StringFieldUpdateOperationsInput | string
    info_owner_phone?: StringFieldUpdateOperationsInput | string
    info_schedule?: StringFieldUpdateOperationsInput | string
  }

  export type ep_informartionCreateManyInput = {
    info_id?: number
    info_name: string
    info_location: string
    info_spaces: number
    info_version: number
    info_image: Uint8Array
    info_owner: string
    info_owner_ced: string
    info_owner_phone: string
    info_schedule: string
  }

  export type ep_informartionUpdateManyMutationInput = {
    info_name?: StringFieldUpdateOperationsInput | string
    info_location?: StringFieldUpdateOperationsInput | string
    info_spaces?: IntFieldUpdateOperationsInput | number
    info_version?: IntFieldUpdateOperationsInput | number
    info_image?: BytesFieldUpdateOperationsInput | Uint8Array
    info_owner?: StringFieldUpdateOperationsInput | string
    info_owner_ced?: StringFieldUpdateOperationsInput | string
    info_owner_phone?: StringFieldUpdateOperationsInput | string
    info_schedule?: StringFieldUpdateOperationsInput | string
  }

  export type ep_informartionUncheckedUpdateManyInput = {
    info_id?: IntFieldUpdateOperationsInput | number
    info_name?: StringFieldUpdateOperationsInput | string
    info_location?: StringFieldUpdateOperationsInput | string
    info_spaces?: IntFieldUpdateOperationsInput | number
    info_version?: IntFieldUpdateOperationsInput | number
    info_image?: BytesFieldUpdateOperationsInput | Uint8Array
    info_owner?: StringFieldUpdateOperationsInput | string
    info_owner_ced?: StringFieldUpdateOperationsInput | string
    info_owner_phone?: StringFieldUpdateOperationsInput | string
    info_schedule?: StringFieldUpdateOperationsInput | string
  }

  export type ep_packagesCreateInput = {
    pack_name: string
    pack_price: number
    pack_version: number
  }

  export type ep_packagesUncheckedCreateInput = {
    pack_id?: number
    pack_name: string
    pack_price: number
    pack_version: number
  }

  export type ep_packagesUpdateInput = {
    pack_name?: StringFieldUpdateOperationsInput | string
    pack_price?: IntFieldUpdateOperationsInput | number
    pack_version?: IntFieldUpdateOperationsInput | number
  }

  export type ep_packagesUncheckedUpdateInput = {
    pack_id?: IntFieldUpdateOperationsInput | number
    pack_name?: StringFieldUpdateOperationsInput | string
    pack_price?: IntFieldUpdateOperationsInput | number
    pack_version?: IntFieldUpdateOperationsInput | number
  }

  export type ep_packagesCreateManyInput = {
    pack_id?: number
    pack_name: string
    pack_price: number
    pack_version: number
  }

  export type ep_packagesUpdateManyMutationInput = {
    pack_name?: StringFieldUpdateOperationsInput | string
    pack_price?: IntFieldUpdateOperationsInput | number
    pack_version?: IntFieldUpdateOperationsInput | number
  }

  export type ep_packagesUncheckedUpdateManyInput = {
    pack_id?: IntFieldUpdateOperationsInput | number
    pack_name?: StringFieldUpdateOperationsInput | string
    pack_price?: IntFieldUpdateOperationsInput | number
    pack_version?: IntFieldUpdateOperationsInput | number
  }

  export type ep_roleCreateInput = {
    rol_name: string
    rol_version: number
  }

  export type ep_roleUncheckedCreateInput = {
    rol_id?: number
    rol_name: string
    rol_version: number
  }

  export type ep_roleUpdateInput = {
    rol_name?: StringFieldUpdateOperationsInput | string
    rol_version?: IntFieldUpdateOperationsInput | number
  }

  export type ep_roleUncheckedUpdateInput = {
    rol_id?: IntFieldUpdateOperationsInput | number
    rol_name?: StringFieldUpdateOperationsInput | string
    rol_version?: IntFieldUpdateOperationsInput | number
  }

  export type ep_roleCreateManyInput = {
    rol_id?: number
    rol_name: string
    rol_version: number
  }

  export type ep_roleUpdateManyMutationInput = {
    rol_name?: StringFieldUpdateOperationsInput | string
    rol_version?: IntFieldUpdateOperationsInput | number
  }

  export type ep_roleUncheckedUpdateManyInput = {
    rol_id?: IntFieldUpdateOperationsInput | number
    rol_name?: StringFieldUpdateOperationsInput | string
    rol_version?: IntFieldUpdateOperationsInput | number
  }

  export type ep_serverCreateInput = {
    server_id: number
    server_type: string
    server_port: string
    server_protocol: string
    server_mail: string
    server_password: string
    server_timeout: number
    server_version?: number
  }

  export type ep_serverUncheckedCreateInput = {
    server_id: number
    server_type: string
    server_port: string
    server_protocol: string
    server_mail: string
    server_password: string
    server_timeout: number
    server_version?: number
  }

  export type ep_serverUpdateInput = {
    server_id?: IntFieldUpdateOperationsInput | number
    server_type?: StringFieldUpdateOperationsInput | string
    server_port?: StringFieldUpdateOperationsInput | string
    server_protocol?: StringFieldUpdateOperationsInput | string
    server_mail?: StringFieldUpdateOperationsInput | string
    server_password?: StringFieldUpdateOperationsInput | string
    server_timeout?: IntFieldUpdateOperationsInput | number
    server_version?: IntFieldUpdateOperationsInput | number
  }

  export type ep_serverUncheckedUpdateInput = {
    server_id?: IntFieldUpdateOperationsInput | number
    server_type?: StringFieldUpdateOperationsInput | string
    server_port?: StringFieldUpdateOperationsInput | string
    server_protocol?: StringFieldUpdateOperationsInput | string
    server_mail?: StringFieldUpdateOperationsInput | string
    server_password?: StringFieldUpdateOperationsInput | string
    server_timeout?: IntFieldUpdateOperationsInput | number
    server_version?: IntFieldUpdateOperationsInput | number
  }

  export type ep_serverCreateManyInput = {
    server_id: number
    server_type: string
    server_port: string
    server_protocol: string
    server_mail: string
    server_password: string
    server_timeout: number
    server_version?: number
  }

  export type ep_serverUpdateManyMutationInput = {
    server_id?: IntFieldUpdateOperationsInput | number
    server_type?: StringFieldUpdateOperationsInput | string
    server_port?: StringFieldUpdateOperationsInput | string
    server_protocol?: StringFieldUpdateOperationsInput | string
    server_mail?: StringFieldUpdateOperationsInput | string
    server_password?: StringFieldUpdateOperationsInput | string
    server_timeout?: IntFieldUpdateOperationsInput | number
    server_version?: IntFieldUpdateOperationsInput | number
  }

  export type ep_serverUncheckedUpdateManyInput = {
    server_id?: IntFieldUpdateOperationsInput | number
    server_type?: StringFieldUpdateOperationsInput | string
    server_port?: StringFieldUpdateOperationsInput | string
    server_protocol?: StringFieldUpdateOperationsInput | string
    server_mail?: StringFieldUpdateOperationsInput | string
    server_password?: StringFieldUpdateOperationsInput | string
    server_timeout?: IntFieldUpdateOperationsInput | number
    server_version?: IntFieldUpdateOperationsInput | number
  }

  export type ep_taxCreateInput = {
    tax_price: number
    tax_version: number
  }

  export type ep_taxUncheckedCreateInput = {
    tax_id?: number
    tax_price: number
    tax_version: number
  }

  export type ep_taxUpdateInput = {
    tax_price?: IntFieldUpdateOperationsInput | number
    tax_version?: IntFieldUpdateOperationsInput | number
  }

  export type ep_taxUncheckedUpdateInput = {
    tax_id?: IntFieldUpdateOperationsInput | number
    tax_price?: IntFieldUpdateOperationsInput | number
    tax_version?: IntFieldUpdateOperationsInput | number
  }

  export type ep_taxCreateManyInput = {
    tax_id?: number
    tax_price: number
    tax_version: number
  }

  export type ep_taxUpdateManyMutationInput = {
    tax_price?: IntFieldUpdateOperationsInput | number
    tax_version?: IntFieldUpdateOperationsInput | number
  }

  export type ep_taxUncheckedUpdateManyInput = {
    tax_id?: IntFieldUpdateOperationsInput | number
    tax_price?: IntFieldUpdateOperationsInput | number
    tax_version?: IntFieldUpdateOperationsInput | number
  }

  export type ep_usersCreateInput = {
    users_name: string
    users_lastname: string
    users_ced: string
    users_version: number
    user_username: string
    user_password: string
    users_email: string
    ep_cash_per_day?: ep_cash_per_dayCreateNestedManyWithoutEp_usersInput
    notes?: ep_notesCreateNestedManyWithoutUserInput
  }

  export type ep_usersUncheckedCreateInput = {
    users_id?: number
    users_name: string
    users_lastname: string
    users_ced: string
    users_version: number
    user_username: string
    user_password: string
    users_email: string
    ep_cash_per_day?: ep_cash_per_dayUncheckedCreateNestedManyWithoutEp_usersInput
    notes?: ep_notesUncheckedCreateNestedManyWithoutUserInput
  }

  export type ep_usersUpdateInput = {
    users_name?: StringFieldUpdateOperationsInput | string
    users_lastname?: StringFieldUpdateOperationsInput | string
    users_ced?: StringFieldUpdateOperationsInput | string
    users_version?: IntFieldUpdateOperationsInput | number
    user_username?: StringFieldUpdateOperationsInput | string
    user_password?: StringFieldUpdateOperationsInput | string
    users_email?: StringFieldUpdateOperationsInput | string
    ep_cash_per_day?: ep_cash_per_dayUpdateManyWithoutEp_usersNestedInput
    notes?: ep_notesUpdateManyWithoutUserNestedInput
  }

  export type ep_usersUncheckedUpdateInput = {
    users_id?: IntFieldUpdateOperationsInput | number
    users_name?: StringFieldUpdateOperationsInput | string
    users_lastname?: StringFieldUpdateOperationsInput | string
    users_ced?: StringFieldUpdateOperationsInput | string
    users_version?: IntFieldUpdateOperationsInput | number
    user_username?: StringFieldUpdateOperationsInput | string
    user_password?: StringFieldUpdateOperationsInput | string
    users_email?: StringFieldUpdateOperationsInput | string
    ep_cash_per_day?: ep_cash_per_dayUncheckedUpdateManyWithoutEp_usersNestedInput
    notes?: ep_notesUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ep_usersCreateManyInput = {
    users_id?: number
    users_name: string
    users_lastname: string
    users_ced: string
    users_version: number
    user_username: string
    user_password: string
    users_email: string
  }

  export type ep_usersUpdateManyMutationInput = {
    users_name?: StringFieldUpdateOperationsInput | string
    users_lastname?: StringFieldUpdateOperationsInput | string
    users_ced?: StringFieldUpdateOperationsInput | string
    users_version?: IntFieldUpdateOperationsInput | number
    user_username?: StringFieldUpdateOperationsInput | string
    user_password?: StringFieldUpdateOperationsInput | string
    users_email?: StringFieldUpdateOperationsInput | string
  }

  export type ep_usersUncheckedUpdateManyInput = {
    users_id?: IntFieldUpdateOperationsInput | number
    users_name?: StringFieldUpdateOperationsInput | string
    users_lastname?: StringFieldUpdateOperationsInput | string
    users_ced?: StringFieldUpdateOperationsInput | string
    users_version?: IntFieldUpdateOperationsInput | number
    user_username?: StringFieldUpdateOperationsInput | string
    user_password?: StringFieldUpdateOperationsInput | string
    users_email?: StringFieldUpdateOperationsInput | string
  }

  export type ep_vehiclesCreateInput = {
    veh_plate: string
    veh_reference: string
    veh_status?: string | null
    veh_owner: string
    veh_color?: string | null
    veh_ingress_date: Date | string
    veh_egress_date?: Date | string | null
    veh_tax: string
    veh_version: number
  }

  export type ep_vehiclesUncheckedCreateInput = {
    veh_id?: number
    veh_plate: string
    veh_reference: string
    veh_status?: string | null
    veh_owner: string
    veh_color?: string | null
    veh_ingress_date: Date | string
    veh_egress_date?: Date | string | null
    veh_tax: string
    veh_version: number
  }

  export type ep_vehiclesUpdateInput = {
    veh_plate?: StringFieldUpdateOperationsInput | string
    veh_reference?: StringFieldUpdateOperationsInput | string
    veh_status?: NullableStringFieldUpdateOperationsInput | string | null
    veh_owner?: StringFieldUpdateOperationsInput | string
    veh_color?: NullableStringFieldUpdateOperationsInput | string | null
    veh_ingress_date?: DateTimeFieldUpdateOperationsInput | Date | string
    veh_egress_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    veh_tax?: StringFieldUpdateOperationsInput | string
    veh_version?: IntFieldUpdateOperationsInput | number
  }

  export type ep_vehiclesUncheckedUpdateInput = {
    veh_id?: IntFieldUpdateOperationsInput | number
    veh_plate?: StringFieldUpdateOperationsInput | string
    veh_reference?: StringFieldUpdateOperationsInput | string
    veh_status?: NullableStringFieldUpdateOperationsInput | string | null
    veh_owner?: StringFieldUpdateOperationsInput | string
    veh_color?: NullableStringFieldUpdateOperationsInput | string | null
    veh_ingress_date?: DateTimeFieldUpdateOperationsInput | Date | string
    veh_egress_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    veh_tax?: StringFieldUpdateOperationsInput | string
    veh_version?: IntFieldUpdateOperationsInput | number
  }

  export type ep_vehiclesCreateManyInput = {
    veh_id?: number
    veh_plate: string
    veh_reference: string
    veh_status?: string | null
    veh_owner: string
    veh_color?: string | null
    veh_ingress_date: Date | string
    veh_egress_date?: Date | string | null
    veh_tax: string
    veh_version: number
  }

  export type ep_vehiclesUpdateManyMutationInput = {
    veh_plate?: StringFieldUpdateOperationsInput | string
    veh_reference?: StringFieldUpdateOperationsInput | string
    veh_status?: NullableStringFieldUpdateOperationsInput | string | null
    veh_owner?: StringFieldUpdateOperationsInput | string
    veh_color?: NullableStringFieldUpdateOperationsInput | string | null
    veh_ingress_date?: DateTimeFieldUpdateOperationsInput | Date | string
    veh_egress_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    veh_tax?: StringFieldUpdateOperationsInput | string
    veh_version?: IntFieldUpdateOperationsInput | number
  }

  export type ep_vehiclesUncheckedUpdateManyInput = {
    veh_id?: IntFieldUpdateOperationsInput | number
    veh_plate?: StringFieldUpdateOperationsInput | string
    veh_reference?: StringFieldUpdateOperationsInput | string
    veh_status?: NullableStringFieldUpdateOperationsInput | string | null
    veh_owner?: StringFieldUpdateOperationsInput | string
    veh_color?: NullableStringFieldUpdateOperationsInput | string | null
    veh_ingress_date?: DateTimeFieldUpdateOperationsInput | Date | string
    veh_egress_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    veh_tax?: StringFieldUpdateOperationsInput | string
    veh_version?: IntFieldUpdateOperationsInput | number
  }

  export type ep_cash_per_dayCreateInput = {
    cpd_amount: Decimal | DecimalJsLike | number | string
    cpd_date: Date | string
    cpd_version: number
    ep_users: ep_usersCreateNestedOneWithoutEp_cash_per_dayInput
  }

  export type ep_cash_per_dayUncheckedCreateInput = {
    cpd_id?: number
    cpd_amount: Decimal | DecimalJsLike | number | string
    cpd_user_id: number
    cpd_date: Date | string
    cpd_version: number
  }

  export type ep_cash_per_dayUpdateInput = {
    cpd_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cpd_date?: DateTimeFieldUpdateOperationsInput | Date | string
    cpd_version?: IntFieldUpdateOperationsInput | number
    ep_users?: ep_usersUpdateOneRequiredWithoutEp_cash_per_dayNestedInput
  }

  export type ep_cash_per_dayUncheckedUpdateInput = {
    cpd_id?: IntFieldUpdateOperationsInput | number
    cpd_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cpd_user_id?: IntFieldUpdateOperationsInput | number
    cpd_date?: DateTimeFieldUpdateOperationsInput | Date | string
    cpd_version?: IntFieldUpdateOperationsInput | number
  }

  export type ep_cash_per_dayCreateManyInput = {
    cpd_id?: number
    cpd_amount: Decimal | DecimalJsLike | number | string
    cpd_user_id: number
    cpd_date: Date | string
    cpd_version: number
  }

  export type ep_cash_per_dayUpdateManyMutationInput = {
    cpd_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cpd_date?: DateTimeFieldUpdateOperationsInput | Date | string
    cpd_version?: IntFieldUpdateOperationsInput | number
  }

  export type ep_cash_per_dayUncheckedUpdateManyInput = {
    cpd_id?: IntFieldUpdateOperationsInput | number
    cpd_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cpd_user_id?: IntFieldUpdateOperationsInput | number
    cpd_date?: DateTimeFieldUpdateOperationsInput | Date | string
    cpd_version?: IntFieldUpdateOperationsInput | number
  }

  export type ep_cashierCreateInput = {
    cash_type: string
    cash_amount: Decimal | DecimalJsLike | number | string
    cash_date: Date | string
    cash_version: number
    cash_movement_type?: string | null
    transactions?: ep_cashier_transactionCreateNestedManyWithoutCashierInput
  }

  export type ep_cashierUncheckedCreateInput = {
    cash_id?: number
    cash_type: string
    cash_amount: Decimal | DecimalJsLike | number | string
    cash_date: Date | string
    cash_version: number
    cash_movement_type?: string | null
    transactions?: ep_cashier_transactionUncheckedCreateNestedManyWithoutCashierInput
  }

  export type ep_cashierUpdateInput = {
    cash_type?: StringFieldUpdateOperationsInput | string
    cash_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cash_date?: DateTimeFieldUpdateOperationsInput | Date | string
    cash_version?: IntFieldUpdateOperationsInput | number
    cash_movement_type?: NullableStringFieldUpdateOperationsInput | string | null
    transactions?: ep_cashier_transactionUpdateManyWithoutCashierNestedInput
  }

  export type ep_cashierUncheckedUpdateInput = {
    cash_id?: IntFieldUpdateOperationsInput | number
    cash_type?: StringFieldUpdateOperationsInput | string
    cash_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cash_date?: DateTimeFieldUpdateOperationsInput | Date | string
    cash_version?: IntFieldUpdateOperationsInput | number
    cash_movement_type?: NullableStringFieldUpdateOperationsInput | string | null
    transactions?: ep_cashier_transactionUncheckedUpdateManyWithoutCashierNestedInput
  }

  export type ep_cashierCreateManyInput = {
    cash_id?: number
    cash_type: string
    cash_amount: Decimal | DecimalJsLike | number | string
    cash_date: Date | string
    cash_version: number
    cash_movement_type?: string | null
  }

  export type ep_cashierUpdateManyMutationInput = {
    cash_type?: StringFieldUpdateOperationsInput | string
    cash_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cash_date?: DateTimeFieldUpdateOperationsInput | Date | string
    cash_version?: IntFieldUpdateOperationsInput | number
    cash_movement_type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ep_cashierUncheckedUpdateManyInput = {
    cash_id?: IntFieldUpdateOperationsInput | number
    cash_type?: StringFieldUpdateOperationsInput | string
    cash_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cash_date?: DateTimeFieldUpdateOperationsInput | Date | string
    cash_version?: IntFieldUpdateOperationsInput | number
    cash_movement_type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ep_cashier_transactionCreateInput = {
    cash_trans_amount: string
    cash_trans_type: string
    cash_trans_method: string
    cash_trans_date: Date | string
    cashier: ep_cashierCreateNestedOneWithoutTransactionsInput
  }

  export type ep_cashier_transactionUncheckedCreateInput = {
    cash_trans_id?: number
    cash_trans_amount: string
    cash_trans_type: string
    cash_trans_method: string
    cash_trans_date: Date | string
    cash_trans_cashier_id: number
  }

  export type ep_cashier_transactionUpdateInput = {
    cash_trans_amount?: StringFieldUpdateOperationsInput | string
    cash_trans_type?: StringFieldUpdateOperationsInput | string
    cash_trans_method?: StringFieldUpdateOperationsInput | string
    cash_trans_date?: DateTimeFieldUpdateOperationsInput | Date | string
    cashier?: ep_cashierUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type ep_cashier_transactionUncheckedUpdateInput = {
    cash_trans_id?: IntFieldUpdateOperationsInput | number
    cash_trans_amount?: StringFieldUpdateOperationsInput | string
    cash_trans_type?: StringFieldUpdateOperationsInput | string
    cash_trans_method?: StringFieldUpdateOperationsInput | string
    cash_trans_date?: DateTimeFieldUpdateOperationsInput | Date | string
    cash_trans_cashier_id?: IntFieldUpdateOperationsInput | number
  }

  export type ep_cashier_transactionCreateManyInput = {
    cash_trans_id?: number
    cash_trans_amount: string
    cash_trans_type: string
    cash_trans_method: string
    cash_trans_date: Date | string
    cash_trans_cashier_id: number
  }

  export type ep_cashier_transactionUpdateManyMutationInput = {
    cash_trans_amount?: StringFieldUpdateOperationsInput | string
    cash_trans_type?: StringFieldUpdateOperationsInput | string
    cash_trans_method?: StringFieldUpdateOperationsInput | string
    cash_trans_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ep_cashier_transactionUncheckedUpdateManyInput = {
    cash_trans_id?: IntFieldUpdateOperationsInput | number
    cash_trans_amount?: StringFieldUpdateOperationsInput | string
    cash_trans_type?: StringFieldUpdateOperationsInput | string
    cash_trans_method?: StringFieldUpdateOperationsInput | string
    cash_trans_date?: DateTimeFieldUpdateOperationsInput | Date | string
    cash_trans_cashier_id?: IntFieldUpdateOperationsInput | number
  }

  export type ep_notesCreateInput = {
    ep_note_content: string
    ep_note_date?: Date | string
    user: ep_usersCreateNestedOneWithoutNotesInput
  }

  export type ep_notesUncheckedCreateInput = {
    ep_note_id?: number
    ep_note_user: number
    ep_note_content: string
    ep_note_date?: Date | string
  }

  export type ep_notesUpdateInput = {
    ep_note_content?: StringFieldUpdateOperationsInput | string
    ep_note_date?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: ep_usersUpdateOneRequiredWithoutNotesNestedInput
  }

  export type ep_notesUncheckedUpdateInput = {
    ep_note_id?: IntFieldUpdateOperationsInput | number
    ep_note_user?: IntFieldUpdateOperationsInput | number
    ep_note_content?: StringFieldUpdateOperationsInput | string
    ep_note_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ep_notesCreateManyInput = {
    ep_note_id?: number
    ep_note_user: number
    ep_note_content: string
    ep_note_date?: Date | string
  }

  export type ep_notesUpdateManyMutationInput = {
    ep_note_content?: StringFieldUpdateOperationsInput | string
    ep_note_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ep_notesUncheckedUpdateManyInput = {
    ep_note_id?: IntFieldUpdateOperationsInput | number
    ep_note_user?: IntFieldUpdateOperationsInput | number
    ep_note_content?: StringFieldUpdateOperationsInput | string
    ep_note_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ep_clientsCountOrderByAggregateInput = {
    cli_id?: SortOrder
    cli_name?: SortOrder
    cli_lastname?: SortOrder
    cli_ced?: SortOrder
    cli_email?: SortOrder
    cli_version?: SortOrder
  }

  export type ep_clientsAvgOrderByAggregateInput = {
    cli_id?: SortOrder
    cli_version?: SortOrder
  }

  export type ep_clientsMaxOrderByAggregateInput = {
    cli_id?: SortOrder
    cli_name?: SortOrder
    cli_lastname?: SortOrder
    cli_ced?: SortOrder
    cli_email?: SortOrder
    cli_version?: SortOrder
  }

  export type ep_clientsMinOrderByAggregateInput = {
    cli_id?: SortOrder
    cli_name?: SortOrder
    cli_lastname?: SortOrder
    cli_ced?: SortOrder
    cli_email?: SortOrder
    cli_version?: SortOrder
  }

  export type ep_clientsSumOrderByAggregateInput = {
    cli_id?: SortOrder
    cli_version?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type BytesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel>
    in?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesFilter<$PrismaModel> | Uint8Array
  }

  export type ep_informartionCountOrderByAggregateInput = {
    info_id?: SortOrder
    info_name?: SortOrder
    info_location?: SortOrder
    info_spaces?: SortOrder
    info_version?: SortOrder
    info_image?: SortOrder
    info_owner?: SortOrder
    info_owner_ced?: SortOrder
    info_owner_phone?: SortOrder
    info_schedule?: SortOrder
  }

  export type ep_informartionAvgOrderByAggregateInput = {
    info_id?: SortOrder
    info_spaces?: SortOrder
    info_version?: SortOrder
  }

  export type ep_informartionMaxOrderByAggregateInput = {
    info_id?: SortOrder
    info_name?: SortOrder
    info_location?: SortOrder
    info_spaces?: SortOrder
    info_version?: SortOrder
    info_image?: SortOrder
    info_owner?: SortOrder
    info_owner_ced?: SortOrder
    info_owner_phone?: SortOrder
    info_schedule?: SortOrder
  }

  export type ep_informartionMinOrderByAggregateInput = {
    info_id?: SortOrder
    info_name?: SortOrder
    info_location?: SortOrder
    info_spaces?: SortOrder
    info_version?: SortOrder
    info_image?: SortOrder
    info_owner?: SortOrder
    info_owner_ced?: SortOrder
    info_owner_phone?: SortOrder
    info_schedule?: SortOrder
  }

  export type ep_informartionSumOrderByAggregateInput = {
    info_id?: SortOrder
    info_spaces?: SortOrder
    info_version?: SortOrder
  }

  export type BytesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel>
    in?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesWithAggregatesFilter<$PrismaModel> | Uint8Array
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBytesFilter<$PrismaModel>
    _max?: NestedBytesFilter<$PrismaModel>
  }

  export type ep_packagesCountOrderByAggregateInput = {
    pack_id?: SortOrder
    pack_name?: SortOrder
    pack_price?: SortOrder
    pack_version?: SortOrder
  }

  export type ep_packagesAvgOrderByAggregateInput = {
    pack_id?: SortOrder
    pack_price?: SortOrder
    pack_version?: SortOrder
  }

  export type ep_packagesMaxOrderByAggregateInput = {
    pack_id?: SortOrder
    pack_name?: SortOrder
    pack_price?: SortOrder
    pack_version?: SortOrder
  }

  export type ep_packagesMinOrderByAggregateInput = {
    pack_id?: SortOrder
    pack_name?: SortOrder
    pack_price?: SortOrder
    pack_version?: SortOrder
  }

  export type ep_packagesSumOrderByAggregateInput = {
    pack_id?: SortOrder
    pack_price?: SortOrder
    pack_version?: SortOrder
  }

  export type ep_roleCountOrderByAggregateInput = {
    rol_id?: SortOrder
    rol_name?: SortOrder
    rol_version?: SortOrder
  }

  export type ep_roleAvgOrderByAggregateInput = {
    rol_id?: SortOrder
    rol_version?: SortOrder
  }

  export type ep_roleMaxOrderByAggregateInput = {
    rol_id?: SortOrder
    rol_name?: SortOrder
    rol_version?: SortOrder
  }

  export type ep_roleMinOrderByAggregateInput = {
    rol_id?: SortOrder
    rol_name?: SortOrder
    rol_version?: SortOrder
  }

  export type ep_roleSumOrderByAggregateInput = {
    rol_id?: SortOrder
    rol_version?: SortOrder
  }

  export type ep_serverCountOrderByAggregateInput = {
    server_id?: SortOrder
    server_type?: SortOrder
    server_port?: SortOrder
    server_protocol?: SortOrder
    server_mail?: SortOrder
    server_password?: SortOrder
    server_timeout?: SortOrder
    server_version?: SortOrder
  }

  export type ep_serverAvgOrderByAggregateInput = {
    server_id?: SortOrder
    server_timeout?: SortOrder
    server_version?: SortOrder
  }

  export type ep_serverMaxOrderByAggregateInput = {
    server_id?: SortOrder
    server_type?: SortOrder
    server_port?: SortOrder
    server_protocol?: SortOrder
    server_mail?: SortOrder
    server_password?: SortOrder
    server_timeout?: SortOrder
    server_version?: SortOrder
  }

  export type ep_serverMinOrderByAggregateInput = {
    server_id?: SortOrder
    server_type?: SortOrder
    server_port?: SortOrder
    server_protocol?: SortOrder
    server_mail?: SortOrder
    server_password?: SortOrder
    server_timeout?: SortOrder
    server_version?: SortOrder
  }

  export type ep_serverSumOrderByAggregateInput = {
    server_id?: SortOrder
    server_timeout?: SortOrder
    server_version?: SortOrder
  }

  export type ep_taxCountOrderByAggregateInput = {
    tax_id?: SortOrder
    tax_price?: SortOrder
    tax_version?: SortOrder
  }

  export type ep_taxAvgOrderByAggregateInput = {
    tax_id?: SortOrder
    tax_price?: SortOrder
    tax_version?: SortOrder
  }

  export type ep_taxMaxOrderByAggregateInput = {
    tax_id?: SortOrder
    tax_price?: SortOrder
    tax_version?: SortOrder
  }

  export type ep_taxMinOrderByAggregateInput = {
    tax_id?: SortOrder
    tax_price?: SortOrder
    tax_version?: SortOrder
  }

  export type ep_taxSumOrderByAggregateInput = {
    tax_id?: SortOrder
    tax_price?: SortOrder
    tax_version?: SortOrder
  }

  export type Ep_cash_per_dayListRelationFilter = {
    every?: ep_cash_per_dayWhereInput
    some?: ep_cash_per_dayWhereInput
    none?: ep_cash_per_dayWhereInput
  }

  export type Ep_notesListRelationFilter = {
    every?: ep_notesWhereInput
    some?: ep_notesWhereInput
    none?: ep_notesWhereInput
  }

  export type ep_cash_per_dayOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ep_notesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ep_usersCountOrderByAggregateInput = {
    users_id?: SortOrder
    users_name?: SortOrder
    users_lastname?: SortOrder
    users_ced?: SortOrder
    users_version?: SortOrder
    user_username?: SortOrder
    user_password?: SortOrder
    users_email?: SortOrder
  }

  export type ep_usersAvgOrderByAggregateInput = {
    users_id?: SortOrder
    users_version?: SortOrder
  }

  export type ep_usersMaxOrderByAggregateInput = {
    users_id?: SortOrder
    users_name?: SortOrder
    users_lastname?: SortOrder
    users_ced?: SortOrder
    users_version?: SortOrder
    user_username?: SortOrder
    user_password?: SortOrder
    users_email?: SortOrder
  }

  export type ep_usersMinOrderByAggregateInput = {
    users_id?: SortOrder
    users_name?: SortOrder
    users_lastname?: SortOrder
    users_ced?: SortOrder
    users_version?: SortOrder
    user_username?: SortOrder
    user_password?: SortOrder
    users_email?: SortOrder
  }

  export type ep_usersSumOrderByAggregateInput = {
    users_id?: SortOrder
    users_version?: SortOrder
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type ep_vehiclesCountOrderByAggregateInput = {
    veh_id?: SortOrder
    veh_plate?: SortOrder
    veh_reference?: SortOrder
    veh_status?: SortOrder
    veh_owner?: SortOrder
    veh_color?: SortOrder
    veh_ingress_date?: SortOrder
    veh_egress_date?: SortOrder
    veh_tax?: SortOrder
    veh_version?: SortOrder
  }

  export type ep_vehiclesAvgOrderByAggregateInput = {
    veh_id?: SortOrder
    veh_version?: SortOrder
  }

  export type ep_vehiclesMaxOrderByAggregateInput = {
    veh_id?: SortOrder
    veh_plate?: SortOrder
    veh_reference?: SortOrder
    veh_status?: SortOrder
    veh_owner?: SortOrder
    veh_color?: SortOrder
    veh_ingress_date?: SortOrder
    veh_egress_date?: SortOrder
    veh_tax?: SortOrder
    veh_version?: SortOrder
  }

  export type ep_vehiclesMinOrderByAggregateInput = {
    veh_id?: SortOrder
    veh_plate?: SortOrder
    veh_reference?: SortOrder
    veh_status?: SortOrder
    veh_owner?: SortOrder
    veh_color?: SortOrder
    veh_ingress_date?: SortOrder
    veh_egress_date?: SortOrder
    veh_tax?: SortOrder
    veh_version?: SortOrder
  }

  export type ep_vehiclesSumOrderByAggregateInput = {
    veh_id?: SortOrder
    veh_version?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type Ep_usersScalarRelationFilter = {
    is?: ep_usersWhereInput
    isNot?: ep_usersWhereInput
  }

  export type ep_cash_per_dayCountOrderByAggregateInput = {
    cpd_id?: SortOrder
    cpd_amount?: SortOrder
    cpd_user_id?: SortOrder
    cpd_date?: SortOrder
    cpd_version?: SortOrder
  }

  export type ep_cash_per_dayAvgOrderByAggregateInput = {
    cpd_id?: SortOrder
    cpd_amount?: SortOrder
    cpd_user_id?: SortOrder
    cpd_version?: SortOrder
  }

  export type ep_cash_per_dayMaxOrderByAggregateInput = {
    cpd_id?: SortOrder
    cpd_amount?: SortOrder
    cpd_user_id?: SortOrder
    cpd_date?: SortOrder
    cpd_version?: SortOrder
  }

  export type ep_cash_per_dayMinOrderByAggregateInput = {
    cpd_id?: SortOrder
    cpd_amount?: SortOrder
    cpd_user_id?: SortOrder
    cpd_date?: SortOrder
    cpd_version?: SortOrder
  }

  export type ep_cash_per_daySumOrderByAggregateInput = {
    cpd_id?: SortOrder
    cpd_amount?: SortOrder
    cpd_user_id?: SortOrder
    cpd_version?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type Ep_cashier_transactionListRelationFilter = {
    every?: ep_cashier_transactionWhereInput
    some?: ep_cashier_transactionWhereInput
    none?: ep_cashier_transactionWhereInput
  }

  export type ep_cashier_transactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ep_cashierCountOrderByAggregateInput = {
    cash_id?: SortOrder
    cash_type?: SortOrder
    cash_amount?: SortOrder
    cash_date?: SortOrder
    cash_version?: SortOrder
    cash_movement_type?: SortOrder
  }

  export type ep_cashierAvgOrderByAggregateInput = {
    cash_id?: SortOrder
    cash_amount?: SortOrder
    cash_version?: SortOrder
  }

  export type ep_cashierMaxOrderByAggregateInput = {
    cash_id?: SortOrder
    cash_type?: SortOrder
    cash_amount?: SortOrder
    cash_date?: SortOrder
    cash_version?: SortOrder
    cash_movement_type?: SortOrder
  }

  export type ep_cashierMinOrderByAggregateInput = {
    cash_id?: SortOrder
    cash_type?: SortOrder
    cash_amount?: SortOrder
    cash_date?: SortOrder
    cash_version?: SortOrder
    cash_movement_type?: SortOrder
  }

  export type ep_cashierSumOrderByAggregateInput = {
    cash_id?: SortOrder
    cash_amount?: SortOrder
    cash_version?: SortOrder
  }

  export type Ep_cashierScalarRelationFilter = {
    is?: ep_cashierWhereInput
    isNot?: ep_cashierWhereInput
  }

  export type ep_cashier_transactionCountOrderByAggregateInput = {
    cash_trans_id?: SortOrder
    cash_trans_amount?: SortOrder
    cash_trans_type?: SortOrder
    cash_trans_method?: SortOrder
    cash_trans_date?: SortOrder
    cash_trans_cashier_id?: SortOrder
  }

  export type ep_cashier_transactionAvgOrderByAggregateInput = {
    cash_trans_id?: SortOrder
    cash_trans_cashier_id?: SortOrder
  }

  export type ep_cashier_transactionMaxOrderByAggregateInput = {
    cash_trans_id?: SortOrder
    cash_trans_amount?: SortOrder
    cash_trans_type?: SortOrder
    cash_trans_method?: SortOrder
    cash_trans_date?: SortOrder
    cash_trans_cashier_id?: SortOrder
  }

  export type ep_cashier_transactionMinOrderByAggregateInput = {
    cash_trans_id?: SortOrder
    cash_trans_amount?: SortOrder
    cash_trans_type?: SortOrder
    cash_trans_method?: SortOrder
    cash_trans_date?: SortOrder
    cash_trans_cashier_id?: SortOrder
  }

  export type ep_cashier_transactionSumOrderByAggregateInput = {
    cash_trans_id?: SortOrder
    cash_trans_cashier_id?: SortOrder
  }

  export type ep_notesCountOrderByAggregateInput = {
    ep_note_id?: SortOrder
    ep_note_user?: SortOrder
    ep_note_content?: SortOrder
    ep_note_date?: SortOrder
  }

  export type ep_notesAvgOrderByAggregateInput = {
    ep_note_id?: SortOrder
    ep_note_user?: SortOrder
  }

  export type ep_notesMaxOrderByAggregateInput = {
    ep_note_id?: SortOrder
    ep_note_user?: SortOrder
    ep_note_content?: SortOrder
    ep_note_date?: SortOrder
  }

  export type ep_notesMinOrderByAggregateInput = {
    ep_note_id?: SortOrder
    ep_note_user?: SortOrder
    ep_note_content?: SortOrder
    ep_note_date?: SortOrder
  }

  export type ep_notesSumOrderByAggregateInput = {
    ep_note_id?: SortOrder
    ep_note_user?: SortOrder
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type BytesFieldUpdateOperationsInput = {
    set?: Uint8Array
  }

  export type ep_cash_per_dayCreateNestedManyWithoutEp_usersInput = {
    create?: XOR<ep_cash_per_dayCreateWithoutEp_usersInput, ep_cash_per_dayUncheckedCreateWithoutEp_usersInput> | ep_cash_per_dayCreateWithoutEp_usersInput[] | ep_cash_per_dayUncheckedCreateWithoutEp_usersInput[]
    connectOrCreate?: ep_cash_per_dayCreateOrConnectWithoutEp_usersInput | ep_cash_per_dayCreateOrConnectWithoutEp_usersInput[]
    createMany?: ep_cash_per_dayCreateManyEp_usersInputEnvelope
    connect?: ep_cash_per_dayWhereUniqueInput | ep_cash_per_dayWhereUniqueInput[]
  }

  export type ep_notesCreateNestedManyWithoutUserInput = {
    create?: XOR<ep_notesCreateWithoutUserInput, ep_notesUncheckedCreateWithoutUserInput> | ep_notesCreateWithoutUserInput[] | ep_notesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ep_notesCreateOrConnectWithoutUserInput | ep_notesCreateOrConnectWithoutUserInput[]
    createMany?: ep_notesCreateManyUserInputEnvelope
    connect?: ep_notesWhereUniqueInput | ep_notesWhereUniqueInput[]
  }

  export type ep_cash_per_dayUncheckedCreateNestedManyWithoutEp_usersInput = {
    create?: XOR<ep_cash_per_dayCreateWithoutEp_usersInput, ep_cash_per_dayUncheckedCreateWithoutEp_usersInput> | ep_cash_per_dayCreateWithoutEp_usersInput[] | ep_cash_per_dayUncheckedCreateWithoutEp_usersInput[]
    connectOrCreate?: ep_cash_per_dayCreateOrConnectWithoutEp_usersInput | ep_cash_per_dayCreateOrConnectWithoutEp_usersInput[]
    createMany?: ep_cash_per_dayCreateManyEp_usersInputEnvelope
    connect?: ep_cash_per_dayWhereUniqueInput | ep_cash_per_dayWhereUniqueInput[]
  }

  export type ep_notesUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ep_notesCreateWithoutUserInput, ep_notesUncheckedCreateWithoutUserInput> | ep_notesCreateWithoutUserInput[] | ep_notesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ep_notesCreateOrConnectWithoutUserInput | ep_notesCreateOrConnectWithoutUserInput[]
    createMany?: ep_notesCreateManyUserInputEnvelope
    connect?: ep_notesWhereUniqueInput | ep_notesWhereUniqueInput[]
  }

  export type ep_cash_per_dayUpdateManyWithoutEp_usersNestedInput = {
    create?: XOR<ep_cash_per_dayCreateWithoutEp_usersInput, ep_cash_per_dayUncheckedCreateWithoutEp_usersInput> | ep_cash_per_dayCreateWithoutEp_usersInput[] | ep_cash_per_dayUncheckedCreateWithoutEp_usersInput[]
    connectOrCreate?: ep_cash_per_dayCreateOrConnectWithoutEp_usersInput | ep_cash_per_dayCreateOrConnectWithoutEp_usersInput[]
    upsert?: ep_cash_per_dayUpsertWithWhereUniqueWithoutEp_usersInput | ep_cash_per_dayUpsertWithWhereUniqueWithoutEp_usersInput[]
    createMany?: ep_cash_per_dayCreateManyEp_usersInputEnvelope
    set?: ep_cash_per_dayWhereUniqueInput | ep_cash_per_dayWhereUniqueInput[]
    disconnect?: ep_cash_per_dayWhereUniqueInput | ep_cash_per_dayWhereUniqueInput[]
    delete?: ep_cash_per_dayWhereUniqueInput | ep_cash_per_dayWhereUniqueInput[]
    connect?: ep_cash_per_dayWhereUniqueInput | ep_cash_per_dayWhereUniqueInput[]
    update?: ep_cash_per_dayUpdateWithWhereUniqueWithoutEp_usersInput | ep_cash_per_dayUpdateWithWhereUniqueWithoutEp_usersInput[]
    updateMany?: ep_cash_per_dayUpdateManyWithWhereWithoutEp_usersInput | ep_cash_per_dayUpdateManyWithWhereWithoutEp_usersInput[]
    deleteMany?: ep_cash_per_dayScalarWhereInput | ep_cash_per_dayScalarWhereInput[]
  }

  export type ep_notesUpdateManyWithoutUserNestedInput = {
    create?: XOR<ep_notesCreateWithoutUserInput, ep_notesUncheckedCreateWithoutUserInput> | ep_notesCreateWithoutUserInput[] | ep_notesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ep_notesCreateOrConnectWithoutUserInput | ep_notesCreateOrConnectWithoutUserInput[]
    upsert?: ep_notesUpsertWithWhereUniqueWithoutUserInput | ep_notesUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ep_notesCreateManyUserInputEnvelope
    set?: ep_notesWhereUniqueInput | ep_notesWhereUniqueInput[]
    disconnect?: ep_notesWhereUniqueInput | ep_notesWhereUniqueInput[]
    delete?: ep_notesWhereUniqueInput | ep_notesWhereUniqueInput[]
    connect?: ep_notesWhereUniqueInput | ep_notesWhereUniqueInput[]
    update?: ep_notesUpdateWithWhereUniqueWithoutUserInput | ep_notesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ep_notesUpdateManyWithWhereWithoutUserInput | ep_notesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ep_notesScalarWhereInput | ep_notesScalarWhereInput[]
  }

  export type ep_cash_per_dayUncheckedUpdateManyWithoutEp_usersNestedInput = {
    create?: XOR<ep_cash_per_dayCreateWithoutEp_usersInput, ep_cash_per_dayUncheckedCreateWithoutEp_usersInput> | ep_cash_per_dayCreateWithoutEp_usersInput[] | ep_cash_per_dayUncheckedCreateWithoutEp_usersInput[]
    connectOrCreate?: ep_cash_per_dayCreateOrConnectWithoutEp_usersInput | ep_cash_per_dayCreateOrConnectWithoutEp_usersInput[]
    upsert?: ep_cash_per_dayUpsertWithWhereUniqueWithoutEp_usersInput | ep_cash_per_dayUpsertWithWhereUniqueWithoutEp_usersInput[]
    createMany?: ep_cash_per_dayCreateManyEp_usersInputEnvelope
    set?: ep_cash_per_dayWhereUniqueInput | ep_cash_per_dayWhereUniqueInput[]
    disconnect?: ep_cash_per_dayWhereUniqueInput | ep_cash_per_dayWhereUniqueInput[]
    delete?: ep_cash_per_dayWhereUniqueInput | ep_cash_per_dayWhereUniqueInput[]
    connect?: ep_cash_per_dayWhereUniqueInput | ep_cash_per_dayWhereUniqueInput[]
    update?: ep_cash_per_dayUpdateWithWhereUniqueWithoutEp_usersInput | ep_cash_per_dayUpdateWithWhereUniqueWithoutEp_usersInput[]
    updateMany?: ep_cash_per_dayUpdateManyWithWhereWithoutEp_usersInput | ep_cash_per_dayUpdateManyWithWhereWithoutEp_usersInput[]
    deleteMany?: ep_cash_per_dayScalarWhereInput | ep_cash_per_dayScalarWhereInput[]
  }

  export type ep_notesUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ep_notesCreateWithoutUserInput, ep_notesUncheckedCreateWithoutUserInput> | ep_notesCreateWithoutUserInput[] | ep_notesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ep_notesCreateOrConnectWithoutUserInput | ep_notesCreateOrConnectWithoutUserInput[]
    upsert?: ep_notesUpsertWithWhereUniqueWithoutUserInput | ep_notesUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ep_notesCreateManyUserInputEnvelope
    set?: ep_notesWhereUniqueInput | ep_notesWhereUniqueInput[]
    disconnect?: ep_notesWhereUniqueInput | ep_notesWhereUniqueInput[]
    delete?: ep_notesWhereUniqueInput | ep_notesWhereUniqueInput[]
    connect?: ep_notesWhereUniqueInput | ep_notesWhereUniqueInput[]
    update?: ep_notesUpdateWithWhereUniqueWithoutUserInput | ep_notesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ep_notesUpdateManyWithWhereWithoutUserInput | ep_notesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ep_notesScalarWhereInput | ep_notesScalarWhereInput[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type ep_usersCreateNestedOneWithoutEp_cash_per_dayInput = {
    create?: XOR<ep_usersCreateWithoutEp_cash_per_dayInput, ep_usersUncheckedCreateWithoutEp_cash_per_dayInput>
    connectOrCreate?: ep_usersCreateOrConnectWithoutEp_cash_per_dayInput
    connect?: ep_usersWhereUniqueInput
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type ep_usersUpdateOneRequiredWithoutEp_cash_per_dayNestedInput = {
    create?: XOR<ep_usersCreateWithoutEp_cash_per_dayInput, ep_usersUncheckedCreateWithoutEp_cash_per_dayInput>
    connectOrCreate?: ep_usersCreateOrConnectWithoutEp_cash_per_dayInput
    upsert?: ep_usersUpsertWithoutEp_cash_per_dayInput
    connect?: ep_usersWhereUniqueInput
    update?: XOR<XOR<ep_usersUpdateToOneWithWhereWithoutEp_cash_per_dayInput, ep_usersUpdateWithoutEp_cash_per_dayInput>, ep_usersUncheckedUpdateWithoutEp_cash_per_dayInput>
  }

  export type ep_cashier_transactionCreateNestedManyWithoutCashierInput = {
    create?: XOR<ep_cashier_transactionCreateWithoutCashierInput, ep_cashier_transactionUncheckedCreateWithoutCashierInput> | ep_cashier_transactionCreateWithoutCashierInput[] | ep_cashier_transactionUncheckedCreateWithoutCashierInput[]
    connectOrCreate?: ep_cashier_transactionCreateOrConnectWithoutCashierInput | ep_cashier_transactionCreateOrConnectWithoutCashierInput[]
    createMany?: ep_cashier_transactionCreateManyCashierInputEnvelope
    connect?: ep_cashier_transactionWhereUniqueInput | ep_cashier_transactionWhereUniqueInput[]
  }

  export type ep_cashier_transactionUncheckedCreateNestedManyWithoutCashierInput = {
    create?: XOR<ep_cashier_transactionCreateWithoutCashierInput, ep_cashier_transactionUncheckedCreateWithoutCashierInput> | ep_cashier_transactionCreateWithoutCashierInput[] | ep_cashier_transactionUncheckedCreateWithoutCashierInput[]
    connectOrCreate?: ep_cashier_transactionCreateOrConnectWithoutCashierInput | ep_cashier_transactionCreateOrConnectWithoutCashierInput[]
    createMany?: ep_cashier_transactionCreateManyCashierInputEnvelope
    connect?: ep_cashier_transactionWhereUniqueInput | ep_cashier_transactionWhereUniqueInput[]
  }

  export type ep_cashier_transactionUpdateManyWithoutCashierNestedInput = {
    create?: XOR<ep_cashier_transactionCreateWithoutCashierInput, ep_cashier_transactionUncheckedCreateWithoutCashierInput> | ep_cashier_transactionCreateWithoutCashierInput[] | ep_cashier_transactionUncheckedCreateWithoutCashierInput[]
    connectOrCreate?: ep_cashier_transactionCreateOrConnectWithoutCashierInput | ep_cashier_transactionCreateOrConnectWithoutCashierInput[]
    upsert?: ep_cashier_transactionUpsertWithWhereUniqueWithoutCashierInput | ep_cashier_transactionUpsertWithWhereUniqueWithoutCashierInput[]
    createMany?: ep_cashier_transactionCreateManyCashierInputEnvelope
    set?: ep_cashier_transactionWhereUniqueInput | ep_cashier_transactionWhereUniqueInput[]
    disconnect?: ep_cashier_transactionWhereUniqueInput | ep_cashier_transactionWhereUniqueInput[]
    delete?: ep_cashier_transactionWhereUniqueInput | ep_cashier_transactionWhereUniqueInput[]
    connect?: ep_cashier_transactionWhereUniqueInput | ep_cashier_transactionWhereUniqueInput[]
    update?: ep_cashier_transactionUpdateWithWhereUniqueWithoutCashierInput | ep_cashier_transactionUpdateWithWhereUniqueWithoutCashierInput[]
    updateMany?: ep_cashier_transactionUpdateManyWithWhereWithoutCashierInput | ep_cashier_transactionUpdateManyWithWhereWithoutCashierInput[]
    deleteMany?: ep_cashier_transactionScalarWhereInput | ep_cashier_transactionScalarWhereInput[]
  }

  export type ep_cashier_transactionUncheckedUpdateManyWithoutCashierNestedInput = {
    create?: XOR<ep_cashier_transactionCreateWithoutCashierInput, ep_cashier_transactionUncheckedCreateWithoutCashierInput> | ep_cashier_transactionCreateWithoutCashierInput[] | ep_cashier_transactionUncheckedCreateWithoutCashierInput[]
    connectOrCreate?: ep_cashier_transactionCreateOrConnectWithoutCashierInput | ep_cashier_transactionCreateOrConnectWithoutCashierInput[]
    upsert?: ep_cashier_transactionUpsertWithWhereUniqueWithoutCashierInput | ep_cashier_transactionUpsertWithWhereUniqueWithoutCashierInput[]
    createMany?: ep_cashier_transactionCreateManyCashierInputEnvelope
    set?: ep_cashier_transactionWhereUniqueInput | ep_cashier_transactionWhereUniqueInput[]
    disconnect?: ep_cashier_transactionWhereUniqueInput | ep_cashier_transactionWhereUniqueInput[]
    delete?: ep_cashier_transactionWhereUniqueInput | ep_cashier_transactionWhereUniqueInput[]
    connect?: ep_cashier_transactionWhereUniqueInput | ep_cashier_transactionWhereUniqueInput[]
    update?: ep_cashier_transactionUpdateWithWhereUniqueWithoutCashierInput | ep_cashier_transactionUpdateWithWhereUniqueWithoutCashierInput[]
    updateMany?: ep_cashier_transactionUpdateManyWithWhereWithoutCashierInput | ep_cashier_transactionUpdateManyWithWhereWithoutCashierInput[]
    deleteMany?: ep_cashier_transactionScalarWhereInput | ep_cashier_transactionScalarWhereInput[]
  }

  export type ep_cashierCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<ep_cashierCreateWithoutTransactionsInput, ep_cashierUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: ep_cashierCreateOrConnectWithoutTransactionsInput
    connect?: ep_cashierWhereUniqueInput
  }

  export type ep_cashierUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<ep_cashierCreateWithoutTransactionsInput, ep_cashierUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: ep_cashierCreateOrConnectWithoutTransactionsInput
    upsert?: ep_cashierUpsertWithoutTransactionsInput
    connect?: ep_cashierWhereUniqueInput
    update?: XOR<XOR<ep_cashierUpdateToOneWithWhereWithoutTransactionsInput, ep_cashierUpdateWithoutTransactionsInput>, ep_cashierUncheckedUpdateWithoutTransactionsInput>
  }

  export type ep_usersCreateNestedOneWithoutNotesInput = {
    create?: XOR<ep_usersCreateWithoutNotesInput, ep_usersUncheckedCreateWithoutNotesInput>
    connectOrCreate?: ep_usersCreateOrConnectWithoutNotesInput
    connect?: ep_usersWhereUniqueInput
  }

  export type ep_usersUpdateOneRequiredWithoutNotesNestedInput = {
    create?: XOR<ep_usersCreateWithoutNotesInput, ep_usersUncheckedCreateWithoutNotesInput>
    connectOrCreate?: ep_usersCreateOrConnectWithoutNotesInput
    upsert?: ep_usersUpsertWithoutNotesInput
    connect?: ep_usersWhereUniqueInput
    update?: XOR<XOR<ep_usersUpdateToOneWithWhereWithoutNotesInput, ep_usersUpdateWithoutNotesInput>, ep_usersUncheckedUpdateWithoutNotesInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedBytesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel>
    in?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesFilter<$PrismaModel> | Uint8Array
  }

  export type NestedBytesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel>
    in?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesWithAggregatesFilter<$PrismaModel> | Uint8Array
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBytesFilter<$PrismaModel>
    _max?: NestedBytesFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type ep_cash_per_dayCreateWithoutEp_usersInput = {
    cpd_amount: Decimal | DecimalJsLike | number | string
    cpd_date: Date | string
    cpd_version: number
  }

  export type ep_cash_per_dayUncheckedCreateWithoutEp_usersInput = {
    cpd_id?: number
    cpd_amount: Decimal | DecimalJsLike | number | string
    cpd_date: Date | string
    cpd_version: number
  }

  export type ep_cash_per_dayCreateOrConnectWithoutEp_usersInput = {
    where: ep_cash_per_dayWhereUniqueInput
    create: XOR<ep_cash_per_dayCreateWithoutEp_usersInput, ep_cash_per_dayUncheckedCreateWithoutEp_usersInput>
  }

  export type ep_cash_per_dayCreateManyEp_usersInputEnvelope = {
    data: ep_cash_per_dayCreateManyEp_usersInput | ep_cash_per_dayCreateManyEp_usersInput[]
    skipDuplicates?: boolean
  }

  export type ep_notesCreateWithoutUserInput = {
    ep_note_content: string
    ep_note_date?: Date | string
  }

  export type ep_notesUncheckedCreateWithoutUserInput = {
    ep_note_id?: number
    ep_note_content: string
    ep_note_date?: Date | string
  }

  export type ep_notesCreateOrConnectWithoutUserInput = {
    where: ep_notesWhereUniqueInput
    create: XOR<ep_notesCreateWithoutUserInput, ep_notesUncheckedCreateWithoutUserInput>
  }

  export type ep_notesCreateManyUserInputEnvelope = {
    data: ep_notesCreateManyUserInput | ep_notesCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ep_cash_per_dayUpsertWithWhereUniqueWithoutEp_usersInput = {
    where: ep_cash_per_dayWhereUniqueInput
    update: XOR<ep_cash_per_dayUpdateWithoutEp_usersInput, ep_cash_per_dayUncheckedUpdateWithoutEp_usersInput>
    create: XOR<ep_cash_per_dayCreateWithoutEp_usersInput, ep_cash_per_dayUncheckedCreateWithoutEp_usersInput>
  }

  export type ep_cash_per_dayUpdateWithWhereUniqueWithoutEp_usersInput = {
    where: ep_cash_per_dayWhereUniqueInput
    data: XOR<ep_cash_per_dayUpdateWithoutEp_usersInput, ep_cash_per_dayUncheckedUpdateWithoutEp_usersInput>
  }

  export type ep_cash_per_dayUpdateManyWithWhereWithoutEp_usersInput = {
    where: ep_cash_per_dayScalarWhereInput
    data: XOR<ep_cash_per_dayUpdateManyMutationInput, ep_cash_per_dayUncheckedUpdateManyWithoutEp_usersInput>
  }

  export type ep_cash_per_dayScalarWhereInput = {
    AND?: ep_cash_per_dayScalarWhereInput | ep_cash_per_dayScalarWhereInput[]
    OR?: ep_cash_per_dayScalarWhereInput[]
    NOT?: ep_cash_per_dayScalarWhereInput | ep_cash_per_dayScalarWhereInput[]
    cpd_id?: IntFilter<"ep_cash_per_day"> | number
    cpd_amount?: DecimalFilter<"ep_cash_per_day"> | Decimal | DecimalJsLike | number | string
    cpd_user_id?: IntFilter<"ep_cash_per_day"> | number
    cpd_date?: DateTimeFilter<"ep_cash_per_day"> | Date | string
    cpd_version?: IntFilter<"ep_cash_per_day"> | number
  }

  export type ep_notesUpsertWithWhereUniqueWithoutUserInput = {
    where: ep_notesWhereUniqueInput
    update: XOR<ep_notesUpdateWithoutUserInput, ep_notesUncheckedUpdateWithoutUserInput>
    create: XOR<ep_notesCreateWithoutUserInput, ep_notesUncheckedCreateWithoutUserInput>
  }

  export type ep_notesUpdateWithWhereUniqueWithoutUserInput = {
    where: ep_notesWhereUniqueInput
    data: XOR<ep_notesUpdateWithoutUserInput, ep_notesUncheckedUpdateWithoutUserInput>
  }

  export type ep_notesUpdateManyWithWhereWithoutUserInput = {
    where: ep_notesScalarWhereInput
    data: XOR<ep_notesUpdateManyMutationInput, ep_notesUncheckedUpdateManyWithoutUserInput>
  }

  export type ep_notesScalarWhereInput = {
    AND?: ep_notesScalarWhereInput | ep_notesScalarWhereInput[]
    OR?: ep_notesScalarWhereInput[]
    NOT?: ep_notesScalarWhereInput | ep_notesScalarWhereInput[]
    ep_note_id?: IntFilter<"ep_notes"> | number
    ep_note_user?: IntFilter<"ep_notes"> | number
    ep_note_content?: StringFilter<"ep_notes"> | string
    ep_note_date?: DateTimeFilter<"ep_notes"> | Date | string
  }

  export type ep_usersCreateWithoutEp_cash_per_dayInput = {
    users_name: string
    users_lastname: string
    users_ced: string
    users_version: number
    user_username: string
    user_password: string
    users_email: string
    notes?: ep_notesCreateNestedManyWithoutUserInput
  }

  export type ep_usersUncheckedCreateWithoutEp_cash_per_dayInput = {
    users_id?: number
    users_name: string
    users_lastname: string
    users_ced: string
    users_version: number
    user_username: string
    user_password: string
    users_email: string
    notes?: ep_notesUncheckedCreateNestedManyWithoutUserInput
  }

  export type ep_usersCreateOrConnectWithoutEp_cash_per_dayInput = {
    where: ep_usersWhereUniqueInput
    create: XOR<ep_usersCreateWithoutEp_cash_per_dayInput, ep_usersUncheckedCreateWithoutEp_cash_per_dayInput>
  }

  export type ep_usersUpsertWithoutEp_cash_per_dayInput = {
    update: XOR<ep_usersUpdateWithoutEp_cash_per_dayInput, ep_usersUncheckedUpdateWithoutEp_cash_per_dayInput>
    create: XOR<ep_usersCreateWithoutEp_cash_per_dayInput, ep_usersUncheckedCreateWithoutEp_cash_per_dayInput>
    where?: ep_usersWhereInput
  }

  export type ep_usersUpdateToOneWithWhereWithoutEp_cash_per_dayInput = {
    where?: ep_usersWhereInput
    data: XOR<ep_usersUpdateWithoutEp_cash_per_dayInput, ep_usersUncheckedUpdateWithoutEp_cash_per_dayInput>
  }

  export type ep_usersUpdateWithoutEp_cash_per_dayInput = {
    users_name?: StringFieldUpdateOperationsInput | string
    users_lastname?: StringFieldUpdateOperationsInput | string
    users_ced?: StringFieldUpdateOperationsInput | string
    users_version?: IntFieldUpdateOperationsInput | number
    user_username?: StringFieldUpdateOperationsInput | string
    user_password?: StringFieldUpdateOperationsInput | string
    users_email?: StringFieldUpdateOperationsInput | string
    notes?: ep_notesUpdateManyWithoutUserNestedInput
  }

  export type ep_usersUncheckedUpdateWithoutEp_cash_per_dayInput = {
    users_id?: IntFieldUpdateOperationsInput | number
    users_name?: StringFieldUpdateOperationsInput | string
    users_lastname?: StringFieldUpdateOperationsInput | string
    users_ced?: StringFieldUpdateOperationsInput | string
    users_version?: IntFieldUpdateOperationsInput | number
    user_username?: StringFieldUpdateOperationsInput | string
    user_password?: StringFieldUpdateOperationsInput | string
    users_email?: StringFieldUpdateOperationsInput | string
    notes?: ep_notesUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ep_cashier_transactionCreateWithoutCashierInput = {
    cash_trans_amount: string
    cash_trans_type: string
    cash_trans_method: string
    cash_trans_date: Date | string
  }

  export type ep_cashier_transactionUncheckedCreateWithoutCashierInput = {
    cash_trans_id?: number
    cash_trans_amount: string
    cash_trans_type: string
    cash_trans_method: string
    cash_trans_date: Date | string
  }

  export type ep_cashier_transactionCreateOrConnectWithoutCashierInput = {
    where: ep_cashier_transactionWhereUniqueInput
    create: XOR<ep_cashier_transactionCreateWithoutCashierInput, ep_cashier_transactionUncheckedCreateWithoutCashierInput>
  }

  export type ep_cashier_transactionCreateManyCashierInputEnvelope = {
    data: ep_cashier_transactionCreateManyCashierInput | ep_cashier_transactionCreateManyCashierInput[]
    skipDuplicates?: boolean
  }

  export type ep_cashier_transactionUpsertWithWhereUniqueWithoutCashierInput = {
    where: ep_cashier_transactionWhereUniqueInput
    update: XOR<ep_cashier_transactionUpdateWithoutCashierInput, ep_cashier_transactionUncheckedUpdateWithoutCashierInput>
    create: XOR<ep_cashier_transactionCreateWithoutCashierInput, ep_cashier_transactionUncheckedCreateWithoutCashierInput>
  }

  export type ep_cashier_transactionUpdateWithWhereUniqueWithoutCashierInput = {
    where: ep_cashier_transactionWhereUniqueInput
    data: XOR<ep_cashier_transactionUpdateWithoutCashierInput, ep_cashier_transactionUncheckedUpdateWithoutCashierInput>
  }

  export type ep_cashier_transactionUpdateManyWithWhereWithoutCashierInput = {
    where: ep_cashier_transactionScalarWhereInput
    data: XOR<ep_cashier_transactionUpdateManyMutationInput, ep_cashier_transactionUncheckedUpdateManyWithoutCashierInput>
  }

  export type ep_cashier_transactionScalarWhereInput = {
    AND?: ep_cashier_transactionScalarWhereInput | ep_cashier_transactionScalarWhereInput[]
    OR?: ep_cashier_transactionScalarWhereInput[]
    NOT?: ep_cashier_transactionScalarWhereInput | ep_cashier_transactionScalarWhereInput[]
    cash_trans_id?: IntFilter<"ep_cashier_transaction"> | number
    cash_trans_amount?: StringFilter<"ep_cashier_transaction"> | string
    cash_trans_type?: StringFilter<"ep_cashier_transaction"> | string
    cash_trans_method?: StringFilter<"ep_cashier_transaction"> | string
    cash_trans_date?: DateTimeFilter<"ep_cashier_transaction"> | Date | string
    cash_trans_cashier_id?: IntFilter<"ep_cashier_transaction"> | number
  }

  export type ep_cashierCreateWithoutTransactionsInput = {
    cash_type: string
    cash_amount: Decimal | DecimalJsLike | number | string
    cash_date: Date | string
    cash_version: number
    cash_movement_type?: string | null
  }

  export type ep_cashierUncheckedCreateWithoutTransactionsInput = {
    cash_id?: number
    cash_type: string
    cash_amount: Decimal | DecimalJsLike | number | string
    cash_date: Date | string
    cash_version: number
    cash_movement_type?: string | null
  }

  export type ep_cashierCreateOrConnectWithoutTransactionsInput = {
    where: ep_cashierWhereUniqueInput
    create: XOR<ep_cashierCreateWithoutTransactionsInput, ep_cashierUncheckedCreateWithoutTransactionsInput>
  }

  export type ep_cashierUpsertWithoutTransactionsInput = {
    update: XOR<ep_cashierUpdateWithoutTransactionsInput, ep_cashierUncheckedUpdateWithoutTransactionsInput>
    create: XOR<ep_cashierCreateWithoutTransactionsInput, ep_cashierUncheckedCreateWithoutTransactionsInput>
    where?: ep_cashierWhereInput
  }

  export type ep_cashierUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: ep_cashierWhereInput
    data: XOR<ep_cashierUpdateWithoutTransactionsInput, ep_cashierUncheckedUpdateWithoutTransactionsInput>
  }

  export type ep_cashierUpdateWithoutTransactionsInput = {
    cash_type?: StringFieldUpdateOperationsInput | string
    cash_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cash_date?: DateTimeFieldUpdateOperationsInput | Date | string
    cash_version?: IntFieldUpdateOperationsInput | number
    cash_movement_type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ep_cashierUncheckedUpdateWithoutTransactionsInput = {
    cash_id?: IntFieldUpdateOperationsInput | number
    cash_type?: StringFieldUpdateOperationsInput | string
    cash_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cash_date?: DateTimeFieldUpdateOperationsInput | Date | string
    cash_version?: IntFieldUpdateOperationsInput | number
    cash_movement_type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ep_usersCreateWithoutNotesInput = {
    users_name: string
    users_lastname: string
    users_ced: string
    users_version: number
    user_username: string
    user_password: string
    users_email: string
    ep_cash_per_day?: ep_cash_per_dayCreateNestedManyWithoutEp_usersInput
  }

  export type ep_usersUncheckedCreateWithoutNotesInput = {
    users_id?: number
    users_name: string
    users_lastname: string
    users_ced: string
    users_version: number
    user_username: string
    user_password: string
    users_email: string
    ep_cash_per_day?: ep_cash_per_dayUncheckedCreateNestedManyWithoutEp_usersInput
  }

  export type ep_usersCreateOrConnectWithoutNotesInput = {
    where: ep_usersWhereUniqueInput
    create: XOR<ep_usersCreateWithoutNotesInput, ep_usersUncheckedCreateWithoutNotesInput>
  }

  export type ep_usersUpsertWithoutNotesInput = {
    update: XOR<ep_usersUpdateWithoutNotesInput, ep_usersUncheckedUpdateWithoutNotesInput>
    create: XOR<ep_usersCreateWithoutNotesInput, ep_usersUncheckedCreateWithoutNotesInput>
    where?: ep_usersWhereInput
  }

  export type ep_usersUpdateToOneWithWhereWithoutNotesInput = {
    where?: ep_usersWhereInput
    data: XOR<ep_usersUpdateWithoutNotesInput, ep_usersUncheckedUpdateWithoutNotesInput>
  }

  export type ep_usersUpdateWithoutNotesInput = {
    users_name?: StringFieldUpdateOperationsInput | string
    users_lastname?: StringFieldUpdateOperationsInput | string
    users_ced?: StringFieldUpdateOperationsInput | string
    users_version?: IntFieldUpdateOperationsInput | number
    user_username?: StringFieldUpdateOperationsInput | string
    user_password?: StringFieldUpdateOperationsInput | string
    users_email?: StringFieldUpdateOperationsInput | string
    ep_cash_per_day?: ep_cash_per_dayUpdateManyWithoutEp_usersNestedInput
  }

  export type ep_usersUncheckedUpdateWithoutNotesInput = {
    users_id?: IntFieldUpdateOperationsInput | number
    users_name?: StringFieldUpdateOperationsInput | string
    users_lastname?: StringFieldUpdateOperationsInput | string
    users_ced?: StringFieldUpdateOperationsInput | string
    users_version?: IntFieldUpdateOperationsInput | number
    user_username?: StringFieldUpdateOperationsInput | string
    user_password?: StringFieldUpdateOperationsInput | string
    users_email?: StringFieldUpdateOperationsInput | string
    ep_cash_per_day?: ep_cash_per_dayUncheckedUpdateManyWithoutEp_usersNestedInput
  }

  export type ep_cash_per_dayCreateManyEp_usersInput = {
    cpd_id?: number
    cpd_amount: Decimal | DecimalJsLike | number | string
    cpd_date: Date | string
    cpd_version: number
  }

  export type ep_notesCreateManyUserInput = {
    ep_note_id?: number
    ep_note_content: string
    ep_note_date?: Date | string
  }

  export type ep_cash_per_dayUpdateWithoutEp_usersInput = {
    cpd_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cpd_date?: DateTimeFieldUpdateOperationsInput | Date | string
    cpd_version?: IntFieldUpdateOperationsInput | number
  }

  export type ep_cash_per_dayUncheckedUpdateWithoutEp_usersInput = {
    cpd_id?: IntFieldUpdateOperationsInput | number
    cpd_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cpd_date?: DateTimeFieldUpdateOperationsInput | Date | string
    cpd_version?: IntFieldUpdateOperationsInput | number
  }

  export type ep_cash_per_dayUncheckedUpdateManyWithoutEp_usersInput = {
    cpd_id?: IntFieldUpdateOperationsInput | number
    cpd_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cpd_date?: DateTimeFieldUpdateOperationsInput | Date | string
    cpd_version?: IntFieldUpdateOperationsInput | number
  }

  export type ep_notesUpdateWithoutUserInput = {
    ep_note_content?: StringFieldUpdateOperationsInput | string
    ep_note_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ep_notesUncheckedUpdateWithoutUserInput = {
    ep_note_id?: IntFieldUpdateOperationsInput | number
    ep_note_content?: StringFieldUpdateOperationsInput | string
    ep_note_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ep_notesUncheckedUpdateManyWithoutUserInput = {
    ep_note_id?: IntFieldUpdateOperationsInput | number
    ep_note_content?: StringFieldUpdateOperationsInput | string
    ep_note_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ep_cashier_transactionCreateManyCashierInput = {
    cash_trans_id?: number
    cash_trans_amount: string
    cash_trans_type: string
    cash_trans_method: string
    cash_trans_date: Date | string
  }

  export type ep_cashier_transactionUpdateWithoutCashierInput = {
    cash_trans_amount?: StringFieldUpdateOperationsInput | string
    cash_trans_type?: StringFieldUpdateOperationsInput | string
    cash_trans_method?: StringFieldUpdateOperationsInput | string
    cash_trans_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ep_cashier_transactionUncheckedUpdateWithoutCashierInput = {
    cash_trans_id?: IntFieldUpdateOperationsInput | number
    cash_trans_amount?: StringFieldUpdateOperationsInput | string
    cash_trans_type?: StringFieldUpdateOperationsInput | string
    cash_trans_method?: StringFieldUpdateOperationsInput | string
    cash_trans_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ep_cashier_transactionUncheckedUpdateManyWithoutCashierInput = {
    cash_trans_id?: IntFieldUpdateOperationsInput | number
    cash_trans_amount?: StringFieldUpdateOperationsInput | string
    cash_trans_type?: StringFieldUpdateOperationsInput | string
    cash_trans_method?: StringFieldUpdateOperationsInput | string
    cash_trans_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}